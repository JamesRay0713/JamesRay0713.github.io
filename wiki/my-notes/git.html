<!DOCTYPE html>
<html lang='zh-CN'>


<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.23.0" theme-name="Stellar" theme-version="1.23.0">
  
  <meta name="generator" content="Hexo 7.0.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>笔记本：Git学习 - 分你一半</title>

  
    <meta name="description" content="资料菜鸟：菜鸟教程，最佳简明指南git: 总站；文档：命令手册、书籍、速查表、howto ；深入学习：像git一样思考，图解github，其他链接github: 帮助中心，文档中心   TIPS: 文中的PR代表pull request；fork等于‘派生’。  一些重要概念一些语法杂项&lt;branch&gt;@&#123;&lt;筛选条件&gt;&#125;, 见 指定提交我们有许多引用（H">
<meta property="og:type" content="website">
<meta property="og:title" content="Git学习">
<meta property="og:url" content="https://taddream.site/wiki/my-notes/git.html">
<meta property="og:site_name" content="分你一半">
<meta property="og:description" content="资料菜鸟：菜鸟教程，最佳简明指南git: 总站；文档：命令手册、书籍、速查表、howto ；深入学习：像git一样思考，图解github，其他链接github: 帮助中心，文档中心   TIPS: 文中的PR代表pull request；fork等于‘派生’。  一些重要概念一些语法杂项&lt;branch&gt;@&#123;&lt;筛选条件&gt;&#125;, 见 指定提交我们有许多引用（H">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://assets.taddream.site/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%9B%BE%E8%A7%A3.png">
<meta property="og:image" content="http://assets.taddream.site/wiki/my-notes/%E5%9B%BE%E8%A7%A3-%E5%88%86%E6%94%AF%E5%8D%B3%E6%8C%87%E9%92%88.png">
<meta property="og:image" content="http://assets.taddream.site/wiki/my-notes/%E5%9B%BE%E8%A7%A3-git%E4%B8%89%E6%96%B9%E5%90%88%E5%B9%B6.png">
<meta property="og:image" content="http://assets.taddream.site/wiki/my-notes/%E5%9B%BE%E8%A7%A3-%E5%8F%98%E5%9F%BA%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4.png">
<meta property="og:image" content="http://assets.taddream.site/wiki/my-notes/%E5%9B%BE%E8%A7%A3-fetch%E4%BA%86%E5%8F%98%E5%9F%BA%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8E%E4%BD%BF%E7%94%A8merge%E5%92%8Crebase%E7%9A%84%E5%8C%BA%E5%88%AB.png">
<meta property="og:image" content="http://assets.taddream.site/wiki/my-notes/%E5%9B%BE%E8%A7%A3-%E5%8F%98%E5%9F%BA%E7%9A%84%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD.png">
<meta property="og:image" content="http://assets.taddream.site/wiki/my-notes/GitHub%E4%B8%8A%E5%88%9B%E5%BB%BAPR.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/maint-02-merge.png">
<meta property="og:image" content="http://assets.taddream.site/wiki/my-notes/%E5%9B%BE%E8%A7%A3-%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%90%88%E5%B9%B6%E5%BE%AA%E7%8E%AF.png">
<meta property="og:image" content="http://assets.taddream.site/wiki/my-notes/github-markdown-%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8.png">
<meta property="og:image" content="http://assets.taddream.site/wiki/my-notes/github-%E5%90%8C%E6%AD%A5fork%E6%8C%89%E9%92%AE.png">
<meta property="og:image" content="http://assets.taddream.site/wiki/my-notes/git-rebase-i%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E8%BF%9B%E5%BA%A6.png">
<meta property="article:published_time" content="2024-02-03T00:07:31.435Z">
<meta property="article:modified_time" content="2024-02-03T00:07:31.435Z">
<meta property="article:author" content="JamesRay">
<meta property="article:tag" content="技术, 生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://assets.taddream.site/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%9B%BE%E8%A7%A3.png">
  
  
  
  <meta name="keywords" content="技术, 生活">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="分你一半" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="http://assets.taddream.site/build_site_images/网站图标2.png">
  

  
    
<link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/atom-one-dark.min.css">

  

  
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap" rel="stylesheet">
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/social/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.9/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="http://assets.taddream.site/build_site_images/蚪狐狸头像.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.9/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">分你一半</div><div class="sub normal cap">tadpole in dreams ~~</div><div class="sub hover cap" style="opacity:0"> turning in circles</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">博客</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/explore/">探索</a><a class="nav-item" href="/social/">社交</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/wiki/my-notes/" placeholder="search in my-notes ..."><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc multi" id="data-toc" collapse="true"><div class="widget-body fs14"></div><div class="widget-header cap dis-select"><span class="name">后端开发</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/my-notes/server-webserver-apache.html"><span class="toc-text">web服务器-Apache</span></a></div></div><div class="widget-header cap dis-select"><span class="name">前端开发</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/my-notes/html-css-js.html"><span class="toc-text">HTML+CSS+JS+jQuery+AJAX</span></a></div></div><div class="widget-header cap dis-select"><span class="name">工具类</span></div><div class="widget-body fs14"><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/my-notes/git.html"><span class="toc-text">Git学习</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-text">一些重要概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95"><span class="toc-text">一些语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-text">杂项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%8F%90%E4%BA%A4"><span class="toc-text">指定提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%8C%BA"><span class="toc-text">三区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pull-Request"><span class="toc-text">Pull-Request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">Git配置和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">使用前的配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%9C%89%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">其他有用配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git%E5%91%BD%E4%BB%A4"><span class="toc-text">Git命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%B1%BB"><span class="toc-text">基础类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#git-add"><span class="toc-text">git add</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-commit"><span class="toc-text">git commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-rm"><span class="toc-text">git rm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-mv"><span class="toc-text">git mv</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B1%BB"><span class="toc-text">查看类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#git-status-s"><span class="toc-text">git status -s</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-show"><span class="toc-text">git show</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-reflog"><span class="toc-text">git reflog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-diff"><span class="toc-text">git diff</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-log"><span class="toc-text">git log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-grep"><span class="toc-text">git grep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-blame"><span class="toc-text">git blame</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%90%84%E7%A7%8D%E6%8C%87%E9%92%88"><span class="toc-text">查看各种指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF"><span class="toc-text">查看分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E5%BC%95%E7%94%A8"><span class="toc-text">查看所有引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%92%8C%E9%87%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">撤销和重置类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%90%86-clean"><span class="toc-text">清理 clean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AE%E8%97%8F-stash"><span class="toc-text">贮藏 stash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D"><span class="toc-text">恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E7%B1%BB"><span class="toc-text">标签类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#git-tag"><span class="toc-text">git tag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-describe"><span class="toc-text">git describe &lt;branch&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="toc-text">远程相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%81"><span class="toc-text">见</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%9B%B8%E5%85%B3"><span class="toc-text">分支相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%81-1"><span class="toc-text">见</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-checkout"><span class="toc-text">git checkout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-switch"><span class="toc-text">git switch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%9B%B8%E5%85%B3"><span class="toc-text">发布相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB"><span class="toc-text">其他类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E5%91%BD%E4%BB%A4"><span class="toc-text">管道命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git%E8%BF%9C%E7%A8%8B"><span class="toc-text">Git远程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%9F%A5%E7%9C%8B%E3%80%81%E5%A2%9E%E5%88%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-text">命令：查看、增删远程仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%EF%BC%9A%E4%B8%8B%E8%BD%BD%E3%80%81%E6%8B%89%E5%8F%96"><span class="toc-text">命令：下载、拉取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%8E%A8%E9%80%81"><span class="toc-text">命令：推送</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%98%85-Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%EF%BC%81"><span class="toc-text">★ Git分支管理！</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4"><span class="toc-text">一些命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6"><span class="toc-text">场景：分支的新建与合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-text">分支开发工作流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="toc-text">远程分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E5%9F%BA%E4%B8%8E%E5%90%88%E5%B9%B6"><span class="toc-text">变基与合并</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E5%9F%BA-rebase"><span class="toc-text">变基-rebase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A3%E9%80%89-cherry-pick"><span class="toc-text">拣选-cherry-pick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6-merge"><span class="toc-text">合并-merge</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%85%AC%E5%85%B1%E4%BB%93%E5%BA%93"><span class="toc-text">Git服务器(公共仓库)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E7%A7%8D%E5%8D%8F%E8%AE%AE"><span class="toc-text">4种协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8SSH%E5%8D%8F%E8%AE%AE%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1"><span class="toc-text">用SSH协议搭建Git服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8Git%E5%8D%8F%E8%AE%AE%E6%90%AD%E5%BB%BA"><span class="toc-text">用Git协议搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-smart-HTTP%E6%90%AD%E5%BB%BA"><span class="toc-text">用 smart HTTP搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">系统环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E6%9D%83%E9%99%90"><span class="toc-text">改权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%88%E6%9D%83"><span class="toc-text">授权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%90%AF"><span class="toc-text">重启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bingo%EF%BC%81%E6%B5%8B%E8%AF%95"><span class="toc-text">bingo！测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8BGitWeb"><span class="toc-text">建立GitWeb</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%B4%E6%97%B6web"><span class="toc-text">查看临时web</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E7%BB%B4%E6%8A%A4%E7%9A%84web"><span class="toc-text">持续维护的web</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8BGitLab-better-GitWeb"><span class="toc-text">建立GitLab (better GitWeb)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git%E7%9A%84%E5%8D%8F%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">Git的协作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">分布式工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-text">集中式工作流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E7%AE%A1%E7%90%86%E8%80%85%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-text">集成管理者工作流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%AE%A1%E4%B8%8E%E5%89%AF%E4%B8%BB%E7%AE%A1%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-text">主管与副主管工作流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%90%88-%E7%AE%A1%E7%90%86%E8%80%85%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-text">整合-管理者工作流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A1%E7%8C%AE%E9%A1%B9%E7%9B%AE"><span class="toc-text">贡献项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A1%E7%8C%AE%E5%8E%9F%E5%88%99"><span class="toc-text">贡献原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%BA%A7%E5%88%AB%E7%9A%84%E5%9B%A2%E9%98%9F%E4%B8%AD"><span class="toc-text">在不同级别的团队中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%85%AC%E5%BC%80%E9%A1%B9%E7%9B%AE-%E7%94%A8fork-PR"><span class="toc-text">在公开项目-用fork-PR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EPull-Request"><span class="toc-text">关于Pull-Request</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%85%AC%E5%BC%80%E9%A1%B9%E7%9B%AE-%E7%94%A8%E9%82%AE%E4%BB%B6"><span class="toc-text">在公开项目-用邮件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E9%A1%B9%E7%9B%AE"><span class="toc-text">维护项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AF%BC%E5%85%A5%E5%A4%A7%E5%AE%B6%E7%9A%84%E8%B4%A1%E7%8C%AE"><span class="toc-text">1、导入大家的贡献</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF1%EF%BC%9A%E8%B4%A1%E7%8C%AE%E8%80%85%E9%82%AE%E4%BB%B6%E4%BC%A0%E6%9D%A5-patch"><span class="toc-text">场景1：贡献者邮件传来.patch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF2%EF%BC%9A%E8%B4%A1%E7%8C%AE%E8%80%85%E7%94%A8fork-PullRequest"><span class="toc-text">场景2：贡献者用fork+PullRequest</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%A3%80%E6%9F%A5%E8%B4%A1%E7%8C%AE%E5%86%85%E5%AE%B9"><span class="toc-text">2、检查贡献内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%90%88%E5%B9%B6%E8%B4%A1%E7%8C%AE%E5%86%85%E5%AE%B9"><span class="toc-text">3、合并贡献内容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%90%88%E5%B9%B6%E5%B7%A5%E4%BD%9C%E6%B5%81%E2%80%93%E4%B8%A4%E9%98%B6%E6%AE%B5"><span class="toc-text">常见合并工作流–两阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E9%A1%B9%E7%9B%AE%E5%90%88%E5%B9%B6%E5%B7%A5%E4%BD%9C%E6%B5%81%E2%80%93%E5%9B%9B%E9%98%B6%E6%AE%B5"><span class="toc-text">大项目合并工作流–四阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E5%9F%BA%E4%B8%8E%E6%8B%A3%E9%80%89%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-text">变基与拣选工作流</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%B8%BA%E5%8F%91%E5%B8%83%E6%89%93%E6%A0%87%E7%AD%BE"><span class="toc-text">4、为发布打标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E7%94%9F%E6%88%90%E6%9E%84%E5%BB%BA%E5%8F%B7-%E5%8F%AF%E9%80%89"><span class="toc-text">5、生成构建号(可选)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%87%86%E5%A4%87%E4%B8%80%E6%AC%A1%E5%8F%91%E5%B8%83"><span class="toc-text">6、准备一次发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%88%B6%E4%BD%9C%E6%8F%90%E4%BA%A4%E7%AE%80%E6%8A%A5"><span class="toc-text">7、制作提交简报</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GitHub"><span class="toc-text">GitHub</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A1%E7%8C%AE%E9%A1%B9%E7%9B%AE-1"><span class="toc-text">贡献项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GitHub%E9%A3%8E%E6%A0%BC%E7%9A%84Markdown"><span class="toc-text">GitHub风格的Markdown</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8"><span class="toc-text">任务列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%88%AB%E4%BA%BA%E8%AF%84%E8%AE%BA%E7%9A%84%E9%83%A8%E5%88%86%E5%8F%A5%E5%AD%90"><span class="toc-text">引用别人评论的部分句子</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E6%83%85%E7%AC%A6%E5%8F%B7"><span class="toc-text">表情符号</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A9%E6%B4%BE%E7%94%9F%E4%BB%93%E5%BA%93%E4%BF%9D%E6%8C%81%E6%9B%B4%E6%96%B0"><span class="toc-text">让派生仓库保持更新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E9%A1%B9%E7%9B%AE-1"><span class="toc-text">维护项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%AE%A1%E7%90%86%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82"><span class="toc-text">3、管理合并请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6"><span class="toc-text">6、特殊文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%BB%84%E7%BB%87"><span class="toc-text">管理组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%9A%E6%9C%ACGitHub"><span class="toc-text">脚本GitHub</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%A9%E5%AD%90"><span class="toc-text">钩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GitHub-API"><span class="toc-text">GitHub API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git%E5%B7%A5%E5%85%B7"><span class="toc-text">Git工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98"><span class="toc-text">交互式暂存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AE%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-text">贮藏与清理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AE%E8%97%8F"><span class="toc-text">贮藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%90%86"><span class="toc-text">清理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E5%B7%A5%E5%85%B7"><span class="toc-text">签名工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E6%96%87%E4%BB%B6"><span class="toc-text">搜文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E6%8F%90%E4%BA%A4"><span class="toc-text">搜提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2"><span class="toc-text">重写历史</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4"><span class="toc-text">修改最后一次提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E6%8F%90%E4%BA%A4"><span class="toc-text">同时处理多个提交</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC1%EF%BC%9A%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA-%E5%A4%9A%E4%B8%AA%E5%8E%86%E5%8F%B2%E7%9A%84%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF"><span class="toc-text">脚本1：修改一个&#x2F;多个历史的提交信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC2%EF%BC%9A%E5%88%A0%E9%99%A4%E9%83%A8%E5%88%86%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4"><span class="toc-text">脚本2：删除部分历史提交</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC3%EF%BC%9A%E9%87%8D%E6%8E%92%E5%BA%8F%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4"><span class="toc-text">脚本3：重排序历史提交</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC4%EF%BC%9A"><span class="toc-text">脚本4：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git%E4%BB%93%E5%BA%93%E5%B7%A5%E5%85%B7"><span class="toc-text">Git仓库工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7gitk"><span class="toc-text">可视化工具gitk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8FGitWeb"><span class="toc-text">轻量GitWeb</span></a></li></ol></li></ol></div></div><div class="widget-header cap dis-select"><span class="name">日常笔记</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/my-notes/set-of-debug-and-pieces-of-knowledge.html"><span class="toc-text">debug集合</span></a></div></div></widget>



<widget class="widget-wrapper recent"><div class="widget-header cap theme dis-select"><span class="name">最近更新</span></div><div class="widget-body related-posts fs14"><a class="item title" href="/post/topic-security/"><span class="title">加解密及安全话题</span></a><a class="item title" href="/post/manual-useful-command/"><span class="title">常用代码/命令手册</span></a><a class="item title" href="/post/toolkit02-about-network-connection/"><span class="title">网络连接相关</span></a><a class="item title" href="/post/manual-debug/"><span class="title">手册：debug</span></a><a class="item title" href="/post/manual-manage-blog/"><span class="title">手册：管理hexo-stellar博客</span></a></div></widget>
</div>


    </aside>
    <div class='l_main'>
      

      

  
  
<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/">博客</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/my-notes/">笔记本</a></div><div id="post-meta">
    <span>更新于&nbsp;<time datetime="2024-02-03T00:07:31.435Z">2024年2月3日</time></span>
    </div></div></div>

  <article class='md-text content wiki'>
  <h1 class="article-title"><span>Git学习</span></h1>
  <details class="tag-plugin colorful folding" ><summary><span>资料</span></summary><div class="body"><ul><li>菜鸟：<a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程</a>，最佳<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/git-guide/">简明指南</a></li><li>git: <a target="_blank" rel="noopener" href="https://git-scm.com/">总站</a>；<ul><li>文档：<a target="_blank" rel="noopener" href="https://git-scm.com/docs">命令手册</a>、<a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2">书籍</a>、<a target="_blank" rel="noopener" href="https://training.github.com/downloads/zh_CN/github-git-cheat-sheet/">速查表</a>、<a target="_blank" rel="noopener" href="https://github.com/git/git/tree/master/Documentation/howto">howto</a> ；</li><li>深入学习：<a target="_blank" rel="noopener" href="https://think-like-a-git.net/">像git一样思考</a>，<a target="_blank" rel="noopener" href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解github</a>，<a target="_blank" rel="noopener" href="https://git-scm.com/doc/ext">其他链接</a></li></ul></li><li>github: <a target="_blank" rel="noopener" href="https://support.github.com/">帮助中心</a>，<a target="_blank" rel="noopener" href="https://docs.github.com/zh">文档中心</a></li></ul></div></details>

<blockquote>
<p>TIPS: 文中的<code>PR</code>代表<code>pull request</code>；fork等于‘派生’。</p>
</blockquote>
<h2 id="一些重要概念"><a href="#一些重要概念" class="headerlink" title="一些重要概念"></a>一些重要概念</h2><h3 id="一些语法"><a href="#一些语法" class="headerlink" title="一些语法"></a>一些语法</h3><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><p><code>&lt;branch&gt;@&#123;&lt;筛选条件&gt;&#125;</code>, <a href="#%E5%BC%95%E7%94%A8%E6%97%A5%E5%BF%97">见</a></p>
<h4 id="指定提交"><a href="#指定提交" class="headerlink" title="指定提交"></a>指定提交</h4><p>我们有许多引用（HEAD，branch，tag，commitID）来找到这些引用所指向的提交，而有更多的历史提交该如何索引到呢？<br>下面的例子我都将用<code>HEAD</code>代表引用</p>
<ol>
<li>指定单个提交:<br>  <code>^3</code>是第三个爸爸（前提是对应提交有多个爸爸，0是自己，1和<code>置空</code>是爸爸，2是二爸，…）；<br>  <code>~3</code>是第三层长辈（0是自己，1和<code>置空</code>是爸爸，2是爷爷，…）。</li>
</ol>
<ul>
<li>举例：<code>HEAD^</code>, 指向该引用的<code>父提交</code>。<code>HEAD^2</code>, 指向第二个父提交。</li>
<li>举例：<code>HEAD~2</code> 代表“<code>第一父</code>提交的<code>第一父</code>提交”，也就是“祖父提交”</li>
<li>举例：<code>HEAD~3^2</code> HEAD的曾祖父的第二个父亲。</li>
</ul>
<ol>
<li>指定提交区间</li>
</ol>
<ul>
<li>双点：选出在一个分支中而不在另一个分支中的提交<ul>
<li><code>git log experiment..master</code> 显示在 master 分支中而不在 experiment 分支中的提交</li>
<li>如果你留空了其中的一边， Git 会默认为 HEAD</li>
<li>常用: 查看你即将推送到远端的内容 <div class="tag-plugin copy"><span>$</span><input class="copy-area" id="copy_17" value="git log origin/master..HEAD"><button class="copy-btn" onclick="util.copy(&quot;copy_17&quot;,&quot;复制成功&quot;)"><svg class="icon copy-btn" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path></svg></button></div></li>
</ul>
</li>
<li>多点：在任意引用前加上 ^ 字符或者 –not 来指明你不希望提交被包含其中的分支。<figure class="highlight bash"><figcaption><span>三者等价</span></figcaption><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> refA..refB<br>git <span class="hljs-built_in">log</span> ^refA refB<br>git <span class="hljs-built_in">log</span> refB --not refA<br></code></pre></td></tr></table></figure>
<code>git log refA refB ^refC</code> 所有被 refA 或 refB 包含的但是不被 refC 包含的提交。</li>
<li>三点：选择出被两个引用 之一 包含但又不被两者同时包含的提交。<br><code>git log master...experiment</code> 比较’后者分支’和’两者<code>公共祖先</code>分支’之间的差异。</li>
</ul>
<h3 id="三区"><a href="#三区" class="headerlink" title="三区"></a>三区</h3><p>代表工作目录、暂存区(index)、本地仓库（commit快照的集合、版本库）。</p>
<h3 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull-Request"></a>Pull-Request</h3><p><a href="#%E5%85%B3%E4%BA%8EPull-Request">参考</a></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>是指向 Git 数据库中某个提交（commit）的<code>指针</code>。查看引用的命令<a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E5%BC%95%E7%94%A8">见</a>。<br>· 本地的引用：</p>
<ul>
<li>HEAD类<ul>
<li>【HEAD】：（必有！<code>.git/HEAD</code>）是指向当前工作目录所在分支的指针。一般HEAD指向分支，所以它是<code>指向指针的指针</code>。</li>
<li>detached HEAD： <a name="detached-head"></a>（可有）意味着 HEAD 指向的是一个特定的提交（commit），而不是分支。所以它是<code>指向对象的指针</code>。在这种状态下的提交将不属于任何分支。为此建议新建一个分支来承接这个提交对象。</li>
<li>FETCH_HEAD：（可有，<code>.git/FETCH_HEAD</code>）指向最近一次从远程存储库获取的提交。</li>
<li>ORIG_HEAD：（可有，<code>.git/ORIG_HEAD</code>）保存某些操作前的 HEAD 的值，用于回滚。它通常用于在执行危险的操作（例如git reset）之前保存 HEAD 的位置。</li>
</ul>
</li>
<li>分支（branch）: （如<code>.git/refs/heads/master</code>）<blockquote>
<p>当本地分支追踪着一个远程分支，则此时本地分支叫<code>跟踪分支</code>，远程的叫<code>上游分支</code>。</p>
</blockquote>
</li>
<li>标签（tag）:（如<code>.git/refs/tags/1.0.0</code>）</li>
<li>PR型分支: 本地不会存在这种分支</li>
</ul>
<p>· 远程的引用:（注意，一个版本库可以连接多个remote）</p>
<ul>
<li><p>(HEAD不会存在于远程)</p>
</li>
<li><p>远程分支：（如<code>.git/refs/remotes/master</code>）<a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">详见</a></p>
</li>
<li><p>远程标签。</p>
</li>
<li><p>合并请求分支&#x2F;PR分支：（如<code>refs/pull/&lt;pr#&gt;/head</code>） <a name="PR分支"></a></p>
<ul>
<li>由来：<code>远程源仓库</code>一旦有PR发生，就会生成这样一个分支型引用，指向<code>派生仓库</code>里想要合并的那个分支的最新提交快照。clone和fetch都会忽略这类引用，因此可称作一种<code>假分支</code>。</li>
<li>优点：本质来讲，仓库内的一个引用，却指向了仓库外的一个资源，还不用过问这个资源的url，简直就是为高效的<code>pull request</code>量身定做的。</li>
<li>查看这种分支列表的方法：<a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E5%BC%95%E7%94%A8">参考</a> </li>
<li>如何使用：<a href="#%E5%9C%BA%E6%99%AF2%EF%BC%9A%E8%B4%A1%E7%8C%AE%E8%80%85%E7%94%A8fork+PullRequest">参考</a> 方法4。</li>
</ul>
</li>
<li><p>命令图解：<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://assets.taddream.site/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%9B%BE%E8%A7%A3.png" alt="git常用命令图解"></p>
</li>
</ul>
<h2 id="Git配置和初始化"><a href="#Git配置和初始化" class="headerlink" title="Git配置和初始化"></a>Git配置和初始化</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>方法1：<code>git init</code></li>
<li>方法2：<code>git clone &lt;url&gt;.git</code></li>
</ul>
<h3 id="使用前的配置"><a href="#使用前的配置" class="headerlink" title="使用前的配置"></a>使用前的配置</h3><p><code>git config</code>有3个级别：<code>--system</code>系统级；<code>--global</code>用户级；<code>--local</code>本地级。</p>
<ul>
<li>显示所有三级配置：<code> git config --list --show-origin</code></li>
<li>配置用户：<code>git config --global user.name &quot;John Doe&quot;</code>，<code>git config --global user.email johndoe@example.com</code><br><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6">忽略文件详解</a></li>
</ul>
<h3 id="其他有用配置"><a href="#其他有用配置" class="headerlink" title="其他有用配置"></a>其他有用配置</h3><ul>
<li>设置git别名：简化常用git命令的输入复杂性, 如，<ul>
<li>撤销已暂存的文件<code>git reset HEAD -- &lt;file&gt;</code>-&gt;<code>git unstage &lt;file&gt;</code>：<div class="tag-plugin copy"><span>$</span><input class="copy-area" id="copy_18" value="git config --global alias.unstage reset HEAD --"><button class="copy-btn" onclick="util.copy(&quot;copy_18&quot;,&quot;复制成功&quot;)"><svg class="icon copy-btn" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path></svg></button></div></li>
<li>查看最后一次提交日志：<code>git log -1 HEAD</code>-&gt;<code>git last</code>: <div class="tag-plugin copy"><span>$</span><input class="copy-area" id="copy_19" value="git config --global alias.last log -1 HEAD"><button class="copy-btn" onclick="util.copy(&quot;copy_19&quot;,&quot;复制成功&quot;)"><svg class="icon copy-btn" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path></svg></button></div></li>
<li>外部命令变成git子命令(叹号)：<code>gitk</code>-&gt;<code>git visual</code>: <div class="tag-plugin copy"><span>$</span><input class="copy-area" id="copy_20" value="git config --global alias.visual !gitk"><button class="copy-btn" onclick="util.copy(&quot;copy_20&quot;,&quot;复制成功&quot;)"><svg class="icon copy-btn" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path></svg></button></div></li>
</ul>
</li>
<li>暂存密码几分钟：用于push时Git服务器询问用户密码的临时缓存。<br><code>git config --global credential.helper cache</code> </li>
<li>pull时默认使用变基：<code>git config --global pull.rebase true</code></li>
</ul>
<h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><p>更多命令移步<a target="_blank" rel="noopener" href="https://git-scm.com/docs">官方文档</a></p>
<h3 id="基础类"><a href="#基础类" class="headerlink" title="基础类"></a>基础类</h3><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><code>git add</code></h4><p>功能：跟踪新文件，把已跟踪的文件放到暂存区，合并时把有冲突的文件标记为已解决状态等。<br>本质：精确地将内容添加到下一次提交中</p>
<h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><code>git commit</code></h4><p>提交动作的意义：是对你的工作目录作一次<code>快照</code>，以后可以回到这个状态，或者进行比较。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>git commit -m &quot;...&quot;</code></td>
<td>提交</td>
</tr>
<tr>
<td><code>git commit -a -m &quot;...&quot;</code></td>
<td>提交并跳过缓存，即省略<code>git add</code>。但要小心一些并不需要的文件。</td>
</tr>
<tr>
<td><code>git commit --amend</code></td>
<td>追加提交，而不新增快照。<a href="#%E4%BF%AE%E6%94%B9%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4">详见</a></td>
</tr>
</tbody></table>
<h4 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a><code>git rm</code></h4><ul>
<li>git删除文件的原理：仓库的快照是没有删除一说的，只有更新。因此git的删除实际执行手段是：<code>从暂存区移除，然后提交</code>。</li>
<li>git删除文件的效果：工作区、暂存区都会被删掉。如果接着commit后，新快照里相应文件也就没有了。</li>
<li>注意事项：当文件在<code>暂存区</code>和<code>最新快照</code>的内容有不同，则会报错并建议<code>--cached</code>或<code>-f</code></li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>git rm log/\*.log</code></td>
<td>工作区、暂存区都会被删掉。这里的文件是<code>glob模式匹配</code></td>
</tr>
<tr>
<td><code>git rm --cached &lt;file&gt;</code></td>
<td>只删除暂存区</td>
</tr>
<tr>
<td><code>git rm -f &lt;file&gt;</code></td>
<td>强制删除工作区、暂存区</td>
</tr>
</tbody></table>
<h4 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a><code>git mv</code></h4><p>-功能：移动文件、重命名文件。<br>-原理：等效于三个命令<code>mv fileA fileB &amp;&amp; git rm fileA &amp;&amp; git add fileB</code>, 即实现了在<code>暂存区</code>内的文件移动。</p>
<h3 id="查看类"><a href="#查看类" class="headerlink" title="查看类"></a>查看类</h3><h4 id="git-status-s"><a href="#git-status-s" class="headerlink" title="git status -s"></a><code>git status -s</code></h4><h4 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a><code>git show</code></h4><ul>
<li><code>git show &lt;commit/branch/tag&gt; --stat</code><br><code>git show &lt;brancn&gt;@&#123;&lt;筛选条件&gt;&#125;</code>用来筛选查看结果，如<code>HEAD@&#123;5&#125;</code>是前5次的HEAD历史；<code>master@&#123;yesterday&#125;</code>是你的 master 分支在昨天的时候指向了哪个提交。<a name="引用日志"></a></li>
</ul>
<h4 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a><code>git reflog</code></h4><p>查看HEAD所指向的历史<br>引用日志只存在于本地仓库，它只是一个记录你在 <code>自己</code> 的仓库里做过什么的日志。</p>
<h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a><code>git diff</code></h4><p><a name="git-diff"></a></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>git diff</code></td>
<td>比较的是文件在<mark class="tag-plugin colorful mark" color="green">暂存区</mark>和<mark class="tag-plugin colorful mark" color="green">工作目录</mark>的差异, <code>a/</code>是暂存区，<code>b/</code>是工作目录。</td>
</tr>
<tr>
<td><code>git diff --staged</code></td>
<td>比对文件在<mark class="tag-plugin colorful mark" color="green">最后一次提交</mark>和<mark class="tag-plugin colorful mark" color="green">暂存区</mark>的差异, <code>a/</code>是本地仓库的最后一次提交，<code>b/</code>是暂存区</td>
</tr>
<tr>
<td><code>git diff master [feat1]</code></td>
<td>比较两个<code>分支/提交</code>之间的差异(分支名也可换成提交对象哈希值), 若没有第二个参数，则默认第二个参数是当前分支</td>
</tr>
<tr>
<td><code>git diff master..feat1</code></td>
<td>比较两个分支之间的差异, 等价于上行命令。<a href="#%E6%8C%87%E5%AE%9A%E6%8F%90%E4%BA%A4">详见</a></td>
</tr>
<tr>
<td><code>git diff master...feat1</code></td>
<td>比较’后者分支’和’两者<code>公共祖先</code>分支’之间的差异，等价于<code>git diff $(git merge-base feat1 master) feat1</code></td>
</tr>
<tr>
<td><code>git difftool --tool-help</code></td>
<td>看你的系统支持哪些 Git Diff 插件（包括命令行形式的、窗口形式的 TODO:）</td>
</tr>
</tbody></table>
<p>其他参数：</p>
<ul>
<li><code>--cached</code></li>
<li><code>--check</code> 检查代码错误</li>
</ul>
<h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a><code>git log</code></h4><p><a name="git-log"></a></p>
<ul>
<li><code>git log --oneline --decorate --graph --all</code> 查看各个分支当前所指的<code>提交对象</code>、分叉历史。</li>
<li><code>git log b1 --not master</code> 查看b1分支下不与master重合的提交对象。等价于<code>git log master..b1</code></li>
<li>其他参数<ul>
<li>–abbrev-commit 显示<code>提交对象</code>的前7位</li>
<li>-g 来查看类似于 git log 输出格式的<code>引用日志信息</code>。</li>
<li><code>--no-merges</code> 不要显示<code>合并提交</code>, 即三方合并场景下自动生成的新<code>提交对象</code>。</li>
<li><code>--patch/-p</code> 显示每次提交所引入的差异&#x2F;具体修改。</li>
<li><code>--show-signature</code> 显示签名信息</li>
<li><code>-2</code>,<code>--since=2.weeks</code> 限制输出选项，<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/limit_options">更多</a></li>
<li><code>--stat</code> 看到每次提交的简略统计信息</li>
<li><code>--pretty=oneline/ short/ full/ fuller/ format:&quot;%h - %an, %ar : %s&quot;  </code> 可以使用不同于默认格式的方式展示提交历史。<blockquote>
<p>具体格式占位符<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/pretty_format">见</a> </p>
</blockquote>
</li>
<li>更多<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/log_options">常用选项</a></li>
</ul>
</li>
<li>log中的搜索功能，<a href="#%E6%90%9C%E6%8F%90%E4%BA%A4">见</a></li>
</ul>
<h4 id="git-grep"><a href="#git-grep" class="headerlink" title="git grep"></a><code>git grep</code></h4><p>在工作目录中搜索。详见<a href="#%E6%90%9C%E7%B4%A2">搜索</a></p>
<h4 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a><code>git blame</code></h4><p>显示每一行是由谁提交的。</p>
<h4 id="查看各种指针"><a href="#查看各种指针" class="headerlink" title="查看各种指针"></a>查看各种指针</h4><p>指针即引用，包含branch、tag等。</p>
<h5 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h5><p><code>git branch -a</code>, 列出本地和远程的所有分支，即<code>.git/refs/heads/</code>和<code>.git/refs/remotes/</code>下的所有文件。<br>更详细的branch使用<a href="#%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4">见</a>。</p>
<h5 id="查看所有引用"><a href="#查看所有引用" class="headerlink" title="查看所有引用"></a>查看所有引用</h5><p><code>git ls-remote [&lt;url&gt;]</code>，列出远程url下的所有引用。<br>低级命令，显示任意一个仓库(url)中的所有引用。其中url也可换成url-shortname。获取到的列表形如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">9c906cc02bf209b8b8823f696fffeac5501a3372        HEAD<br>9c906cc02bf209b8b8823f696fffeac5501a3372        refs/heads/main<br>9c906cc02bf209b8b8823f696fffeac5501a3372        refs/heads/npm<br>6a83107c62950be9453aac297bb0193fd743cd6e          refs/pull/1/head<br>afe83c2d1a70674c9505cc1d8b7d380d5e076ed3          refs/pull/1/merge<br>3c8d735ee16296c242be7a9742ebfbc2665adec1          refs/pull/2/head<br>15c9f4f80973a2758462ab2066b6ad9fe8dcf03d          refs/pull/2/merge<br>f6b06a6d6c61bfe81ea99cc55669121a7d6dee8f        refs/tags/1.0.0-rc.6<br>3d98a5a189e0bd680850a5e4c388021c03bf89de        refs/tags/1.0.1a<br></code></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><code>HEAD</code>指向工作目录所在的提交对象；</li>
<li><code>refs/heads/</code>下都是分支；</li>
<li><code>refs/tags/</code>下都是标签；</li>
<li>（注：为什么没有<code>refs/remote/</code>, 毕竟本地的<code>.git/refs/</code>下一般都有<code>remote/</code>目录？因为<code>ls-remote</code>命令的对象是远程仓库，不是本地仓库，远程仓库当然没有<code>remote</code>啦。）</li>
<li><code>refs/pull/</code> 下都是PR分支<ul>
<li><code>refs/pull/&lt;pr#&gt;/head</code>: 指向PR过程中派生仓库里<code>合并请求分支</code>中的最后一个提交快照。</li>
<li><code>refs/pull/&lt;pr#&gt;/merge</code>: 它表示如果你在网站上按下“合并”按钮，将产生的提交。这可以让你在点击按钮之前测试合并。</li>
</ul>
</li>
</ul>
<h3 id="撤销和重置类"><a href="#撤销和重置类" class="headerlink" title="撤销和重置类"></a>撤销和重置类</h3><h4 id="清理-clean"><a href="#清理-clean" class="headerlink" title="清理 clean"></a>清理 clean</h4><p><a href="#%E6%B8%85%E7%90%86">参考</a></p>
<h4 id="贮藏-stash"><a href="#贮藏-stash" class="headerlink" title="贮藏 stash"></a>贮藏 stash</h4><p><a href="#%E8%B4%AE%E8%97%8F">参考</a>  </p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><ul>
<li><p><code>git reset HEAD &lt;file&gt;</code> <mark class="tag-plugin colorful mark" color="warning">!危险, reset加'--hard'更危险</mark>，撤销暂存区的文件</p>
</li>
<li><p><code>git checkout -- &lt;file&gt;</code> <mark class="tag-plugin colorful mark" color="warning">!危险</mark>，撤销工作区的文件所做过的修改。另<a href="#checkout%E6%81%A2%E5%A4%8D%E6%96%87%E4%BB%B6">参考</a></p>
</li>
<li><p><code>git checkout HEAD &lt;file&gt;</code> 从最新提交恢复文件</p>
</li>
<li><p><code>git revert</code>: 撤销一个提交的更改。</p>
</li>
</ul>
<h3 id="标签类"><a href="#标签类" class="headerlink" title="标签类"></a>标签类</h3><h4 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a><code>git tag</code></h4><ul>
<li>查看标签：<br><code>git tag</code>,<br><code>git tag -l &quot;v1.8.5*&quot;</code><br><code>git show</code> 看到标签信息和与之对应的提交信息 </li>
<li>打标签：给仓库<code>历史中</code>的某一个提交打上标签，以示重要。分类如下，<ul>
<li>轻量标签（lightweight）：只是某个特定提交的引用<br><code>git tag v1.4</code> </li>
<li>附注标签（annotated）：是存储在 Git 数据库中的一个完整对象<br><code>git tag -a v1.4 -m &quot;my version 1.4&quot;</code></li>
</ul>
</li>
<li>推送标签（类似推送分支）<ul>
<li><code>git push &lt;remote&gt; &lt;tagname&gt;</code> 推送特定标签到远程仓库，类似推送分支。</li>
<li><code>git push &lt;remote&gt; --tags</code> 推送远端没有的所有标签</li>
</ul>
</li>
<li>删除标签<ul>
<li><code>git tag -d &lt;tagname&gt;</code> 本地的</li>
<li><code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> 远程的, 将冒号前面的空值推送到远程标签名，从而高效地删除它</li>
<li><code>git push &lt;remote&gt; --delete &lt;tagname&gt;</code> 远程的, 方法2, 更直观</li>
</ul>
</li>
<li>检出标签<ul>
<li><code>git checkout 2.0.0</code> 查看某个标签所指向的文件版本<blockquote>
<p>缺点：使你的仓库处于“分离头指针（detached HEAD）”的状态，此时要想将修改提交到标签里是不可能的，得创建新分支来实现<code>git checkout -b version2 v2.0.0</code></p>
</blockquote>
</li>
</ul>
</li>
<li>其他参数：<ul>
<li>☆ 加签名：<code>git tag -s v1.5 -m &#39;...&#39;</code>（如何配置与使用签名请<a href="/post/topic-security#Git%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">参考</a>）</li>
</ul>
</li>
</ul>
<h4 id="git-describe"><a href="#git-describe" class="headerlink" title="git describe &lt;branch&gt;"></a><code>git describe &lt;branch&gt;</code></h4><p><a name="构建号"></a></p>
<p>为提交生成<code>构建号</code>。由于每个提交的ID是一串不易读的SHA-1值，该命令实现了为提交附上一个可读的名称。</p>
<ul>
<li>构建号的格式：<code>&lt;最近的标签名&gt;-&lt;自该标签之后的提交数目&gt;-g&lt;8或10位的SHA-1值&gt;</code> (e.g. <code>v1.6.2-rc1-20-g8c5b85c</code>)。</li>
<li>前提条件：最近的那个tag的生成需要使用 -a 或 -s 选项。</li>
</ul>
<h3 id="远程相关"><a href="#远程相关" class="headerlink" title="远程相关"></a>远程相关</h3><h4 id="见"><a href="#见" class="headerlink" title="见"></a><a href="#Git%E8%BF%9C%E7%A8%8B">见</a></h4><p>含<code>remote fetch pull push</code>等。</p>
<h3 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h3><h4 id="见-1"><a href="#见-1" class="headerlink" title="见"></a><a href="#%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4">见</a></h4><p>含<code>branch checkout merge rebase</code>等。</p>
<h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a><code>git checkout</code></h4><p><a name="checkout详解"></a></p>
<p>checkout（检出）的作用是实现在不同的分支或文件<code>状态之间切换</code>，状态切换意味着工作目录内容的改变。因此一般在检出前，需留意你当前的修改需不需要被提交(commit)、临时保存(stash)等。<br>checkout能切换分支，恢复文件等。</p>
<ul>
<li><p>☆<code>切换分支</code>：<code>git checkout [-b branch2] [branch1]</code></p>
<ul>
<li>形式1：<code>git checkout branch1</code>，切换到项目版本库中名为branch1的分支。<blockquote>
<p>注意：(先用<code>git branch -a</code>查看所有分支的列表)</p>
<ol>
<li>当branch1存在于本地分支列表(形如<code>branch1</code>)，则可以<code>直接切换</code>过去，和<code>git switch branch1</code>等价；</li>
<li>当branch1<code>只</code>存在于远程分支列表(形如<code>origin/branch1</code>)，即此时该<code>远程跟踪分支</code>在本地没有<code>跟踪分支</code>：</li>
</ol>
<ul>
<li>若用<code>git checkout origin/branch1</code>，则HEAD称为<a href="#detached-head"><code>detached HEAD</code></a>，因此建议使用下一行的方法;</li>
<li>若用<code>git checkout branch1</code>，则该命令是<code>git checkout -b branch1 origin/branch1</code>的简化版（见形式3）。</li>
</ul>
<ol start="3">
<li>当branch1不存在于整个分支列表，则报错。</li>
</ol>
</blockquote>
</li>
<li>形式2：<code>git checkout -b branch2</code>，基于当前分支，新建并切换到分支branch2。</li>
<li>形式3：<code>git checkout -b branch2 branch1</code>，基于指定的分支branch2，新建并切换到分支branch1。<blockquote>
<p>☆最常用的场景：<code>git checkout -b branch1 origin/branch1</code><br>-&gt; 太过于常用，简化版本：<code>git checkout --track origin/branch1</code><br>-&gt; 进一步简化：<code>git checkout branch1</code>（前提：本地没有名为branch1的分支，而远程仓库刚好有。TODO: 连接的是多个远程仓库怎么办）</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>切换/恢复文件</code>：<code>git checkout -- file1</code><a name="checkout恢复文件"></a></p>
<ul>
<li>工作目录中的file1被修改过，此时恢复优先级为：暂存区的file1 -&gt; 提交对象中的file1。</li>
</ul>
</li>
</ul>
<h4 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a><code>git switch</code></h4><p>switch是对checkout的<code>切换分支</code>方面的功能的改进。<br><code>git switch &lt;branch-name&gt;</code> 切换到一个已有的本地分支；或切换到一个本地没有但远程有的分支，它会自动创建并设定好远程追踪。</p>
<ul>
<li>更多参数<ul>
<li><code>-c &lt;branch&gt;</code> 创建并切换到一个新分支。</li>
</ul>
</li>
</ul>
<h3 id="发布相关"><a href="#发布相关" class="headerlink" title="发布相关"></a>发布相关</h3><ul>
<li><code>git archive</code> <a href="#6%E3%80%81%E5%87%86%E5%A4%87%E4%B8%80%E6%AC%A1%E5%8F%91%E5%B8%83">见</a></li>
<li><code>git shortlog</code> <a href="#7%E3%80%81%E5%88%B6%E4%BD%9C%E6%8F%90%E4%BA%A4%E7%AE%80%E6%8A%A5">见</a></li>
</ul>
<h3 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h3><p>git submodule: 管理 Git 子模块。<br>git fsck: 检查对象文件和引用的完整性。</p>
<h3 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h3><p>git中更加底层、低级的命令。<br>cat-file<br>check-ignore<br>checkout-index<br>commit-tree<br>count-objects<br>diff-index<br>for-each-ref<br>hash-object<br>ls-files<br>ls-tree<br>merge-base<br>read-tree<br>rev-list<br>rev-parse     查看branch1的SHA-1<br>show-ref<br>symbolic-ref<br>update-index<br>update-ref<br>verify-pack<br>write-tree</p>
<h2 id="Git远程"><a href="#Git远程" class="headerlink" title="Git远程"></a>Git远程</h2><p>一个<code>本地仓库</code>可连接多个<code>远程仓库</code>。</p>
<h3 id="命令：查看、增删远程仓库"><a href="#命令：查看、增删远程仓库" class="headerlink" title="命令：查看、增删远程仓库"></a>命令：查看、增删远程仓库</h3><p><code>git remote -v</code> 显示本地仓库连接的<code>所有</code>远程仓库<br><code>git remote show &lt;remote&gt;</code> 查看<code>某一个</code>远程仓库的更多信息<br><code>git ls-remote &lt;remote&gt;</code> 查看<code>某一个</code>远程仓库下的所有远程引用(HEAD, tag, branch)的完整列表</p>
<p><code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加远程仓库<br><code>git remote rename &lt;shortname1&gt; &lt;shortname2&gt;</code> 修改一个远程仓库的简写名<br><code>git remote remove &lt;shortname&gt;</code> 移除一个远程仓库</p>
<h3 id="命令：下载、拉取"><a href="#命令：下载、拉取" class="headerlink" title="命令：下载、拉取"></a>命令：下载、拉取</h3><p>(以下假设remote&#x3D;<code>origin</code>, branch&#x3D;<code>dev1</code>)</p>
<ul>
<li><code>git fetch &lt;remote&gt; [&lt;branch&gt;]</code> <ul>
<li>只会将数据从远程仓库<code>下载</code>&#x2F;<code>更新</code>到你的本地仓库 —— 它并不会自动合并或修改你当前的工作，需要自己手动merge。原理见<a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/images/remote-branches-3.png">图</a>。</li>
<li>fetch中的分支问题<a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">详见</a>。</li>
</ul>
</li>
<li><code>git pull</code><br>等于fetch+merge。使用前提是已经设置好了跟踪的<code>上游分支</code>，见<a href="#%E8%AE%A9%E6%B4%BE%E7%94%9F%E4%BB%93%E5%BA%93%E4%BF%9D%E6%8C%81%E6%9B%B4%E6%96%B0">这里</a>的方法2。<br>更多命令：<ul>
<li><code>git pull &lt;url&gt; &lt;branch&gt;</code> 临时把url下的branch进行拉取合并，避免了‘添加remote’等配置。</li>
</ul>
</li>
</ul>
<h3 id="命令：推送"><a href="#命令：推送" class="headerlink" title="命令：推送"></a>命令：推送</h3><p>(下面假设remote&#x3D;<code>origin</code>, branch&#x3D;<code>dev1</code>)</p>
<ul>
<li><code>git push &lt;remote&gt; &lt;branch&gt;</code><ul>
<li>其原始命令为：<code>git push origin refs/heads/dev1:refs/heads/dev2</code>, 或<code>git push origin dev1:dev2</code>, 即推送本地的dev1分支来<code>更新/成为</code>远程的dev2分支<blockquote>
<p>牢记：冒号前是本地分支，冒号后是远程仓库；<br>注意：两个分支名字可同可不同。</p>
</blockquote>
</li>
<li>注意【集中式工作流】：当多人推送到同一远程分支时，你必须先<code>抓取</code>他们的工作，再将其<code>合并</code>进你的工作（这里<code>抓取+合并</code>也可换成<code>pull</code>），然后才能<code>push</code>。</li>
</ul>
</li>
<li>push的更多参数<ul>
<li><code>git push origin --delete dev1</code>: 删除远程的dev1分支</li>
<li><code>git push -u origin dev1</code>: <a name="push-u"></a> <ul>
<li>-u即<code>--set-upstream-to</code>, 会将本地的“dev1”分支和指定了远程仓库的“dev1”分支<code>关联</code>起来（即手动设置<code>远程跟踪分支</code>的概念, 联系<a href="#branch-u">branch-u</a>）。</li>
<li>以后在<code>dev1</code>环境下就可以用简化的“git push”命令来推送了（pull也是）,不需要指定远程分支名字。</li>
<li>这样方便在一个仓库连接了<code>多个远程仓库</code>时，对push的默认配置。</li>
<li>TODO: 引用规范</li>
</ul>
</li>
</ul>
</li>
<li>push标签<ul>
<li><code>git push &lt;remote&gt; &lt;tagname&gt;</code> 推送特定标签到远程仓库，类似推送分支。</li>
<li><code>git push &lt;remote&gt; --tags</code> 推送远端没有的所有标签</li>
</ul>
</li>
</ul>
<h2 id="★-Git分支管理！"><a href="#★-Git分支管理！" class="headerlink" title="★ Git分支管理！"></a>★ Git分支管理！</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://assets.taddream.site/wiki/my-notes/图解-分支即指针.png" alt="图解-分支即指针" width="50%"/>

<ul>
<li>原理解读：<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B">用对象的逻辑理解git原理</a>：<ul>
<li>Git的分支，是术语<code>引用</code>的其中一种。其本质上仅仅是<code>指向提交对象的可变指针</code>。</li>
<li>HEAD是一个指针，指向当前所在的本地分支（可理解为<code>当前分支的别名</code>）</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><ul>
<li><p><code>git branch</code></p>
<ul>
<li><p>查看：</p>
<ul>
<li><code>git branch</code>    本地所有分支</li>
<li><code>git branch -a</code> 本地+远程所有分支。（查看当前仓库有哪些远程仓库，执行<code>git remote -v</code>）</li>
<li><code>-v</code>  每个分支的最后一次提交的信息 </li>
<li><code>-vv</code> 在<code>-v</code>基础上有更多简笔信息：跟踪的上游分支、与上游的版本差异。<br>常用：<div class="tag-plugin copy"><span>$</span><input class="copy-area" id="copy_21" value="git fetch --all; git branch -vv"><button class="copy-btn" onclick="util.copy(&quot;copy_21&quot;,&quot;复制成功&quot;)"><svg class="icon copy-btn" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path></svg></button></div></li>
<li><code>-u</code> 设置上游分支，<a href="#branch-u">详见</a></li>
<li><code>--merged [branch]</code>, <code>--no-merged [branch]</code> 只显示<code>已经</code>&#x2F;<code>没有</code>合并到当前分支的分支<blockquote>
<p><code>--merged</code>下显示的非当前分支，可尽情删除，毕竟都合并过了。其他情况，也可强制删除<code>-D</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>新建分支：<code>git branch &lt;branch1&gt; [base-branch]</code></p>
<ul>
<li>当base-branch缺失，则默认基于当前branch来新建。</li>
<li>可为分支设置<code>命名空间</code>, 如branch1可写为<code>james/branch1</code>。</li>
</ul>
</li>
<li><p>更多命令：<code>git branch -h</code></p>
</li>
</ul>
</li>
<li><p><code>git checkout</code>: 切换分支或还原工作目录中的文件。<a href="#checkout%E8%AF%A6%E8%A7%A3">见</a></p>
</li>
<li><p><code>git merge</code>: 将一个分支的更改合并到另一个分支。<a href="#%E5%90%88%E5%B9%B6-merge">见</a></p>
</li>
<li><p><code>git rebase</code>: 变基，将提交从一个分支移动到另一个分支。<a href="#%E5%8F%98%E5%9F%BA-rebase">见</a></p>
</li>
</ul>
<h3 id="场景：分支的新建与合并"><a href="#场景：分支的新建与合并" class="headerlink" title="场景：分支的新建与合并"></a>场景：分支的新建与合并</h3><div class="tag-plugin timeline"><div class="timenode" index="0"><div class="header"><ol><li>新建和切换分支 <code>git checkout -b &lt;dev1&gt;</code></li></ol></div><div class="body fs14"><p>切换&#x2F;检出命令的机理：让HEAD指向另一个的<code>分支指针</code>，同时工作目录也恢复成对应的快照版本。<br>一般情况下，这些分支命令也可分开操作：</p><ul><li>查看(<code>git branch</code>)</li><li>新建(<code>git branch &lt;dev1&gt;</code>)</li><li>切换&#x2F;检出(<code>git checkout &lt;dev1&gt;</code>)，当dev1在本地不存在时，该命令实际是把远程分支检出到本地新建的同名分支，同时设置好<a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><code>跟踪</code></a></li></ul></div></div><div class="timenode" index="1"><div class="header"><ol start="2"><li>此时master有紧急错误需要修复</li></ol></div><div class="body fs14"><ul><li>先把<code>dev1</code>分支打扫干净：尽量把所有修改都形成快照，即commit。实在不行也可<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/_git_stashing">贮藏(stashing)和修补(amending)</a>。</li><li>切换到主分支: <code>git checkout master</code></li><li>新建并切换到修复分支：<code>git checkout -b hotfix</code></li><li>修改、测试、提交</li><li>把修复分支合并到master: <code>git checkout master</code>, <code>git merge hotfix</code></li><li>删除重复分支：<code>git branch -d hotfix</code>(因为此时master指针和hotfix指针，指向同一个提交对象。 )</li></ul></div></div><div class="timenode" index="2"><div class="header"><ol start="3"><li>继续回到开发分支<code>dev1</code>上工作</li></ol></div><div class="body fs14"><ul><li>修改、测试、提交</li><li>把开发分支合并到master: <code>git checkout master</code>, <code>git merge dev1</code><blockquote><p>此时，若master指向的快照不是dev1指向的快照的<code>直接祖先</code>，则git后台会寻找他俩的<code>公共祖先</code>，做一个<code>三方合并</code>, 三方合并会自动创建一个新提交对象<code>C6</code>，如下图：<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://assets.taddream.site/wiki/my-notes/图解-git三方合并.png" alt="图解-git三方合并" width="100%"/></p></blockquote></li><li>删除开发分支：<code>git branch -d dev1</code></li></ul></div></div><div class="timenode" index="3"><div class="header"><ol start="4"><li>有冲突怎么合并？</li></ol></div><div class="body fs14"><p>merge后，如果某文件有冲突，会提示合并失败。</p><ul><li>定位产生冲突的文件：<code>git status</code>。</li><li>进入文件手动解决冲突：冲突代码会有明显的状态标识，我们需二选一、或自定义处理代码。</li><li>删除标识：<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; , ======= , 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</code></li><li>标记文件为<code>冲突已解决</code>：<code>git add file</code></li><li>最终合并提交。</li></ul></div></div></div>

<h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><p>长期分支<br>主题分支</p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>(下面假设remote&#x3D;origin, branch&#x3D;dev1)</p>
<ul>
<li><p>★ <code>远程跟踪分支</code>：<br>是远程分支状态的本地引用，无法移动(即无法在该分支基础上产生新的<code>提交快照</code>)。形式为<code>&lt;remote&gt;/&lt;branch&gt;</code>, 另外用<code>git branch -a</code>命令可得到形式<code>remotes/&lt;remote&gt;/&lt;branch&gt;</code>。</p>
<ul>
<li>如何产生：<code>git fetch &lt;remote&gt;</code>后抓取到了本地没有的<code>新分支</code>就是。</li>
<li>想在远程跟踪分支上工作怎么办，有两种方法：<ul>
<li>把<code>远程追踪分支</code>合并到本地当前分支：<code>git merge origin/dev1</code>。</li>
<li>基于<code>远程追踪分支</code>在本地新建一个分支：<code>git checkout -b dev1 origin/dev1</code>(超级常用的命令，具体使用<a href="#checkout%E8%AF%A6%E8%A7%A3">见</a>里的形式3。)<blockquote>
<p>此时，本地的dev1叫<code>跟踪分支</code>, 对应的那个远程的dev1叫<code>上游分支</code>。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>★ <code>跟踪分支</code>&#x2F;<code>上游分支</code>:<br>从一个<code>远程跟踪分支(上游分支)</code>检出一个<code>本地分支(跟踪分支)</code>时自动创建的分支。有了’上游’和’跟踪’两个分支的对应，<code>git pull</code>才能自动识别抓取、合并的对象; 且可用 <code>@&#123;upstream&#125;</code> 或 <code>@&#123;u&#125;</code>来代替上游分支名，如<code>git merge @&#123;u&#125;</code>-&gt;<code>git merge origin/dev1</code>。<br>如何生成跟踪分支（及其上游分支）：</p>
<ul>
<li>【克隆时自动生成】：<code>git clone</code>后，会自动获得跟踪分支(<code>master</code>)对远程跟踪分支(<code>origin/master</code>)的跟踪。</li>
<li>【把远程分支检出到<code>本地新分支</code>时自动生成】：具体使用<a href="#checkout%E8%AF%A6%E8%A7%A3">见</a>里的形式3。</li>
<li>【手动设置&#x2F;更改<code>本地已有的分支</code>的上游】：<code>git branch -u origin/dev1 [local_branch]</code>（-u即<code>--set-upstream-to</code>，<a name="branch-u"></a>联系<a href="#push-u">push-u</a>）</li>
</ul>
</li>
</ul>
<h3 id="变基与合并"><a href="#变基与合并" class="headerlink" title="变基与合并"></a>变基与合并</h3><p>同：都是整合分支的方法，两者执行结果是相同的。<br>异：merge下的提交历史复杂(多线)，因为所有commit都保留了；rebase下的提交历史简洁(单线)，因为会删除部分历史commit。</p>
<h4 id="变基-rebase"><a href="#变基-rebase" class="headerlink" title="变基-rebase"></a>变基-rebase</h4><ul>
<li>变基的定义：即提取在<code>当前主题分支</code>experiment中引入的补丁和修改，移动到<code>目标基底分支</code>master进行应用和提交。</li>
<li>变基的实质：<code>丢弃</code>一些现有的<code>提交</code>，然后相应地<code>新建</code>一些内容一样但实际上不同的<code>提交</code>。</li>
<li>变基的原理：<br>一开始experiment指向C4，master指向C3。<br>-&gt; 找到<code>最近共同祖先</code>C2<br>-&gt; 对比experiment对C2的所有修改(即一个&#x2F;多个快照)并存为<code>临时文件</code>；<br>-&gt; 将experiment指向master所在的C3；<br>-&gt; 在C3基础上依序应用<code>临时文件</code>的修改，生成<code>新快照C4&#39;</code>(多个快照时，就是新快照链), experiment指向最新的那个快照；<br>-&gt; master进行<code>快进合并</code>完成变基。<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://assets.taddream.site/wiki/my-notes/图解-变基操作步骤.png" alt="图解-变基操作步骤" width="100%"/></li>
<li>命令解释：<code>git rebase master</code>, 把当前分支融入到master里。</li>
<li>操作步骤：<ul>
<li>先在<code>主题分支</code>里实施变基：<code>$ git checkout experiment</code>, <code>$ git rebase master</code> <blockquote>
<p>这两个命令等价于<code>$ git rebase master(base分支) experiment(topic分支)</code></p>
</blockquote>
</li>
<li>后在<code>目标分支</code>里完成变基：<code>$ git checkout master</code>, <code>$ git merge experiment</code></li>
<li>最后删除不用的分支：<code>$ git branch -d experiment</code></li>
</ul>
</li>
<li>优点：对比’merge’, 变基使得提交历史更加整洁——没有分叉。实际上，rebase就是把merge的<code>三方合并</code>情况改造成<code>快进合并</code>。</li>
<li>☆风险：鉴于<code>变基</code>有丢弃提交的特性，如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。<ul>
<li>风险后果：仓库中会有多个完全重复的commit；别人丢弃的一些commit会因为你的push再次回到仓库；仓库版本混乱。</li>
<li>出现风险的解决办法：<mark class="tag-plugin colorful mark" color="yellow">用变基解决变基</mark><ul>
<li>也就是当你在fetch了‘别人push的经过变基的commit’后，不要用‘merge’了，而是用‘rebase’命令，将当前主题分支变基到远程跟踪分支上，如：<code>git rebase teamone/master [master]</code>，然后执行【操作步骤】中的2-3步。</li>
<li>上述过程<code>fetch + rebase</code>命令可整合为：<code>git pull --rebase</code>, 简便实现<code>主题分支</code>变基到<code>远程跟踪分支</code>。</li>
<li>下图是用merge和用rebase的效果对比：<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://assets.taddream.site/wiki/my-notes/图解-fetch了变基后的数据后使用merge和rebase的区别.png" alt="图解-fetch了变基后的数据后使用merge和rebase的区别" width="80%"/></li>
<li>该办法的前提：确保别人的变基中 C4’ 和 C4 是几乎一样的。</li>
</ul>
</li>
</ul>
</li>
<li>更多功能：<ul>
<li>【–onto】当分支有嵌套，只想让<code>子子分支</code>并入<code>指定分支</code>，同时不让<code>子分支</code>并入：<ul>
<li>图示场景：让<code>server</code>分支下的<code>client</code>分支并入<code>master</code>分支<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://assets.taddream.site/wiki/my-notes/图解-变基的高级功能.png" alt="图解-变基的高级功能" width="100%"/></li>
<li>方法：<code>$ git rebase --onto master server client</code> -&gt;<br><code>$ git checkout master</code> -&gt;<br><code>$ git merge server</code></li>
<li>解释：“取出 client 分支，找出它从 server 分支分叉之后的补丁，然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”</li>
</ul>
</li>
<li>【-i】用 rebase -i 将工作压缩成一个单独的提交</li>
</ul>
</li>
</ul>
<h4 id="拣选-cherry-pick"><a href="#拣选-cherry-pick" class="headerlink" title="拣选-cherry-pick"></a>拣选-cherry-pick</h4><p>变基是把一个分支上的<code>多个提交</code>打成一个补丁，更新到目标分支上，生成新提交；<br>拣选是把<code>一个提交</code>的更改，直接更新到目标分支上，生成新提交。</p>
<p>这种方式在你只想引入主题分支中的某个提交，或者主题分支中只有一个提交，而你不想运行变基时很有用。<br><code>git cherry-pick e43a6</code></p>
<h4 id="合并-merge"><a href="#合并-merge" class="headerlink" title="合并-merge"></a>合并-merge</h4><p>使用场景<a href="#%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6">见</a>。</p>
<ul>
<li>命令解释：<code>git merge dev1</code>, 将b1分支的内容合并到当前分支中。</li>
<li>合并的类型：<ul>
<li>快进合并：dev1要并入master，而master的快照是dev1的快照的<code>直接祖先</code>，因此master指针可直接快进到dev1处。</li>
<li>三方合并：不是<code>直接祖先</code>，则要找俩分支的<code>公共祖先</code>快照(分叉点)，对这三个快照进行整合，生成一个新快照(汇合点)。此时master和dev1都指向这个新快照。</li>
</ul>
</li>
<li>更多参数：<ul>
<li>延迟生成新快照：<code>git merge --squash dev1</code>，在需要三方合并的场景下，该参数会做合并过程的几乎所有工作，除了生成新快照。这些改动将在你<code>下一次手动提交</code>时被写入。</li>
<li>另一种延迟：<code>--no-commit</code></li>
</ul>
</li>
</ul>
<h2 id="Git服务器-公共仓库"><a href="#Git服务器-公共仓库" class="headerlink" title="Git服务器(公共仓库)"></a>Git服务器(公共仓库)</h2><p>为了git的协作功能，你的仓库需要转变成<code>公共仓库/远程仓库/git服务器</code>。</p>
<h3 id="4种协议"><a href="#4种协议" class="headerlink" title="4种协议"></a>4种协议</h3><p>git服务器使用的通信协议支持：本地、SSH、HTTP、Git，<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE">详见</a>。<br>一般地，用<code>ssh://</code>进行授权访问，用<code>git://</code>进行无授权访问，用<code>https://</code>可同时实现。</p>
<ul>
<li>Git协议<ul>
<li>其数据访问特点：快速且无需授权，因此仓库<code>只能是公开的</code>。</li>
<li>优点：对只读的项目很友好，省去逐一配置 SSH 公钥的麻烦。<br>…</li>
</ul>
</li>
</ul>
<h3 id="用SSH协议搭建Git服务"><a href="#用SSH协议搭建Git服务" class="headerlink" title="用SSH协议搭建Git服务"></a>用SSH协议搭建Git服务</h3><p>比起HTTP，借助<code>SSH协议</code>的搭建更加容易！但其难点在于<code>用户管理</code>——如何设置数量不可知的用户的<code>访问权限</code>、<code>读写权限</code>？</p>
<ul>
<li>方法1：在Git服务寄宿的主机上创建一个’git’用户供所有用户使用。</li>
<li>方法2：让 SSH 服务器通过某种<code>集中授权机制</code>(e.g. LDAP服务)来授权。<br>下面将借助方法1进行搭建：</li>
</ul>
<div class="tag-plugin timeline"><div class="timenode" index="0"><div class="header"><ol><li>配置远程主机</li></ol></div><div class="body fs14"><ol><li><p>准备一个ssh可连接的远程主机:<br>  我有一个云服务器、一个域名，因此我将云服IP添加到了域名解析<code>mygit.taddream.site</code>中，<br>  访问云服方式为：<code>ssh -p 10361 root@mygit.taddream.site</code></p></li><li><p>创建<code>git</code>用户，建立<code>.ssh</code>目录: </p>  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo adduser git<br>sudo usermod -aG sudo git   <span class="hljs-comment"># 将 git 用户添加到 sudo 组中</span><br>su git<br><span class="hljs-built_in">cd</span><br><span class="hljs-built_in">mkdir</span> .ssh &amp;&amp; <span class="hljs-built_in">chmod</span> 700 .ssh<br><span class="hljs-built_in">touch</span> .ssh/authorized_keys &amp;&amp; <span class="hljs-built_in">chmod</span> 600 .ssh/authorized_keys<br></code></pre></td></tr></table></figure></li><li><p>接收来自一些用户的<code>公钥</code>妥善存放: <code>echo &quot;粘贴公钥内容&quot; &gt;&gt; ~/.ssh/authorized_keys</code></p></li></ol></div></div><div class="timenode" index="1"><div class="header"><ol start="2"><li>准备<code>裸仓库</code>到远程主机中</li></ol></div><div class="body fs14"><blockquote><ul><li>裸仓库目录名一定是<code>.git</code>结尾；</li><li>安装git服务的远程主机中，一般所有的裸仓库都放在<code>/srv/git/</code>下, 其权限改为<code>777</code>。</li></ul></blockquote><p>创建一个裸仓库可有多种场景：</p><ul><li><p>场景1：<code>远程主机管理者</code>手动将别处的裸仓库上传到远程主机</p><ul><li>先在别处将目标仓库导出为裸仓库：<code>$ git clone --bare my_project my_project.git</code>    <blockquote><p>上述命令等价于把原仓库的<code>.git/</code>目录复制过来：<code>$ cp -Rf my_project/.git my_project.git</code></p></blockquote></li><li>然后将裸仓库上传到远程主机：<code>$ scp -P 10361 -r my_project.git git@git.taddream.site:/srv/git/</code></li></ul></li><li><p>场景2：<code>远程主机管理者</code>建空的裸仓库 + <code>项目贡献者</code>推送初始版本</p><ul><li>先在远程主机<code>创建</code>空的公共仓库：<code>$ sudo git init --bare /srv/git/pro2.git</code><a name="创建裸仓库"></a></li><li>然后从任一用户本地<code>推送</code>第一个项目版本：<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> project<br>git init<br>git add .<br>git commit -m <span class="hljs-string">&#x27;initial commit&#x27;</span><br><span class="hljs-comment"># git remote add origin git@git.taddream.site:/srv/git/project.git # 若出现端口权限报错，则用下面的命令</span><br>git remote add origin ssh://git@git.taddream.site:10361/srv/git/project.git<br>git push origin master<br></code></pre></td></tr></table></figure></li></ul></li></ul></div></div><div class="timenode" index="2"><div class="header"><ol start="3"><li>开发者开始使用<code>公共仓库</code></li></ol></div><div class="body fs14"><p>一旦裸仓库有了<code>初始快照</code>，用户们就可以（用ssh协议借助<code>git账户</code>和放置好的<code>公钥</code>）克隆了。</p><ul><li>clone: <ul><li>当访问端口是默认的22，可用：<code>git clone git@git.taddream.site:/srv/git/project.git</code></li><li>当访问端口非22(e.g. 10361)，可用：<code>git clone ssh://git@git.taddream.site:10361/srv/git/project.git</code></li></ul></li><li>push:<code>git push origin master</code> <blockquote><p>如果push时出现<code>写入权限报错</code>，可对该公共仓库目录使用<code>git init --bare --shared</code>，或直接<code>chmod 775</code>，都能修改其<code>组权限</code>为所有用户可写。</p></blockquote></li></ul></div></div><div class="timenode" index="3"><div class="header"><ol start="4"><li>权限约束</li></ol></div><div class="body fs14"><p>目前所有（获得授权的）开发者用户都能以系统用户 git 的身份登录服务器从而获得一个普通 shell。<br>但远程主机系统管理员并不想让开发者对<code>公共仓库</code>之外有权限。</p><ul><li>约束1：将 <code>git-shell</code> (Git软件包中自带的受限shell工具)设置为用户 git 的登录 shell。<ul><li>约束方法：<code>sudo chsh git -s $(which git-shell)</code></li><li>效果：放置了公钥的开发者执行<code>ssh git@git.taddream.site</code>再也不能成功了，但<code>git clone/push</code>等仍有效。</li></ul></li><li>约束2：禁用端口转发<ul><li>约束原因：约束1并不能阻止开发者通过<code>SSH端口转发</code>获取git身份下的普通shell，因此需要对git身份禁用端口转发。</li><li>方法：在<code> ~/.ssh/authorized_keys</code>中，在指定的公钥条目开始位置，把<code>ssh-rsa</code>改为：<div class="tag-plugin copy"><span>txt</span><input class="copy-area" id="copy_22" value="no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa"><button class="copy-btn" onclick="util.copy(&quot;copy_22&quot;,&quot;复制成功&quot;)"><svg class="icon copy-btn" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path></svg></button></div></li></ul></li><li>更多的约束设置：查看<code>git help shell</code></li></ul></div></div></div>

<h3 id="用Git协议搭建"><a href="#用Git协议搭建" class="headerlink" title="用Git协议搭建"></a>用Git协议搭建</h3><p>通过 “Git” 协议建立一个基于守护进程的仓库。TODO: 用到再研究。搭建方法<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-Git-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">见</a></p>
<h3 id="用-smart-HTTP搭建"><a href="#用-smart-HTTP搭建" class="headerlink" title="用 smart HTTP搭建"></a>用 smart HTTP搭建</h3><p>设置 Smart HTTP: 一般只需要在服务器上启用<code>git-http-backend</code>的CGI(命令网关接口)脚本。<br>步骤：</p>
<h4 id="系统环境准备"><a href="#系统环境准备" class="headerlink" title="系统环境准备"></a>系统环境准备</h4><ul>
<li>安装 Apache 作为<code>web服务器</code>及<code>CGI服务器</code>:<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install apache2 apache2-utils  <span class="hljs-comment"># 安装Apache</span><br>a2enmod cgi <span class="hljs-built_in">alias</span> <span class="hljs-built_in">env</span> headers ssl           <span class="hljs-comment"># 启用相关模块</span><br>systemctl restart apache2  <span class="hljs-comment"># 重启</span><br></code></pre></td></tr></table></figure></li>
<li>确保主机的80或443端口开放。如有防火墙限制、需要端口转发等问题，请事先处理好。</li>
</ul>
<h4 id="改权限"><a href="#改权限" class="headerlink" title="改权限"></a>改权限</h4><ul>
<li>允许web服务器对<code>仓库目录</code>的读写权限：<code>chgrp -R www-data /srv/git</code></li>
<li>新建虚拟主机配置文件并设定权限：<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/apache2/sites-available<br>sudo <span class="hljs-built_in">touch</span> git-http.conf<br>sudo <span class="hljs-built_in">chgrp</span> www-data git-http.conf   <span class="hljs-comment"># 若要递归，用`-R`</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li>在<code>git-http.conf</code>写入：  <figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">&lt;VirtualHost *:80&gt;<br>  ServerName git.taddream.site<br>  DocumentRoot /var/www/gitweb<br>  ...<br>&lt;/VirtualHost&gt;<br></code></pre></td></tr></table></figure></li>
<li>VirtualHost标签中添加git相关配置：让 <code>git-http-backend脚本</code>作为 Web 服务器对 <code>/git 路径请求</code>的CGI处理器。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">SetEnv GIT_PROJECT_ROOT /srv/git<br>SetEnv GIT_HTTP_EXPORT_ALL<br>ScriptAlias /git/ /usr/lib/git-core/git-http-backend/<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果留空 GIT_HTTP_EXPORT_ALL 这个环境变量，Git 将只对无授权客户端提供带 git-daemon-export-ok 文件的版本库，就像 Git 守护进程一样。</p>
</blockquote>
</li>
<li>VirtualHost标签中添加<code>授权验证</code>(当对仓库有写入时)  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;Files &quot;git-http-backend&quot;&gt;<br>  AuthType Basic<br>  AuthName &quot;Git Access&quot;<br>  AuthUserFile /srv/git/.htpasswd<br>  Require expr !(%&#123;QUERY_STRING&#125; -strmatch &#x27;*service=git-receive-pack*&#x27; || %&#123;REQUEST_URI&#125; =~ m#/git-receive-pack$#)<br>  Require valid-user<br>&lt;/Files&gt;<br></code></pre></td></tr></table></figure></li>
<li><details class="tag-plugin colorful folding" ><summary><span>其他配置</span></summary><div class="body"><ul><li>对拉取操作也要<code>授权验证</code>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;LocationMatch &quot;^/git/.*/git-receive-pack$&quot;&gt;<br>    Options +ExecCGI<br>    AuthType Basic<br>    AuthName &quot;Git Access&quot;<br>    AuthUserFile /etc/apache2/.htpasswd_project1<br>    Require valid-user<br>&lt;/LocationMatch&gt;<br></code></pre></td></tr></table></figure></li><li>其他</li></ul></div></details></li>
</ol>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>因为配置中用到了<code>.htpasswd</code>文件，所以需要添加 Apache 授权用户<br><code>$ htpasswd -c /srv/git/.htpasswd yourname</code></p>
<blockquote>
<p>如果已经创建过 .htpasswd 文件，去掉 <code>-c</code><br>命令执行后，终端会让你设置密码。完成后<code>.htpasswd</code>中会将密码加密存放。</p>
</blockquote>
<h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><p>启动虚拟主机，重启 Apache</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/apache2/sites-available<br>a2ensite git-http.conf  <span class="hljs-comment"># 注意，`a2ensite`命令操作的目标文件一定不能带路径。</span><br>systemctl restart apache2<br></code></pre></td></tr></table></figure>

<h4 id="bingo！测试"><a href="#bingo！测试" class="headerlink" title="bingo！测试"></a>bingo！测试</h4><ul>
<li>开发者已经可以用http来clone、fetch了：<code>git clone http://git.taddream.site:10580/git/project.git</code><blockquote>
<p>注：API中的<code>/git/</code>即服务器上的<code>/srv/git/</code>目录</p>
</blockquote>
</li>
<li>开发者也能push的，如果此前对push操作（<code>git-receive-pack</code>）设置了授权验证，那么push过程会让你输入Apache的用户密码。</li>
</ul>
<h3 id="建立GitWeb"><a href="#建立GitWeb" class="headerlink" title="建立GitWeb"></a>建立GitWeb</h3><p>GitWeb是一个 Git 服务器的简易 web 界面，使用 GitWeb 来显示仓库的信息。</p>
<h4 id="查看临时web"><a href="#查看临时web" class="headerlink" title="查看临时web"></a>查看临时web</h4><p>使用<code>轻量web服务器</code>。<a href="#%E8%BD%BB%E9%87%8FGitWeb">见</a></p>
<h4 id="持续维护的web"><a href="#持续维护的web" class="headerlink" title="持续维护的web"></a>持续维护的web</h4><p>使用<code>gitweb软件包</code>，包内有CGI脚本。</p>
<ol>
<li><p>【准备软件包】</p>
<ul>
<li>先获取gitweb目录：用<code>whereis gitweb</code>查看系统是否自带，若自带，一般存在于<code>/usr/share/gitweb/</code>; 若不自带，则用下述命令手动安装，得到<code>./gitweb/</code>目录。  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://git.kernel.org/pub/scm/git/git.git<br><span class="hljs-built_in">cd</span> git/ <br>make GITWEB_PROJECTROOT=<span class="hljs-string">&quot;/srv/git&quot;</span> prefix=/usr gitweb<br></code></pre></td></tr></table></figure></li>
<li>后移动目录：放到Apache默认网页目录下：<code>sudo cp -Rf &lt;path of gitweb&gt; /var/www/</code></li>
<li>最后配置gitweb: 为了指定git仓库目录，需在<code>/etc/gitweb.conf</code>(没有则创建)中写入<code>$projectroot = &quot;/home/git/repositories&quot;;</code></li>
</ul>
</li>
<li><p>【配置虚拟主机】<br>还记得<code>用smart HTTP搭建</code>Git服务器里的<a href="#%E9%85%8D%E7%BD%AE">配置</a>环节吗？当时只实现了用<code>http://git.taddream.site:10580</code>来传输仓库(<code>SetEnv GIT_PROJECT_ROOT</code>), 而没有用这个url来同时实现仓库的网页查看(<code>DocumentRoot</code>)。<br>为此我们配置如下: </p>
<ul>
<li>修改<code>VirtualHost</code>标签里的<code>DocumentRoot</code>属性；</li>
<li><del>若用的系统自带的<code>gitweb包</code>，还需配置环境变量<code>GITWEB_PROJECTROOT</code>；</del> 更新，不必配置该环境变量，只需配置<code>/etc/gitweb.conf</code>即可；</li>
<li>并增加<code>Directory</code>子标签。 <figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">DocumentRoot /var/www/gitweb<br>SetEnv GITWEB_PROJECTROOT /srv/git<br>&lt;Directory /var/www/gitweb&gt;<br>    Options +ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch<br>    AllowOverride All<br>    order allow,deny<br>    Allow from all<br>    AddHandler cgi-script cgi<br>    DirectoryIndex gitweb.cgi<br>&lt;/Directory&gt;<br></code></pre></td></tr></table></figure>
在重启Apache(<code>systemctl restart apache2</code>)后，我们就可以访问<code>http://git.taddream.site:10580</code>来查看仓库了。</li>
</ul>
</li>
</ol>
<h3 id="建立GitLab-better-GitWeb"><a href="#建立GitLab-better-GitWeb" class="headerlink" title="建立GitLab (better GitWeb)"></a>建立GitLab (better GitWeb)</h3><p>是比GitWeb更现代，功能更全的 Git 服务器。GitLab 是一个数据库支持的 web 应用，安装也更复杂。<br>资料：<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-GitLab">git-&gt;gitlab</a><br>TODO: 用到再研究该模块</p>
<h2 id="Git的协作方式"><a href="#Git的协作方式" class="headerlink" title="Git的协作方式"></a>Git的协作方式</h2><p>Git是分布式的，它可以很好地支持多人协作。</p>
<h3 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h3><h4 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h4><p>属于单点协作模型。使用广泛。所有开发者都需要与仓库对齐。<br>工作特点：不支持<code>非快进式（non-fast-forward）</code>推送，即<code>push</code>前须对仓库可能存在的更新进行<code>fetch+merge</code>。</p>
<h4 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="集成管理者工作流"></a>集成管理者工作流</h4><p>GitHub&#x2F;GitLab中使用最广泛的。项目是<code>只读</code>的，开发者只能fork，想推送到<code>master</code>分支时只能呼叫请求管理者进行push。<br>优点之一: 你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。<br>流程<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/wfdiag_b">见</a></p>
<h4 id="主管与副主管工作流"><a href="#主管与副主管工作流" class="headerlink" title="主管与副主管工作流"></a>主管与副主管工作流</h4><p>多见于大型项目, 如Linux内核。<br>副主管（lieutenant），即<code>各个集成管理者</code>分别负责集成项目中的特定部分。<br>主管（dictator），即<code>总集成管理者</code>负责统筹，维护<code>参考仓库</code>。</p>
<h4 id="整合-管理者工作流"><a href="#整合-管理者工作流" class="headerlink" title="整合-管理者工作流"></a>整合-管理者工作流</h4><p>类似于<code>主管-副主管</code>，但这里没有主管，而是副主管们形成集中式工作流。然后开发者和副主管之间的关系则来自<code>集成管理者工作流</code>。</p>
<h3 id="贡献项目"><a href="#贡献项目" class="headerlink" title="贡献项目"></a>贡献项目</h3><h4 id="贡献原则"><a href="#贡献原则" class="headerlink" title="贡献原则"></a>贡献原则</h4><ul>
<li>【纠错】：提交前要检查错误，特别是空白错误：<code>git diff --check</code></li>
<li>【切小块】：每一次提交的变更，应该只针对一个小问题的解决，而不应该是多个小问题攒起来后再提交。<ul>
<li>如果一个文件有大量修改，而想切小块多次提交怎么办：用<code>交互式暂存</code>，即<code>git add --patch</code></li>
</ul>
</li>
<li>【优质的提交信息】：<code>git commit -m &quot;&lt;msg&gt;&quot;</code>中，<code>msg</code>&#x3D; 少于50字节的摘要性描述(<code>标题</code>) + 一个空白行 + 详细的变更描述(<code>正文</code>)。<blockquote>
<p>正文中可以有：<code>空行</code>来分段，<code>项目符号</code> 如数字和 - *，<code>悬挂缩进</code>等。</p>
</blockquote>
</li>
</ul>
<h4 id="在不同级别的团队中"><a href="#在不同级别的团队中" class="headerlink" title="在不同级别的团队中"></a>在不同级别的团队中</h4><ul>
<li>在私有小型团队中<br>即项目为两三个人私有开发。多使用<a href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81">集中式工作流</a></li>
<li>在私有管理团队中<br>即有很多人参与的不公开项目。多使用<a href="#%E6%95%B4%E5%90%88-%E7%AE%A1%E7%90%86%E8%80%85%E5%B7%A5%E4%BD%9C%E6%B5%81">整合-管理者工作流</a></li>
</ul>
<h4 id="在公开项目-用fork-PR"><a href="#在公开项目-用fork-PR" class="headerlink" title="在公开项目-用fork-PR"></a>在公开项目-用fork-PR</h4><p>特点：没有权限直接更新项目的master分支，需要用到<code>fork</code>和<code>pull request</code>。<br>工作流程：</p>
<ul>
<li><code>git clone &lt;project-url&gt;</code>: 本地仓库将有一个<code>origin</code>连接project-url</li>
<li><code>git checkout -b featureA</code>：新建分支开始自己的工作</li>
<li>…work: 新增，修改，多次提交等</li>
<li><code>fork</code>：去GitHub的项目主页派生</li>
<li><code>git remote add myfork &lt;forked-project-url&gt;</code>: 添加<code>remote</code>，即你的派生仓库url</li>
<li><code>git push -u myfork featureA</code><blockquote>
<p>origin没有权限，只能推送到<code>派生仓库</code>myfork;<br>这里不是把featureA合并到master再推送到myfork&#x2F;master，而是保留主分支，直接推送featureA分支到新分支myfork&#x2F;featureA。 </p>
</blockquote>
</li>
<li><code>拉取请求(Pull Request)</code>：通知原项目的维护者你有想要他们合并的工作。<a href="#%E5%85%B3%E4%BA%8EPull-Request">详见</a></li>
<li>等待管理者审查、讨论、合并，最终实现你的贡献被更新到原仓库的master上。</li>
</ul>
<h5 id="关于Pull-Request"><a href="#关于Pull-Request" class="headerlink" title="关于Pull-Request"></a>关于Pull-Request</h5><ul>
<li><p>方法1：在GitHub网页上进行 – 相当方便</p>
<ul>
<li>PR流程：进入派生仓库的刚刚push的分支页面，会自动出现<code>Compare &amp; PR</code>按钮，进入按提示创建PR即可。如图：<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://assets.taddream.site/wiki/my-notes/GitHub上创建PR.png" alt="GitHub上创建PR" width="90%"/></li>
<li>一些重要的知识点：<ul>
<li>【PR前不必总是 Fork】：当你对源项目有写权限，那就可以直接推送<code>特性分支</code>过去，然后手动创建一个master分支的<code>PR页面</code>，进行代码审查和讨论等协作。</li>
<li>【PR后仍可提交】：当你对<code>特性分支</code>发起PR后，讨论过程中仍可以在特性分支上继续提交。最终PR的merge会整合‘从PR前到讨论后’的所有改动。</li>
<li>【发起PR的场所】：任何分支上均可，甚至可在PR上发起PR</li>
<li>【派生仓库的master不要动】：建议你的工作在派生仓库的<code>特性分支</code>上进行，派生仓库的master多用来与源仓库的master对齐。</li>
<li>【不干净合并情况的处理】：<code>不干净合并</code>就是在PR时报错存在<code>合并冲突</code>。解决冲突有两种方法：<ul>
<li><code>变基</code>：（不推荐）派生仓库中，把你的特性分支，变基到master分支中。由于变基容易搅乱提交历史的性质。</li>
<li><code>反向合并</code>: （推荐！）拉取源仓库的master，将其合并到你派生仓库的特性分支上，修复提示的冲突，推送回远程派生仓库的特性分支，再次发起PR。该过程类似于<a href="#%E8%AE%A9%E6%B4%BE%E7%94%9F%E4%BB%93%E5%BA%93%E4%BF%9D%E6%8C%81%E6%9B%B4%E6%96%B0">派生仓库的更新</a></li>
</ul>
</li>
<li>【引用】：GitHub的评论中可以引用PR、issue、commit。<ul>
<li><code>议题引用</code>: 项目中所有的PR和Issue（议题）都会生成一个<code>独一无二的编号</code>以供引用。引用方式有三种：<ul>
<li>直接引用当前仓库的PR&#x2F;Issue: <code>#123</code></li>
<li>引用别人派生仓库的Issue：<code>&lt;username&gt;#123</code></li>
<li>引用完全不同项目的PR&#x2F;Issue：<code>&lt;username&gt;/&lt;projectName&gt;#123</code></li>
</ul>
</li>
<li><code>提交引用</code>：必须完整的写出 40 位长的 SHA-1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方法2：用<code>git request-pull</code>命令</p>
<ul>
<li><code>git request-pull origin/master myfork</code>: <ul>
<li>命令解释：’origin&#x2F;master’是<code>基础分支</code>，即希望管理者在原项目的该分支上拉取我的贡献；’myfork’是给管理者指明应该去哪个url拉取内容。</li>
<li>命令输出：一个请求拉取的所有修改的摘要。这个摘要可以用来通过邮件发给项目管理员。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="在公开项目-用邮件"><a href="#在公开项目-用邮件" class="headerlink" title="在公开项目-用邮件"></a>在公开项目-用邮件</h4><p>【不常用】<br>该方法区别于<code>fork+pull request</code>: 这里是直接把每一次提交变成<code>补丁文件</code>，然后用邮件发给项目管理者。<br>命令：<code>git format-patch -M origin/master</code>，得到每个提交生成的<code>.patch</code>文件，然后可以用<code>git send-email *.patch</code>命令发送，或手动发送那些文件。</p>
<h3 id="维护项目"><a href="#维护项目" class="headerlink" title="维护项目"></a>维护项目</h3><p>如何成为一个项目的管理者。一般流程是：为将要整合的新东西新开分支 -&gt; 导入补丁到新分支 -&gt; 检查贡献内容 -&gt; 合并到原项目的目标分支(e.g. master) -&gt; 想发布时，可为发布打标签 -&gt; 为发布生成构建号 -&gt; 发布 -&gt; 制作提交简报。具体如下。</p>
<h4 id="1、导入大家的贡献"><a href="#1、导入大家的贡献" class="headerlink" title="1、导入大家的贡献"></a>1、导入大家的贡献</h4><h5 id="场景1：贡献者邮件传来-patch"><a href="#场景1：贡献者邮件传来-patch" class="headerlink" title="场景1：贡献者邮件传来.patch"></a>场景1：贡献者邮件传来<code>.patch</code></h5><p>【该场景多用于贡献频率较低的开发者】<br>工作流程为，①在原始仓库中开启新分支，用以测试补丁；②把补丁内容应用到工作目录，用以查看、检查、测试；③<code>手动</code>暂存并提交补丁所引入的更改；④按需把新补丁合并到master。<br>其中第二步有两种情况：</p>
<ul>
<li>情况1，.patch文件由<code>git diff</code>生成，可使用命令<code>git apply /path/*.patch</code>：<br>该命令优于<code>patch -p1</code>。<br>在执行前还可先检查补丁：<code>git apply --check /path/*.patch</code>。</li>
<li>情况2，.patch文件由<code>git format-patch</code>生成，可使用命令<code>git am /path/*.patch</code>:<blockquote>
<ol>
<li>git am 是为了读取 mbox 文件而构建的， mbox 是一种用来在单个文本文件中存储一个或多个电子邮件消息的简单纯文本格式，.patch文件开头就是Mbox格式。</li>
<li>一个mbox 文件可以包含多个补丁文件。生成方法：开发者用<code>git send-email</code>发来所有补丁，你将其下载成mbox格式即可。</li>
</ol>
</blockquote>
当更改过于复杂，补丁应用将失败，你可以：<ul>
<li>手动解决所有标记出来的冲突（就和merge时一样），然后暂存文件，然后用<code>git am --resolved</code>告诉系统冲突解决，继续下一个文件。</li>
<li>也可用参数智能应对：<code>git am -3 /path/*.patch</code>，尝试<code>三方合并</code>的方法。前提是用于创建补丁的提交对象（即<code>公共祖先</code>）在你的版本库内。</li>
</ul>
</li>
</ul>
<h5 id="场景2：贡献者用fork-PullRequest"><a href="#场景2：贡献者用fork-PullRequest" class="headerlink" title="场景2：贡献者用fork+PullRequest"></a>场景2：贡献者用fork+PullRequest</h5><p>你此刻处于<code>本地源仓库</code>, 有多种方法对新补丁进行导入、审查、合并。</p>
<ul>
<li><p>方法1：添加<code>remote</code>（多用于长期贡献的开发者）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git remote add devlpr1 &lt;developer-forked-project-url&gt;     <span class="hljs-comment"># 添加开发者邮件中指定的`remote`</span><br>git fetch devlpr1<br>git checkout -b featureA devlpr1/featureA <span class="hljs-comment"># 把开发者在派生仓库的特性分支，检出到本地的特性分支，同时设置好了`追踪`。</span><br></code></pre></td></tr></table></figure>
<p>审核后没问题就可以合并了，具体怎么合并还要看你的<a href="#3%E3%80%81%E5%90%88%E5%B9%B6%E8%B4%A1%E7%8C%AE%E5%86%85%E5%AE%B9">工作流</a>。</p>
</li>
<li><p>方法2：用<code>临时抓取合并</code>命令（多用于临时开发者的PR）<br><code>git pull &lt;developer-forked-project-url&gt; &lt;featureA&gt;</code>。<br>审核后没问题就可以合并了，具体怎么合并还要看你的<a href="#3%E3%80%81%E5%90%88%E5%B9%B6%E8%B4%A1%E7%8C%AE%E5%86%85%E5%AE%B9">工作流</a>。</p>
</li>
<li><p>方法3：<code>PR页面</code>上操作<br><code>PR页面</code>的<code>merge pull request</code>按钮会指导我们进行琐碎的拉取合并过程。如：<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://git-scm.com/book/en/v2/images/maint-02-merge.png" alt="合并按钮和手工合并一个合并请求的指令"> </p>
</li>
<li><p>方法4：使用<code>合并请求分支</code>（多用于有大量PR时使用）<br><a href="#PR%E5%88%86%E6%94%AF">PR分支的概述</a><br>该方法的核心是，把<code>PR引用的路径</code>从对本地源仓库的<code>隐身状态</code>，变为可拉取可合并的<code>显式分支</code>。</p>
<ul>
<li>处理单个PR时：<br>-&gt; 获取PR编号如<code>#372</code><br>-&gt; 在<code>git ls-remote origin</code>中获取编号对应的索引路径，如<code>refs/pull/372/head</code><br>-&gt; 直接抓取该分支：<code>git fetch origin refs/pull/372/head</code><br>-&gt; 该分支合并到本地源仓库的<code>测试分支</code>:<code>git checkout -b test; git merge FETCH_HEAD</code><br>-&gt; 审查后就可以合并到master，伺机push了。</li>
<li>处理大量PR时：<ul>
<li>先配置<code>origin</code>:<br>打开<code>./git/config</code>，在<code>[remote &quot;origin&quot;]</code>模块下添加 <div class="tag-plugin copy"><span>txt</span><input class="copy-area" id="copy_23" value="fetch = +refs/pull/*:refs/remotes/origin/pr/*"><button class="copy-btn" onclick="util.copy(&quot;copy_23&quot;,&quot;复制成功&quot;)"><svg class="icon copy-btn" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path></svg></button></div><br>其作用是让远程源仓库的所有看起来像<code>refs/pull/123/head</code>的引用应该在本地版本库像 <code>refs/remotes/origin/pr/123</code> 一样存储。<blockquote>
<p>当然如果你有多个远程仓库，这里‘origin’也可换成你想要的‘shortname’。</p>
</blockquote>
</li>
<li>后执行<code>git fetch origin</code>, 用fetch更新后，一次性把所有的<code>PR分支</code>都变成了<code>显式分支</code></li>
<li>后检出一个<code>PR分支</code>:<code> git checkout pr/123</code></li>
<li>审查后就可以合并到master，伺机push了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2、检查贡献内容"><a href="#2、检查贡献内容" class="headerlink" title="2、检查贡献内容"></a>2、检查贡献内容</h4><ul>
<li>查看贡献者独有的提交: <code>git log featureA --not master</code>（即master之后，featureA之前的提交）</li>
<li>查看贡献代码的具体差异：<ul>
<li><code>git diff master [featureA]</code>: 用于master是featureA的<code>直接祖先</code>时；</li>
<li><code>git diff $(git merge-base featureA master) [featureA]</code>: 用于master有分叉后，应该手动寻找master与featureA的<code>公共祖先</code>后，再与贡献者的分支比较差异。<blockquote>
<p> 简化命令：<code>git diff master...featureA</code>, 该方法下对比的两个主体是：后者分支、两者的<code>公共祖先</code>分支。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="3、合并贡献内容"><a href="#3、合并贡献内容" class="headerlink" title="3、合并贡献内容"></a>3、合并贡献内容</h4><h5 id="常见合并工作流–两阶段"><a href="#常见合并工作流–两阶段" class="headerlink" title="常见合并工作流–两阶段"></a>常见合并工作流–两阶段</h5><p>一旦<code>本地源仓库</code>有新内容的分支审核完毕，则将其合并入稳定的master分支，如此反复操作。<br>在重要项目中，考虑使用<code>两阶段合并循环</code>: </p>
<ul>
<li>你会维护两个长期分支，分别是 master 和 develop，master 分支只会在一个非常稳定的版本发布时才会更新，而所有的新代码会首先整合进入 develop 分支。 </li>
<li>你定期将这两个分支推送到公共版本库中。 </li>
<li>每次需要<code>合并新的主题分支</code>时, 应该合并进入 develop 分支；</li>
<li>当<code>打标签发布</code>的时候，你会将 master 分支快进到已经稳定的 develop 分支。<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://assets.taddream.site/wiki/my-notes/图解-两阶段合并循环.png" alt="图解-两阶段合并循环" width="80%"/></li>
</ul>
<h5 id="大项目合并工作流–四阶段"><a href="#大项目合并工作流–四阶段" class="headerlink" title="大项目合并工作流–四阶段"></a>大项目合并工作流–四阶段</h5><p>资料： <a target="_blank" rel="noopener" href="https://github.com/git/git/blob/master/Documentation/howto/maintain-git.txt">Git 维护者手册</a><br>四个长期分支：</p>
<ul>
<li>master：稳定版本库。特点，始终在进行<code>快进</code>。</li>
<li>next：特点，偶尔会被<code>变基</code>。</li>
<li>pu（proposed updates）：用于新工作。特点，<code>变基</code>比较频繁。</li>
<li>maint（maintenance backports）：用于维护性向后移植工作<br>工作流程：</li>
<li>master分出不同的<code>主题分支</code>(理解为项目模块)；</li>
<li>贡献者们在不同的主题下工作，成果被收入各个主题分支，方法可参考<a href="#%E5%9C%A8%E5%85%AC%E5%BC%80%E9%A1%B9%E7%9B%AE-%E7%94%A8fork-PR">fork+PR</a>；</li>
<li>测试评估一个主题分支是否能合并，或者仍需要更多工作。<ul>
<li>若可验收，将被并入 next 分支；</li>
<li>若需更多工作，将被并入 pu 分支；</li>
</ul>
</li>
<li>之后当next或pu完全稳定，则再次并入 master 分支（实际就是master快进到next或pu分支）。</li>
<li>一个主题并入master后，便会被从版本库中删除掉。</li>
<li>在需要的时候，将发布一版新的master。同时上一版master会派生出<code>maint分支</code>，提供向后移植过来的补丁以供发布维护更新。</li>
</ul>
<h5 id="变基与拣选工作流"><a href="#变基与拣选工作流" class="headerlink" title="变基与拣选工作流"></a>变基与拣选工作流</h5><p>有些维护者更喜欢保持<code>线性的提交历史</code>。<br>具体使用<a href="#%E5%8F%98%E5%9F%BA-rebase">参考</a></p>
<h4 id="4、为发布打标签"><a href="#4、为发布打标签" class="headerlink" title="4、为发布打标签"></a>4、为发布打标签</h4><p><a href="#%E6%A0%87%E7%AD%BE%E7%B1%BB">参考</a></p>
<h4 id="5、生成构建号-可选"><a href="#5、生成构建号-可选" class="headerlink" title="5、生成构建号(可选)"></a>5、生成构建号(可选)</h4><p><a href="#%E6%9E%84%E5%BB%BA%E5%8F%B7">参考</a></p>
<h4 id="6、准备一次发布"><a href="#6、准备一次发布" class="headerlink" title="6、准备一次发布"></a>6、准备一次发布</h4><p>创建一个最新的快照归档，封装成压缩包进行发布。</p>
<ul>
<li><code>gzip</code>格式：<div class="tag-plugin copy"><span>$</span><input class="copy-area" id="copy_24" value="git archive master --prefix=project/ | gzip > `git describe master`.tar.gz"><button class="copy-btn" onclick="util.copy(&quot;copy_24&quot;,&quot;复制成功&quot;)"><svg class="icon copy-btn" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path></svg></button></div></li>
<li><code>zip</code>格式：<div class="tag-plugin copy"><span>$</span><input class="copy-area" id="copy_25" value="git archive master --prefix=project/ --format=zip > `git describe master`.zip"><button class="copy-btn" onclick="util.copy(&quot;copy_25&quot;,&quot;复制成功&quot;)"><svg class="icon copy-btn" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path></svg></button></div><blockquote>
<p>注：这里操作的分支是master；整个项目被放进了<code>project</code>目录再压缩的；因为使用了describe，所以要保证master此前有tag(with -a&#x2F;-S)。</p>
</blockquote>
</li>
</ul>
<h4 id="7、制作提交简报"><a href="#7、制作提交简报" class="headerlink" title="7、制作提交简报"></a>7、制作提交简报</h4><p>shortlog可以快速生成一份包含从<code>上次发布</code>之后项目新增内容的修改日志（changelog）类文档，即给定范围内的所有提交的摘要的总结。<br><code>git shortlog --no-merges master --not v1.0.1</code>（ v1.0.1以来的所有提交的总结。）</p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="贡献项目-1"><a href="#贡献项目-1" class="headerlink" title="贡献项目"></a>贡献项目</h3><p>常用的工作流程：</p>
<ul>
<li>贡献者（fork &gt; clone &gt; work &gt; push &gt;PR，<a href="#%E5%9C%A8%E5%85%AC%E5%BC%80%E9%A1%B9%E7%9B%AE-%E7%94%A8fork-PR">详见</a>），</li>
<li>管理者（审查、讨论、合并、关闭PR，都在网页上进行）。<blockquote>
<p>每个分支都有自己的PR</p>
</blockquote>
</li>
</ul>
<h4 id="GitHub风格的Markdown"><a href="#GitHub风格的Markdown" class="headerlink" title="GitHub风格的Markdown"></a>GitHub风格的Markdown</h4><p>它增加了一些基础的 Markdown 中做不到的东西。 它在创建拉取请求和议题中的<code>评论和描述</code>时十分有用。</p>
<h5 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h5><p>方法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> [X] 编写代码<br><span class="hljs-bullet">-</span> [ ] 编写所有测试程序<br><span class="hljs-bullet">-</span> [ ] 为代码编写文档<br></code></pre></td></tr></table></figure>
<p>效果：只需要点击复选框，就能更新评论 —— 你不需要直接修改 Markdown。在PR的总览页面上还能看到它的进度条。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://assets.taddream.site/wiki/my-notes/github-markdown-任务列表.png" alt="github-markdown-任务列表" width="50%"/></p>
<h5 id="引用别人评论的部分句子"><a href="#引用别人评论的部分句子" class="headerlink" title="引用别人评论的部分句子"></a>引用别人评论的部分句子</h5><p>方法：你的评论中复制那些句子，在每行前添加 <code>&gt;</code> 符号即可。</p>
<h5 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h5><p>方法：句首用<code>:</code>开头（e.g. <code>:eye</code>），句中则在冒号前加空格（e.g. <code> :eye</code>）。</p>
<h4 id="让派生仓库保持更新"><a href="#让派生仓库保持更新" class="headerlink" title="让派生仓库保持更新"></a>让派生仓库保持更新</h4><ul>
<li>方法1：进入<code>本地派生仓库</code>的master &gt; 把<code>远程的源仓库</code>的master拉取合并到本地master &gt; 更新后的本地master推送到<code>远程派生仓库</code>  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout master<br>git pull &lt;url&gt;<br>git push origin master<br></code></pre></td></tr></table></figure></li>
<li>方法2: 方法1的简化版，配置本地仓库<code>remote</code>里的<code>fetch-url</code>为项目源仓库的url、<code>push-url</code>保持为项目派生仓库的url。  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git remote add forked_origin &lt;url&gt;                <span class="hljs-comment"># 添加源仓库的url</span><br>git branch --set-upstream-to=forked_origin/master master  <span class="hljs-comment"># 通过修改追踪分支，来改变fetch-url</span><br>git config --<span class="hljs-built_in">local</span> remote.pushDefault origin      <span class="hljs-comment"># 保持push-url</span><br></code></pre></td></tr></table></figure>
  最后使用简化的命令组合即可：<div class="tag-plugin copy"><span>$</span><input class="copy-area" id="copy_26" value="git checkout master; git pull; git push"><button class="copy-btn" onclick="util.copy(&quot;copy_26&quot;,&quot;复制成功&quot;)"><svg class="icon copy-btn" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path></svg></button></div></li>
<li>方法3: 直接在远程派生仓库的GitHub网页点击<code>Sync fork</code>即可。<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://assets.taddream.site/wiki/my-notes/github-同步fork按钮.png" alt="github-同步fork按钮" width="80%"/></li>
</ul>
<h3 id="维护项目-1"><a href="#维护项目-1" class="headerlink" title="维护项目"></a>维护项目</h3><p>· 1、创建新的版本库：其中，当分享url的时候，推荐HTTP(s)的，因为SSH的需要GitHub账号秘钥等。<br>· 2、添加合作者：给他们push权限。<br>· 4、PR中的提醒、通知和订阅。<br>· 5、网页通知VS邮件通知。</p>
<h4 id="3、管理合并请求"><a href="#3、管理合并请求" class="headerlink" title="3、管理合并请求"></a>3、管理合并请求</h4><p>（一些PR的<a href="#%E5%85%B3%E4%BA%8EPull-Request">知识点</a>）<br>先用邮件或<code>PR页面</code>对发起的一个<code>PR</code>进行通知、审查、讨论和改进。(邮件和评论是同步的)。<br>然后当你决定要合并了，有这<a href="#%E5%9C%BA%E6%99%AF2%EF%BC%9A%E8%B4%A1%E7%8C%AE%E8%80%85%E7%94%A8fork+PullRequest">4种方法</a></p>
<h4 id="6、特殊文件"><a href="#6、特殊文件" class="headerlink" title="6、特殊文件"></a>6、特殊文件</h4><ul>
<li>README</li>
<li>贡献 CONTRIBUTING：指出对于你的项目开启的合并请求你想要的／不想要的各种事情。 这样别人在开启合并请求之前可以读到这些指导方针。</li>
</ul>
<h3 id="管理组织"><a href="#管理组织" class="headerlink" title="管理组织"></a>管理组织</h3><p><code>组织帐户</code>代表了一组共同拥有多个项目的人，同时也提供一些工具用于对成员进行分组管理。<br>TODO: 需要再学。</p>
<h3 id="脚本GitHub"><a href="#脚本GitHub" class="headerlink" title="脚本GitHub"></a>脚本GitHub</h3><p>介绍GitHub 钩子系统与 API 接口，使 GitHub 按照我们的设想来工作。</p>
<h4 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h4><p>TODO: 需要再学。<a target="_blank" rel="noopener" href="https://docs.github.com/zh/webhooks">https://docs.github.com/zh/webhooks</a></p>
<h4 id="GitHub-API"><a href="#GitHub-API" class="headerlink" title="GitHub API"></a>GitHub API</h4><ul>
<li>针对不需要授权的接口，发送一个简单的 GET 请求即可；</li>
<li>需要授权的接口，使用访问令牌<br>示例场景：</li>
<li>对一个特定议题写评论<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> \<br>     -H <span class="hljs-string">&quot;Authorization: token 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&quot;</span> \<br>     --data <span class="hljs-string">&#x27;&#123;&quot;body&quot;:&quot;写下你的评论&quot;&#125;&#x27;</span> \<br>     https://api.github.com/repos/JamesRay0713/blog-comments/issues/1/comments<br></code></pre></td></tr></table></figure></li>
<li>修改PR的状态<br>TODO: 需要再学。 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/GitHub-%E8%84%9A%E6%9C%AC-GitHub#_%E4%BF%AE%E6%94%B9_pull_request_%E7%9A%84%E7%8A%B6%E6%80%81">https://git-scm.com/book/zh/v2/GitHub-%E8%84%9A%E6%9C%AC-GitHub#_修改_pull_request_的状态</a></li>
</ul>
<h2 id="Git工具"><a href="#Git工具" class="headerlink" title="Git工具"></a>Git工具</h2><h3 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h3><p><code>交互式</code>帮助你将文件的特定部分组合成提交，确保提交是逻辑上独立的变更集。</p>
<ul>
<li><code>git add -i</code> <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ git add -i<br>          staged     unstaged path<br>  1:    unchanged        +0/-1 TODO<br>  2:    unchanged        +1/-1 index.html<br>  3:    unchanged        +5/-1 lib/simplegit.rb<br><br>*** Commands ***<br>  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]<span class="hljs-built_in">dd</span> untracked<br>  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp<br>What now&gt;<br></code></pre></td></tr></table></figure>
其中，<code>2</code>让你选择要暂存的文件；<code>5</code>让你选择要暂存某个文件的哪些行。</li>
<li>更多‘文件的部分暂存’的命令：<ul>
<li><code>git add -p</code> 相当于上面的<code>5</code></li>
<li><code>git reset --patch</code> 部分重置文件</li>
<li>git stash save –patch 部分暂存文件</li>
<li>git checkout –patch 部分检出文件</li>
</ul>
</li>
</ul>
<h3 id="贮藏与清理"><a href="#贮藏与清理" class="headerlink" title="贮藏与清理"></a>贮藏与清理</h3><h4 id="贮藏"><a href="#贮藏" class="headerlink" title="贮藏"></a>贮藏</h4><p>· 使用场景：当前分支的工作有点难以理清，因此不能有效commit，此刻又需要另开分支做更要紧的事。<br>· 作用：跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上，并将工作目录恢复到最后一次提交的状态。 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。<br>  <code>贮藏也可当做有回退功能的清理工具</code><br>· 使用方法：  </p>
<ul>
<li>在一个‘暂存区有未提交、工作目录有未暂存’的分支中</li>
<li>开启贮藏<code>git stash [push]</code> , <code>git status</code>会看到一个干净的分支。<blockquote>
<p>贮藏的所有文件都是<code>已跟踪</code>状态。 </p>
</blockquote>
</li>
<li>查看历史贮藏<code>git stash list</code></li>
<li>在当前分支中恢复贮藏<code>git stash apply [stash@&#123;2&#125;]</code> (若不指定宾语，则默认恢复stash@{0})<blockquote>
<p>除非使用<code>--index</code>，上面命令不会<code>重新暂存</code>。</p>
</blockquote>
</li>
<li>在新建分支中恢复贮藏<code>git stash branch &lt;branch1&gt; [&lt;stash&gt;]</code><blockquote>
<p>恢复成功后自动丢弃贮藏。</p>
</blockquote>
</li>
<li>移除：<code>git stash drop [stash@&#123;0&#125;]</code></li>
<li>应用+移除：<code>git stash pop [stash@&#123;0&#125;] </code><br>· 更多参数：<br>  <code>--keep-index</code><br>  <code>-u</code> 贮藏任何未跟踪文件<br>  <code>--patch</code> 交互式指定需要贮藏的内容</li>
</ul>
<h4 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h4><p>它被设计为从工作目录中移除<code>没有忽略的未跟踪的</code>文件。 如果你改变主意了，你也不一定能找回来那些文件的内容。<br>安全期间，决定清理时，先用<code>-n</code>，再改成<code>-f</code>。</p>
<ul>
<li>安全清理的替代方式：<code>git stash --all</code></li>
<li>移除工作目录中所有未追踪的文件以及空的子目录-d: <code>git clean -df</code></li>
<li>演习式清理–dry-run 或 -n ：<code>git clean -d -n</code></li>
<li>包含忽略文件：<code>-x</code></li>
</ul>
<h3 id="签名工具"><a href="#签名工具" class="headerlink" title="签名工具"></a>签名工具</h3><p>GPG<a href="/post/topic-security#Git%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">参考</a>。<br>可以签名&#x2F;验证签名的一些命令：-S&#x2F;-s</p>
<ul>
<li>签：<code>git tag -s v1.5 -m &#39;my signed 1.5 tag&#39;</code></li>
<li>签：<code>git commit -a -S -m &#39;signed commit&#39;</code></li>
<li>签：<code>git merge --verify-signatures -S &lt;branch1&gt;</code></li>
<li>看：<code>git log --show-signature -1</code>, <code>git log --pretty=&quot;format:%h %G? %aN  %s&quot;</code>(%G)</li>
<li>验：<code>git merge --verify-signatures &lt;branch1&gt;</code> 检查并拒绝没有携带可信 GPG 签名的提交</li>
</ul>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h4 id="搜文件"><a href="#搜文件" class="headerlink" title="搜文件"></a>搜文件</h4><p><code>git grep &lt;string&gt;</code>从提交历史、工作目录、甚至索引中查找一个’字符串’或者’正则表达式’。<br>参数：</p>
<ul>
<li>-n 或 –line-number 选项数来输出 Git 找到的匹配行的行号。</li>
<li>-c 或 –count 只输出匹配数。</li>
<li>-p 或 –show-function 显示每一个匹配的字符串所在的方法或函数</li>
<li>–and 确保了多个匹配出现在同一文本行中</li>
</ul>
<h4 id="搜提交"><a href="#搜提交" class="headerlink" title="搜提交"></a>搜提交</h4><ul>
<li><code>git log -S &lt;string/常量名&gt;</code> 显示新增和删除该字符串的提交</li>
<li><code>-L</code> 展示代码中一行或者一个函数的历史。<ul>
<li><code>git log -L :git_deflate_bound:zlib.c</code>: 查看 zlib.c 文件中 git_deflate_bound 函数的每一次变更.</li>
</ul>
</li>
</ul>
<h3 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h3><p>即修改历史提交，其原则是：你要修改的提交，一定不能是已经push了的提交！！！<br>有以下两种使用场景：</p>
<h4 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h4><p>【可修改内容、也可修改提交信息】<br>步骤：先在工作目录中修改、增删你的文件 -&gt; <code>git add</code> -&gt; <code>git commit --amend</code> -&gt; 自动进入编辑器，写入新的‘commit message’ -&gt; 完成。<br>效果：你的最新一次的commit实现了变更，commit的校验和也刷新了，但不会新增一个提交。</p>
<blockquote>
<p><code> --no-edit</code> 选项可以跳过编辑提交信息。</p>
</blockquote>
<h4 id="同时处理多个提交"><a href="#同时处理多个提交" class="headerlink" title="同时处理多个提交"></a>同时处理多个提交</h4><p>· 该场景下我们有多种目的：批量修改提交信息、重排序多个提交、压缩多个提交、拆分任意一个提交等。<br>· 实现它们的核心是<code>git rebase -i HEAD~3</code>，基于<code>交互式的变基工具</code>中的自定义脚本，从你在命令行中指定的提交（HEAD~3）开始，从上到下的依次重演每一个提交引入的修改。</p>
<blockquote>
<p>注意：变基范围的选择易搞错。例如想重写最近的<code>3次提交</code>(HEAD, HEAD<del>, HEAD</del>2)，则应该把’最远的那个提交(<code>HEAD~2</code>)的父提交(<code>^</code>)’传给命令，即<code>HEAD~3</code>。</p>
</blockquote>
<p>· 【总体步骤】是：</p>
<ul>
<li>执行<code>git rebase -i HEAD~3</code>，自动进入文本编辑器，可以看到有多个<code>pick行</code>，对应你指定的HEAD~3后的每一个提交。形如<details class="tag-plugin colorful folding" ><summary><span>rebase-i的编辑器</span></summary><div class="body"><figure class="highlight md"><table><tr><td class="code"><pre><code class="hljs md">pick 993162d update<br>pick e790f14 iafter reba<br>pick b7b18ae uuu---update<br><br><span class="hljs-section"># Rebase 4acbfd9..b7b18ae onto 4acbfd9 (3 commands)</span><br><span class="hljs-section">#</span><br><span class="hljs-section"># Commands:</span><br><span class="hljs-section"># p, pick <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">commit</span>&gt;</span></span> = use commit</span><br><span class="hljs-section"># r, reword <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">commit</span>&gt;</span></span> = use commit, but edit the commit message</span><br><span class="hljs-section"># e, edit <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">commit</span>&gt;</span></span> = use commit, but stop for amending</span><br><span class="hljs-section"># s, squash <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">commit</span>&gt;</span></span> = use commit, but meld into previous commit</span><br><span class="hljs-section"># f, fixup [-C | -c] <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">commit</span>&gt;</span></span> = like &quot;squash&quot; but keep only the previous</span><br><span class="hljs-section">#                    commit&#x27;s log message, unless -C is used, in which case</span><br><span class="hljs-section">#                    keep only this commit&#x27;s message; -c is same as -C but</span><br><span class="hljs-section">#                    opens the editor</span><br><span class="hljs-section"># x, exec <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">command</span>&gt;</span></span> = run command (the rest of the line) using shell</span><br><span class="hljs-section"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span><br><span class="hljs-section"># d, drop <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">commit</span>&gt;</span></span> = remove commit</span><br><span class="hljs-section"># l, label <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span> = label current HEAD with a name</span><br><span class="hljs-section"># t, reset <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span> = reset HEAD to a label</span><br><span class="hljs-section"># m, merge [-C <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">commit</span>&gt;</span></span> | -c <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">commit</span>&gt;</span></span>] <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span> [# <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">oneline</span>&gt;</span></span>]</span><br><span class="hljs-section">#         create a merge commit using the original merge commit&#x27;s</span><br><span class="hljs-section">#         message (or the oneline, if no original merge commit was</span><br><span class="hljs-section">#         specified); use -c <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">commit</span>&gt;</span></span> to reword the commit message</span><br><span class="hljs-section"># u, update-ref <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ref</span>&gt;</span></span> = track a placeholder for the <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ref</span>&gt;</span></span> to be updated</span><br><span class="hljs-section">#                       to this position in the new commits. The <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ref</span>&gt;</span></span> is</span><br><span class="hljs-section">#                       updated at the end of the rebase</span><br><span class="hljs-section">#</span><br><span class="hljs-section"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="hljs-section">#</span><br><span class="hljs-section"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="hljs-section">#</span><br><span class="hljs-section"># However, if you remove everything, the rebase will be aborted.</span><br><span class="hljs-section">#</span><br></code></pre></td></tr></table></figure></div></details>
<blockquote>
<p>注释里有脚本的完整教程。<br>注意：<code>pick行</code>的顺序是‘历史提交的正向顺序’，即从旧到新，跟<code>git log</code>的输出相反。</p>
</blockquote>
</li>
<li>编辑该脚本，以满足你重写历史的目的。参考下面的多个子标题的例子。</li>
<li>保存退出，会自动运行脚本，并自动给出接下来你需要怎么做的命令提示。同时终端会提示你正处于脚本的哪个进度：<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="http://assets.taddream.site/wiki/my-notes/git-rebase-i脚本执行进度.png" alt="git-rebase-i脚本执行进度" width="80%"/></li>
<li>按提示执行命令、解决冲突…（当提示中有<code>git add &lt;file&gt;</code>时，你甚至可以在工作区修改部分文件内容再add，当然这会有后序commit的更多冲突让你手动解决），完成！</li>
</ul>
<h5 id="脚本1：修改一个-多个历史的提交信息"><a href="#脚本1：修改一个-多个历史的提交信息" class="headerlink" title="脚本1：修改一个&#x2F;多个历史的提交信息"></a>脚本1：修改一个&#x2F;多个历史的提交信息</h5><p>· 编辑脚本：把你想修改的commitID前的<code>pick</code>改成<code>edit</code>。<br>· 脚本执行：会提示你使用<code>git commit --amend</code>，该命令会进入第一个<code>edit行</code>的commit的<code>提交信息</code>编辑器。编辑后执行提示命令<code>git rebase --continue</code>，运行下一行脚本。逐行应用，直到完成。</p>
<h5 id="脚本2：删除部分历史提交"><a href="#脚本2：删除部分历史提交" class="headerlink" title="脚本2：删除部分历史提交"></a>脚本2：删除部分历史提交</h5><p>· 编辑脚本：直接删除那些提交对应的行。<br>· 脚本执行：按提示即可。(可能用到<code>git add .</code>等)<br>· 最终效果：被删commit之后的commitID都将更新。</p>
<h5 id="脚本3：重排序历史提交"><a href="#脚本3：重排序历史提交" class="headerlink" title="脚本3：重排序历史提交"></a>脚本3：重排序历史提交</h5><p>· 编辑脚本：直接更换<code>pick行</code>的顺序，注意从上到下是从旧到新。<br>· 脚本执行、最终效果：同脚本2。</p>
<h5 id="脚本4："><a href="#脚本4：" class="headerlink" title="脚本4："></a>脚本4：</h5><h2 id="Git仓库工具"><a href="#Git仓库工具" class="headerlink" title="Git仓库工具"></a>Git仓库工具</h2><h3 id="可视化工具gitk"><a href="#可视化工具gitk" class="headerlink" title="可视化工具gitk"></a>可视化工具<code>gitk</code></h3><h3 id="轻量GitWeb"><a href="#轻量GitWeb" class="headerlink" title="轻量GitWeb"></a>轻量GitWeb</h3><ul>
<li><code>git instaweb --httpd=lighttpd</code>: 开启web, 默认1234端口。若不带<code>httpd</code>，则默认使用lighttpd。也可指定其他web服务器：apache2、webrick等，若系统没有则<code>apt</code>下载。</li>
<li><code>git instaweb --httpd=lighttpd --stop</code>: 关闭web。</li>
</ul>
<p>引用规范：“refspec.” 它是一种把 remote 的名称映射到你本地 .git 目录的方法。</p>

  
  
<div class="article-footer reveal fs14"></div>

  </article>
  
<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/my-notes/html-css-js.html">HTML+CSS+JS+jQuery+AJAX</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/wiki/my-notes/set-of-debug-and-pieces-of-knowledge.html">debug集合</a></div></section></div>

  




      
<footer class="page-footer reveal fs12"><hr><div class="text"><div style="text-align:center">

<p><a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img.shields.io/badge/Framework-Hexo-A3D1D1?logo=hexo" alt="Static Badge"></a> <a target="_blank" rel="noopener" href="https://xaoxuu.com/wiki/stellar/"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img.shields.io/badge/Theme-stellar-81C0C0" alt="Static Badge"></a> <a target="_blank" rel="noopener" href="https://vercel.com/"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img.shields.io/badge/Deploy-vercel-5CADAD?logo=vercel" alt="Static Badge"></a> <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img.shields.io/badge/License-CC_BY--NC--SA_4.0-5CADAD" alt="Static Badge"><br>Copyright © 2023-2024 JamesRay, All Rights Reserved.</p>
</div>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.23.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.23.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"codeblock":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img, .gallery img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      var script = document.createElement('script');
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>







<!-- inject -->


  </div>
</body>
</html>
