[{"title":"加解密及安全话题","path":"/post/topic-security/","content":"汇总遇到过的网络安全、加解密方面的问题。 SSH的公私钥用于身份验证：私钥在本地，公钥在远程。 GPG基础 什么是GPG：PGP 是 “Pretty Good Privacy”（相当好的隐私）的缩写，是一种用于加密、签名和验证电子通信的标准和程序。在签名时的工作方式为私钥为己所用，生成数字签名；公钥公之于众，验证我的签名。 使用场景文件和通信加密，数字签名，软件包签名，安全身份验证，密码管理等。 Git中的数字签名Git中tag, commit, merge, pull等命令都支持数字签名。其作用是使用户能够确认特定提交的作者，并确保相关命令下的提交快照在创建时未被篡改。如何在一个Git项目中配置并使用签名： 生成GPG密钥：gpg --full-generate-key, 若有现成的则不必生成。 查看并获取秘钥ID：gpg --list-secret-keys --keyid-format SHORT， 其中ID就是sec rsa1024/后的8位字符。 配置Git使用GPG密钥：git config --global user.signingkey &lt;Your_GPG_Key_ID&gt; git config --global commit.gpgSign true # 当你想在commit使用GPG签名时才开启 现在就可以使用签名了：git tag -s v0.1 -m &quot;...&quot;, git commit -S -m &quot;...&quot;, … 公布公钥，方便其他开发者验证签名： 先导出公钥然后导入Git数据库：gpg --armor --export &lt;Your_GPG_Key_ID&gt; | git hash-object -w --stdin; hash-object的作用：在版本库里把公钥存成了blob对象形式，因此会得到一串校验码。 把blob对象单独存成一个tag：git tag -a maintainer-pgp-pub &lt;校验码&gt;; 公布公钥的tag, 方便开发者获取公钥：git push --tags 其他开发者想要验证签名： 导入公钥：git show maintainer-pgp-pub | gpg --import 验证签名(tag的)：git verify-tag v1.0, 或git tag -v v1.0 验证其他操作的签名(没有专门的验证命令)：git log --show-signature 其他安全话题","tags":["Internet-Security"]},{"title":"一个特价机票的优选工具","path":"/post/flight-ticket-crawler/","content":"在两城市之间，购票平台不同，搜索时间不同，目标时段不同，目标航线不同……机票价格会有很大差别。作为一个打工人，如何高效获取最适合的特价机票呢？ 本文涉及票价时均默认包含燃油和机建费（2023&#x2F;12，标准为￥90+￥50），若有特殊情况会单独说明。 机票工具的设想作为一个普通打工人，对机票价格的要求没有最低只有更低，而每次都要花费好多时间在做机票的攻略上，所以打算做一个简单的机票工具。 该工具的后端是一个Selenium爬虫工具，输入相关搜索条件后，对全平台的机票信息进行爬取和筛选，并存入数据库；其前端类似于携程网页界面的阉割版，可指定时间段、起止城市等搜索条件，执行搜索后可返回一组价格升序排列的机票信息。 该工具的核心是找国内最低票价，所以航司服务的水平、退改签政策的合理性、托运及携行量的大小、境外机场……均不考虑。 该工具的特点是全平台比价、模糊日期搜索、以火车&#x2F;高铁票作为参考基准等。 准备工作相关工具的调研现有的机票比价工具的数据来源于国内外各大OTA(Online Travel Agency Platform)平台、航空公司官网。比价工具自身不是售票平台，选好机票后需要登录到相应的航司&#x2F;OTA进行购买。据知乎高赞用户的回答，有俩主流工具： KAYAK 客涯 特点：国外的，搜索刷新有延迟，界面简洁高级，号称同时搜索数百家旅游网站进行比价，有添加110KM范围的附近机场功能（不含境外）。 经对比测试，相同行程下的机票，有的比国内OTA的价格贵数十至上百元，有的便宜数百元。也许是因为该软件的国外基因，搜索结果更倾向于国外OTA，国内OTA&#x2F;航司的数据不全。 skyscanner 天巡 特点：国外的，搜索刷新稍有延迟，界面简洁高级，有添加附近机场功能（含境外，如深圳宝安附近可包括香港）。另外其网页对机器爬虫的检测更严格。 经对比测试，天巡搜索结果中，国内国外并重。 更多：可加入成为天巡的合作伙伴赚取佣金；它的traval API服务不对无盈利性质的个人开放。 开始设计 要爬取的平台汇总： 平台 对比价格1注1&#x2F;价格2注2 有无网页版来爬取 有无开放api 备注 客涯 ￥605&#x2F;￥605 客涯 ✅有，正在注册审核 天巡 ￥627&#x2F;￥480 天巡 ✅有，但不对个人开放，不过人家给了测试环境的API token：.sh428739766321522266746152871799 携程已收购。反爬严格 美团 ￥432&#x2F;￥432 无 ❌有，但里面没有关于机票的；另有美团企业版API，但苦于没有企业版账号。 京东 ￥940&#x2F;￥540 无 ❌有，但里面没有关于机票的 飞猪 ￥542&#x2F;￥480 飞猪 ❌有，但淘宝账号必须是阿里旅行商家 携程 ￥540&#x2F;￥480 携程 ❌有，但里面没有关于机票的，且账号注册需要公司资质 同程 ￥540&#x2F;￥480 同程 ❌有，没有关于机票的，且账号注册需要特定资质 途牛 ￥542&#x2F;￥540 途牛 ❌有，没有关于机票的，且账号注册需要特定资质 去哪儿 ￥1106&#x2F;￥480 去哪儿 ❌有，注册流程复杂，需要资质 注1：固定航班信息的机票价格对比，2024&#x2F;01&#x2F;04-22:30-00:55成都天府→北京大兴直飞的东航MU6798经济舱； 注2：2024&#x2F;01&#x2F;04 成都天府→北京大兴当天直飞的最低价对比 要考虑的情况 附近机场搜索功能要扩大范围，如成都市，不仅要包含双流、天府，还要包含绵阳、南充、宜宾、泸州等。这需要维护一个全国民航机场距离矩阵。 选择了附近机场，则要同时考虑起点-&gt;出发机场和到达机场-&gt;终点等路线的通勤价格、通勤时间的可行性。 不同平台的爬虫难度有高低，特别是美团、京东没有网页。 单程、往返的都要爬。 同一个航班信息搜索滞留久了，平台可能出现改价杀熟行为，这个无解。","tags":["爬虫"],"categories":["life"]},{"title":"手册：debug","path":"/post/manual-debug/","content":"平时遇到的各种bug及解决办法收录。【环境、命令、报错现象、原因、解决】 python相关调试场景 [UI] 带参数的调试：直接在launch.json中加入键值对：&quot;args&quot;: [ &quot;--arg1&quot;, &quot;val1&quot;, &quot;--arg2&quot;, &quot;val2&quot;, ] docker相关命令相关 `docker login`命令的报错环境：wsl2, docker重现：执行docker login报错：Error saving credentials: error storing credentials err: exec: &quot;docker-credential-desktop.exe&quot;: executable file not found in $PATH, out: &#x27;&#x27;原因：旧的Docker 凭据产生了冲突，清除掉，重新登录即可。解决：rm ~/.docker/config.jsondocker logoutdocker login连接docker守护进程被拒环境：wsl2, docker重现：执行docker run ...报错：docker: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post &quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/create&quot;: dial unix /var/run/docker.sock: connect: permission denied.原因：你的用户（james）没有足够的权限连接到 Docker 守护进程。通常情况下，这是因为用户没有加入 docker 组解决：sudo usermod -aG docker $USER # 入组newgrp docker # 重载 Linux相关ssh相关 当连接远程失败、连接重置： 先考虑服务端的ssh服务是否开启：sudo service ssh status/start 当无法锁定问题，用-v参数查看详细信息。 Windows编程相关batch脚本语言(CMD)激活conda环境的命令 报错场景：在CMD中，activate base命令可正常开启base虚拟环境，但放入.bat文件中执行会导致闪退。 解决办法：语句改为call activate base。 注意事项：conda activate base在CMD中是没有效果的。 网络连接相关url访问报错 一个url本身可被访问，但置于另一网页则无法被加载的问题场景：我的七牛云图床中一张图片的url可以打开查看，但将该url放到我博客文章里时，博客网页无法加载对应图片，浏览器控制台报错forbidden 403原因：七牛云图床有防盗链设置，且博客域名没有加入白名单。解决办法：将你想要的域名放入白名单即可。注意，经测试*.taddream.site无效，应用taddream.site和www.taddream.site；另外最好加上127.0.0.1，用以本地调试。 前端相关将内容复制到剪切板 问题描述：一个不显示的元素(即含有style=&quot;display: none;&quot;属性)的值，无法用document.execCommand(&quot;Copy&quot;)方法实现复制到剪切板的操作。 场景：在博客主题stellar-v1.23.0的源码中，作者在文章footer部分的分享文章模块有一个class=&quot;social share-item link&quot;的图标按钮，点击该按钮后，会将相应链接复制到剪切板。具体实现方式为: 先在分享文章模块中把文章的永久链接显示出来，其HTML元素为：https://github.com/xaoxuu/hexo-theme-stellar/blob/1.23.0/layout/_partial/main/article/article_footer.ejs&lt;div class=&quot;link&quot;&gt; &lt;input class=&quot;copy-area&quot; readonly=&quot;&quot; id=&quot;copy-link&quot; value=&quot;$&#123;page.permalink&#125;&quot;&gt;&lt;/div&gt; 然后对social share-item link按钮实现复制到剪切板的功能：.../article_footer.ejs&lt;a class=&quot;social share-item link&quot; onclick=&quot;util.copy(&amp;quot;copy-link&amp;quot;, &amp;quot;复制成功&amp;quot;)&quot;&gt; &lt;img 。。。&gt;&lt;/a&gt; util.copy函数的功能：通过id=&quot;copy-link&quot;找到相应元素，将元素的value属性的值复制到剪切板，源码如下：https://github.com/xaoxuu/hexo-theme-stellar/blob/1.23.0/source/js/main.jscopy: (id, msg) =&gt; &#123; const el = document.getElementById(id); if (el) &#123; el.select(); document.execCommand(&quot;Copy&quot;); if (msg &amp;&amp; msg.length &gt; 0) &#123; hud.toast(msg, 2500); &#125; &#125;&#125;, 通过这种方法，能顺利实现复制到剪切板的功能。但当我简化这个模块，通过在class=&quot;link&quot;的元素中增加style=&quot;display: none;&quot;属性，把链接隐藏起来后，发现点击class=&quot;social share-item link&quot;按钮并不能把文章链接有效地复制到剪切板。 原因：因为class=&quot;link&quot;的元素是隐藏的，无法通过document.execCommand(&quot;Copy&quot;)实现复制到剪切板的操作。chatGPT解释如下 由于浏览器安全策略的限制，直接使用 document.execCommand(“copy”) 在某些情况下可能无法正常工作。可以考虑使用更先进的 Clipboard API 或其他现代的方法。 解决办法：将copy函数中的el.select(); document.execCommand(&quot;Copy&quot;);替换为navigator.clipboard.writeText(el.value)即可。 VSCode以下是vscode-windows-desktop使用中遇到的bug及解决办法 配置问题 Git bash终端的集成问题 问题描述：系统中安装了git，且环境变量能找到git-bash.exe的路径。我想在vscode内部就能使用Git bash, 但是在终端下拉菜单中选择”Git Bash”后，实际打开的是一个独立的git-bash终端窗口，而非vscode的集成终端。 原因：未能正确配置Git bash。特别是，你想在vscode中使用git的终端工具，应该调用git目录里的bash.exe，而非git-bash.exe 解决办法： 找到终端工具的正确路径：由于我Windows中安装的不是单纯的Git，而是git-for-windows-sdk，因此所需的路径是：E:\\\\app_down\\\\Git_sdk_64\\\\usr\\\\bin\\\\bash.exe 在settings.json中配置：&quot;terminal.integrated.profiles.windows&quot;: &#123; &quot;PowerShell&quot;: &#123;&#125;, &quot;Command Prompt&quot;: &#123;&#125;, &quot;Git Bash&quot;: &#123; //&quot;path&quot;: [&quot;E:\\\\app_down\\\\Git_sdk_64\\\\git-bash.exe&quot;], 注意，这里一定是bash.exe而非git-bash.exe &quot;path&quot;: [&quot;E:\\\\app_down\\\\Git_sdk_64\\\\usr\\\\bin\\\\bash.exe&quot;], &quot;args&quot;: [], &quot;icon&quot;: &quot;terminal-bash&quot;, //&quot;source&quot;: &quot;Git Bash&quot; 如果git的安装是默认路径，则可使用source，否则使用&quot;path&quot; &#125;&#125;, &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;Git Bash&quot;, 然后就成了。 参考 其他配置问题 写博客时遇到的非常奇怪的bug: `jQuery`字符串(区分大小写)不能单独作为二级目录，否则整篇文章图片无法被懒加载场景：该页面原因：未知。","tags":["debug"],"categories":["debug"]},{"title":"手册：搭建博客网站","path":"/post/manual-build-website/","content":"从0-1, 基于hexo+ stellar+ vercel搭建博客所涉及到的方方面。 每年11&#x2F;26日前记得重新申请域名的ssl证书；若配置了七牛云图床，也要相应更新证书 博客构思我们想要做出一个什么样的个人博客？应该是能满足记录生活、学习笔记、bug收录、项目展示、产品推广、个人简历、朋友互动等等，最主要是简单易上手且方便部署。为此选择了Hexo。 环境准备 win10系统，终端用powershell或git-bash均可。 确认git可正常访问github, 有问题请参考。 安装有nvm，并以此安装了与stellar匹配的nodejs版本。验证安装成功: node -v, npm -v。 全局安装了hexo博客工具：npm install -g hexo-cli。 造一个博客源码仓库~&nbsp;如果你只想在本地搭建博客，没有远程管理及迁移的需求，可跳过该节。 在github&#x2F;gitee新建私有仓库blog-source, 克隆到本地; 进入blog-source目录，制作.gitignore: .DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/_multiconfig.yml 然后进行下节的博客搭建工作。 当需要上传博客源码时：git add --all &amp;&amp; git commit -m &quot;update&quot; &amp;&amp; git push origin main。 如果是gitee, main要换成master 本地搭建 造目录： 创建空的博客工程目录 blog-source，如果是git克隆而来则直接进入目录。 搭框架： 如果是从零开始，则先把目录所有内容移出去，后用命令hexo init来初始化得到博客框架； 如果已有博客，想移植其他主题，则建议按需移植以下目录&#x2F;文件过来：- scaffolds/ # 模版- source/ # 各种文章内容、资源 - themes/ # 主题- _config.yml # 配置文件- _config.theme.yml- package.json... 为什么不整个移植过来呢？因为其他目录&#x2F;文件都是通过上述目录&#x2F;文件生成的，保证了移植时的轻量化。 装软件：安装‘package.json’中的npm依赖，执行npm install。 配主题: 如果对`stellar`主题功能更新没有兴趣，直接安装稳定版：npm i hexo-theme-stellar 如果想跟随`stellar`作者的更新脚步，则克隆他的主题仓库， 若当前目录下有`.git&#x2F;`，那就用（仓库套仓库）： 若没有，那就用： 如果想时时更新，还有自定义需求，那就fork他的仓库到自己的GitHub，然后用上面的clone或submodule add命令即可； 然后在_config.yml中修改：theme: stellar。 以后如果主题有更新，则先同步fork，后进入`themes&#x2F;stellar&#x2F;`,执行git pull即可。 DIY主题： 先将主题目录下的config文件复制到根目录下，使得hexo可用： 然后可选择进一步根据教程设计自己的网站。 写文章：此刻你已经可以创建、修改、部署博客到本地了，常用命令有 hexo new post [title] (新建文章)hexo clean &amp;&amp; hexo g &amp;&amp; hexo s (清缓存、生成网页、本地部署) 主题手册是对stellar教程文档中大量内置标签用法的总结，用以辅助写文章。我也将时刻关注主题版本的升级，每次升级的内容都要同步添加到我的主题手册中。 部署博客到互联网最简单快捷：部署到GitHub&#x2F;Gitee 新建公有仓库，存放我们的输出的网页静态文件（即hexo g命令后生成的/public/文件夹） 仓库名有讲究：GitHub应为用户名.github.io; Gitee应为用户名 将仓库加入配置./_config.ymldeploy:- type: git repo: git@gitee.com:jamesray0713/jamesray0713.git branch: master message: &quot;update&quot;- type: git repo: https://github.com/JamesRay0713/JamesRay0713.github.io.git branch: gh-pages message: &quot;update&quot; 注意GitHub和gitee两者branch的区别 下载部署工具: npm i hexo-deployer-git 执行部署：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 仓库开启服务githubgitee在仓库的Settings设置中找到Pages选项卡，设置Source和Branch为如下图所示： 此时，我们得到了域名user.github.io。在仓库的服务下拉中找到Gitee Pages选项卡，可以什么都不要动，只需点击更新即可。此时，我们得到了域名user.gitee.io。 更好的部署：购买域名+ vercel部署Vercel可以获得更快的访问速度，但在大陆地区vercel.app和github.io均被运营商进行了DNS污染，无法直接访问。因此需要购买域名。 准备域名： 购买域名: 我在腾讯云上买了taddream.site，有效期10年，￥175，挺实惠的。 备案域名:需要备案的场景：你的存放静态文件的服务器在国内，我目前托管在vercel完全没必要的。如果你的网站有很大的访问流量，建议把服务器搬到国内。这里服务器有两种情况： 购买的云服务器：按照官方教程走即可 自己的实体服务器：该情况下备案审核要求很繁琐（特别是腾讯云），而且需要有营业执照+ 备案授权码 营业执照那里需填写法人身份信息，你得自己想办法；授权码可以去淘宝搜‘腾讯 授权码’，10块左右。 设置DNS解析：在云服务商的域名DNS解析中增加2条CNAME 解析, 主机记录分别是@、www： 主机记录 记录类型 记录值 TTL 解析请求来源(isp) @ CNAME cname.vercel-dns.com 10分钟 默认 获取免费SSL证书，一年一签。 免费证书局限性：不支持二级域名，如mail.taddream.site; 收费证书真的好贵，600+。 vercel.com部署：用GitHub账号登录，Add New... -&gt; Project, 导入我们的静态文件仓库（username.github.io）。输入projectName，这直接关系到三级域名的名字，点击部署。修改分支：因为我们的博客静态文件存到了gh-pages分支，所以在当前vercel项目中依次点击settings -&gt; git -&gt; Production Branch, 输入gh-pages即可。 分支不会立即生效，需再次用hexo d将静态文件部署上传后，这里才能自动更改。此时，我们得到了新域名taddream.vercel.app(国内不可访问)。 绑定域名：在当前vercel项目中依次点击settings -&gt; Domains -&gt; Production Branch, 填入我的域名taddream.site 修改博客配置文件, 修改之后需等待重新部署后生效： ./_config.ymlurl: https://taddream.site github自动化部署(TODO)TODO：　https://hexo.io/zh-cn/docs/github-pages 借助GitHub Actions实现自动化。我们无需再负责维护user.github.io仓库, 只需push好源码仓库即可。 gitee无自动化功能，考虑放弃gitee部署这条路。 我们直接在本地源码仓库目录的.github/workflows/下创建配置文件(即自动化脚本)，如下：.github/workflows/auto-deploy.ymlname: auto deployon: workflow_dispatch: # 手动触发 push: # push代码时触发jobs: build: runs-on: ubuntu-latest # 运行环境为最新版 Ubuntu name: auto deploy steps: # 1. 获取源码 - name: Checkout uses: actions/checkout@v3 # 使用 actions/checkout@v3 with: # 条件 submodules: true # Checkout private submodules(themes or something else). 当有子模块时切换分支？ # 2. 配置环境 - name: Setup Node.js 18.12.x uses: actions/setup-node@master with: node-version: &quot;18.12.x&quot; # 3. 生成静态文件 - name: Generate Public Files run: | npm i npm install hexo-cli -g hexo clean &amp;&amp; hexo generate # 4. 部署到 GitHub 仓库（可选） - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $&#123;&#123; secrets.DEPLOY_KEY &#125;&#125; external_repository: JamesRay0713/JamesRay0713.github.io publish_branch: gh-pages publish_dir: ./public commit_message: $&#123;&#123; github.event.head_commit.message &#125;&#125; user_name: &#x27;github-actions[bot]&#x27; user_email: &#x27;github-actions[bot]@users.noreply.github.com&#x27; # 5. 部署到服务器（可选） - name: Deploy to Server uses: easingthemes/ssh-deploy@v3 env: SSH_PRIVATE_KEY: $&#123;&#123; secrets.SERVER_SSH_KEY &#125;&#125; ARGS: &quot;-rltgoDzvO --delete&quot; EXCLUDE: &quot;.well-known, .user.ini&quot; SOURCE: public/ REMOTE_HOST: $&#123;&#123; secrets.REMOTE_HOST &#125;&#125; REMOTE_PORT: $&#123;&#123; secrets.REMOTE_PORT &#125;&#125; REMOTE_USER: $&#123;&#123; secrets.REMOTE_USER &#125;&#125; TARGET: $&#123;&#123; secrets.TARGET &#125;&#125; 选择仅部署GitHub时，只需修改其中external_repository为自己的博客静态文件仓库 配置公私钥，用于’Action的虚拟机(客户端，私钥)’同’静态文件仓库(服务端，公钥)’的通信： 准备一对公私钥(方法) 放置公钥：进入external_repository→ settings→ Deploy keys→ Add Deploy key 更高级部署：用自己的服务器略，以后探索。参考：https://zhuanlan.zhihu.com/p/120743882https://zhuanlan.zhihu.com/p/120743882 网站进一步优化使用图床关于图床服务和图床工具图床服务，如七牛云，是一种为用户提供图像存储和分享的便利平台。图床能提高博客站点的性能、稳定性，并简化博客的管理和维护。图床工具，如PicGo，简化了图片上传和链接生成的流程，提高了效率，尤其对于需要频繁上传图片的场景。 为什么要用图床服务加快页面加载速度：是将博客页面中的图片资源托管到专门的图片服务器上，从而减轻博客服务器的负担。节省博客服务器存储空间：不再把图片放在博客目录的/assets/下了。避免博客迁移和备份问题提高图片访问稳定性支持防盗链： 图床服务通常支持防盗链功能，可以限制图片只能在特定域名下显示，防止图片被其他网站直接引用，避免了大量的流量和费用。 为什么要用图床工具`PicGo`快速上传和生成链接多图床支持： weibo, qiniu, tcyun, upyun, github, aliyun, imgur and SM.MSMarkdown图片链接自动生成：简化插入图片的过程丰富的配置本地图片处理功能：如裁剪、压缩等跨平台支持：支持多个操作系统插件系统：通过安装插件来扩展 PicGo 的功能 图床服务1：七牛云(含免费)使用七牛云中的对象存储服务，￥60&#x2F;50G&#x2F;年。 资料：开发者文档，含图像处理API 优缺点： 优点：有免费额度：对象存储10G&#x2F;月+ CDN加速10G&#x2F;月；有丰富的图像处理API，可满足缩放、裁剪等。 缺点：免费只针对HTTP服务，HTTPS的图片链接要收费。但是大多数浏览器会拦截这些非安全（非 HTTPS）的资源，导致无法加载图片。 完整的搭建步骤 I. 建立一个图床空间：登录&#x2F;注册进入控制台 -&gt; 对象存储Kodo -&gt; 空间管理 -&gt; 新建空间 如果博客域名未备案，存储区域要选海外的；访问控制选公开。 II.给空间绑定域名：七牛云默认给空间绑定了临时的CDN加速域名，有效期30天，若想自定义绑定域名，有以下途径： 自定义CDN加速域名：我没购买过，pass，以后探索（TODO）； 自定义源站域名：刚好可以用我的博客域名，bingo。在经历bug和debug后，我选择默认HTTP+子域名的方式。番外篇：bug与debug的经历起初我想当然地把域名绑定成了我的主域名(taddream.site)，并在域名中添加了七牛给我的CNAME值，并对该绑定配置了HTTPS。结果就是当访问带主域名的图床外链(如https://taddream.site/img/xxx.jpg)，甚至访问主站（taddream.site）时，浏览器就会报错不安全的连接，有时稍等几分钟即恢复正常；有时完全不恢复。我认为原因是：域名的原有解析记录、和新建的七牛的解析记录打架了。因此需要用子域名来七牛的CNAME。 继续正题，绑定域名步骤如下： 点击进入空间名 -&gt; 域名管理 -&gt; 自定义源站域名 -&gt; 绑定域名，绑定时输入assets.taddream.site(这里assets改成你喜欢的)； 复制CNAME值：形如iovip-as0.qiniuio.com 给域名添加七牛的解析记录：进入域名服务商的域名管理列表 -&gt; 点击进入博客域名 -&gt; 记录管理 -&gt; 添加记录，进行如下配置： 主机记录 记录类型 记录值 其他 assets CNAME iovip-as0.qiniuio.com 默认 可选步骤：配置HTTPS：如果你的子域名(assets.taddream.site)没有SSL证书，那就略过，直接使用不安全的http；如果有，那就配置，方法如下： 从域名服务商下载证书：进入我的ssl证书 -&gt; 下载关于博客域名的pem格式证书 -&gt; 解压 上传证书到七牛：进入证书管理 -&gt; 上传自有证书 -&gt; 按提示上传刚解压的证书内容、证书私钥 点击配置HTTPS -&gt; 更换证书 III. 给空间加防盗链：点击进入空间名 -&gt; 空间设置 -&gt; Referer 防盗链 -&gt; 设置开启状态 -&gt; 在白名单中加入自己的博客地址和常用搜索引擎 -&gt; 允许空 Referer 白名单：*.taddream.site, *.baidu.com, *.bing.com, *.google.com debug: *.taddream.site放入白名单仍会得到forbidden 403的问题，见。 IV. 测试效果：上传一张图片到空间即可得到该图片的图床链接（链接的外链域名可以是我们绑定的博客子域名、也可以是七牛默认的CDN域名）。 V. 如果想让本地层级目录整个迁移到图床空间呢使用qshell同步本地文件目录到存储空间并体现出层级结构，参考文档1、文档2。以下是教程总结： 下载：下载win_x64的执行文件； 安装：解压，把.exe文件放到自定义目录，将该目录添加环境变量，这样，在cmd中就可使用qshell命令了； 添加账户：qshell account ak sk 自定义名字；查看账户：qshell user ls 这里的ak, sk在这里找。 配置：在~\\.qshell\\upload.conf中添加需要迁移的本地目录&#123; &quot;src_dir&quot; : &quot;H:\\\\blog_space\\\\hexo_arch\\\\blog-assets&quot;, //这里七牛云是将`assets`作为了‘blog-dream’空间的根目录。 //&quot;ignore_dir&quot; : true, &quot;bucket&quot; : &quot;blog-dream&quot;&#125; 执行迁移命令：qshell qupload ~\\.qshell\\upload.conf，完成。 拓展：七牛图像处理API七牛图床可以通过http://assets.taddream.site/&lt;图像名&gt;?&lt;处理接口&gt;的方式，实现裁剪、缩放、调色等操作。文档见：开发者中心-&gt;智能多媒体服务-&gt;API文档-&gt;图片处理 可视化设计接口：进入空间 -&gt; 图片样式 -&gt; 新建图片样式 示例场景： 居中裁剪出高度为100的图片：http://assets.taddream.site/my-best-avatar.png?imageMogr2/gravity/Center/crop/x100/blur/1x0/quality/75 图床工具：PicGo 它的主要功能：我们前端在编写md文档时，直接粘贴图片、或选择路径上传图片，就能得到md格式的图片链接。工具后端自动将我们选好的图片上传到图床服务商，然后返回链接，呈现在md文档中。 资料：源码，picgo-core文档, picgo文档 可以使用版本：UI软件版；VScode插件版。 这里我只探索了VScode插件版: 配置方法如下： picgo.picBed.uploader: 选择你的图床服务商，我选择了qiniu picgo.picBed.qiniu: 该模块下的相关配置参考下面，这里的前提是已经在相应服务商做好了图床空间的各种设置。 &#123; &quot;accessKey&quot;: &quot;&quot;, //在 https://portal.qiniu.com/developer/user/key 查找 &quot;secretKey&quot;: &quot;&quot;, &quot;bucket&quot;: &quot;blog-dream&quot;, // 存储空间名 &quot;url&quot;: &quot;http://assets.taddream.site&quot;, // 自定义域名，一定要带上协议头。 &quot;area&quot;: &quot;as0&quot;, // 存储区域编号 &quot;z0&quot; | &quot;z1&quot; | &quot;z2&quot; | &quot;na0&quot; | &quot;as0&quot; &quot;options&quot;: &quot;&quot;, // 网址后缀，比如 `?imgslim`。网址后缀通常是你用到了七牛的图片处理工具的时候会用到的一些处理参数，比如图片瘦身。 &quot;path&quot;: &quot;&quot; // 自定义存储路径，比如 `img/`&#125; 注：path的字符串，尾字符须为/，且首字符为/时无效，字符串内部有/则表示添加了一个父目录。当你想使用快捷键上传图片到图床的指定目录时，记得随时在这里修改path。 其他的就按你所需来配置。 使用方法如下： step1: 把光标放在你要插入图片的地方，或选中一些文字（选中的文字就是图片别名，若没有，则图片文件名就是图片别名）； step2: 方法1：复制本地图片到剪切板，在光标处按下Ctrl + Alt + U，完成！ step2: 方法2：在光标处按下Ctrl + Alt + E，手动选择本地图片，确认后完成！ 图床可存放的资源可不仅限于图片，也包括视频、音频、文档、二进制文件等，均可如上炮制。最后只需把生成的那个叹号删掉，就变成了非图片资源的超链接了。 图床服务2：Cloudflare Pages+Telegraph资料：戳该方法借助在Cloudflare搭建图床服务，实现彻底的白嫖。教程总结如下： 搭建图床网站：fork项目 -&gt; 进入 cf-pages面板 -&gt; Workers和Pages -&gt; 概述 -&gt; 先创建应用程序 -&gt; Pages -&gt; 连接到Git -&gt; … -&gt; 选择刚刚fork的仓库 后进行相关配置并部署，可全都默认，直接保存并部署 -&gt; 最终得到了自己的图床服务网站，见https://telegraph-image-1ei.pages.dev/ 也可按提示自定义域名。 管理图床网站： 添加命名空间：Workers和Pages -&gt; KV -&gt; 创建命名空间 -&gt; 起个名字(如blog-assets2) -&gt; 添加； 绑定命名空间：Workers和Pages -&gt; 概述 -&gt; 进入项目telegraph-image -&gt; 设置 -&gt; 函数 -&gt; KV命名空间绑定 -&gt; 添加绑定 -&gt; 变量名称只能写img_url、KV命名空间选择上步添加的blog-assets2 -&gt; 保存； 给图床制作用户和密码：Workers和Pages -&gt; 概述 -&gt; 进入项目telegraph-image -&gt; 设置 -&gt; 环境变量 -&gt; 添加变量并保存:BASIC_USER,BASIC_PASS, 其值可完全自定义； 重新部署图床网站: 进入管理界面：Worker域名/admin登录即可，如 https://telegraph-image-1ei.pages.dev/admin 该方法的一些局限性： 上传图片之后，应至少通过URL访问图片一次，后台才能看到这张图片。 Cloudflare KV每天只有1000次的免费写入额度，100,000 次免费读取操作等。 无法对上传图片自定义名字。 其他图床服务： 可以搜索免费图床服务网站：这种网站可能容易失效，不保证稳定性。 去不图床： 博客大佬杜老师说自建的图床服务，￥30&#x2F;5G&#x2F;年。 腾讯云cos或轻量cos 阿里云oss 搭建域名邮箱 TODOhttps://hin.cool/posts/exmailgo.html","tags":["博客"],"categories":["博客"]},{"title":"手册：管理hexo-stellar博客","path":"/post/manual-manage-blog/","content":"归纳总结了Hexo+stellar的使用教程，作平时维护博客网站之用。另要常关注框架&#x2F;主题的迭代。 注意！！！ Tag Plugins说明 Hexos说，markdown语法不能包裹标签插件。但是我测试，是可以的。如：有色的链接 反过来，有的标签插件能包裹markdown语法，有的却不能正确渲染。如行内的标签插件：在生成绿字的标签插件中加[一个链接](http://assets.taddream.site)就无法生效。 应对方法：可考虑直接写入HTML代码，如：&lt;a href=&quot;http://example.com/&quot;&gt;一个链接&lt;/a&gt; 所有的标签插件的语法中: 用空格分隔多个参数（当需要真正的空格，请使用&amp;nbsp;代替）；用方括号表示可选参数；用冒号分隔键值对参数（无空格）。 本文的路径格式：除非特殊说明，以/开头的，就是/public/下的相对路径。其他开头的就是工作目录绝对路径。 注意：Hexo框架、stellar主题有新的迭代时，本文也要及时更新，方法见配主题。 更新历史 Hexo框架常用命令参考 写作 hexo new post &quot;title1&quot;: 会在/source/_posts下创建title1.md; hexo new page title2 -p dir1/dir2/filename: 会在/source/下创建title2.md; 基础配置 配置优先级：_config.yml的theme_config属性 -&gt; _config.[theme].yml -&gt; _config.yml。 文章里：front-matter配置这里的配置直接定义本页的装修风格，且能覆盖全局配置文件_config。这里只介绍部分参数： layout: post类型和自定义类型，存入source/_posts; page类型，存入source/。 comments：是否可用bool（TODO） categories: Hexo不支持多个同级分类，解决办法 文章里: 标签插件 标签插件（Tag Plugins）不应该被包裹在 Markdown 语法中。 引用块 blockquote&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 更简单的引用块，&gt; content 代码块 codeblock或code&#123;% codeblock [title] [lang:language] [url] [link text] [additional options:value] %&#125;code snippet&#123;% endcodeblock %&#125;其中，额外选项有：line_number:true ; line_threshold:0 ; highlight:true ; first_line:1 ; mark:1,4-7,10。 用in更优雅python小技巧1234num = 1if num in(1,3,5): type = &#x27;奇数&#x27;print(type) 更简单的代码块，用反引号：``` [language] [title] [url] [link text] code snippet ``` 自己的代码资源嵌入 include_code&#123;% include_code [title] [lang:language] [from:line] [to:line] path/to/file %&#125; 这里path/to/file的根目录是source/downloads/code。 tag-embed式代码、视频嵌入需要事先安装hexo-tag-embed插件：npm i hexo-tag-embed Gist的代码块嵌入：&#123;% gist gist_id [filename] %&#125; jsfiddle的前端代码块嵌入：&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125; vimeo视频嵌入：&#123;% vimeo video_id [width] [height] %&#125; YouTube视频嵌入：&#123;% youtube video_id [type] [cookie] %&#125; 避免渲染的块 rawcontent {% mark 在绿字中加一个[链接](http://assets.taddream.site/build_site_images/备选头像2.png) color:green %} 更好用的视频嵌入 iframe iframe标签，美观度一般：&#123;% iframe url [width] [height] %&#125; 直接上HTML代码：更复杂、更定制化的视频嵌入&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=566104739&amp;bvid=BV1Tv4y1r7ZG&amp;cid=985684333&amp;page=1&amp;autoplay=0&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; class=&quot;bilibili-video&quot; style=&quot;width:100%;min-height:315px&quot;&gt; &lt;/iframe&gt; 图片嵌入 img&#123;% img [class names] /path/to/image [width] [height] '\"title text\" \"alt text\"' %&#125; 我的评价：markdown格式更简洁：![](url)，或者stellar的更好。 链接嵌入 link&#123;% link text url [external] [title] %&#125; https://hexo.io/zh-cn/docs 标题https://taddream.site/hexo%E6%96%87%E6%A1%A3 我的评价：不如stellar的。 assets目录下的资源嵌入站内图片、文件的更定制化的、路径简单化的嵌入方式，但我就只用markdown。 引用自己post目录下的文章 post_link&#123;% post_path filename %&#125;，&#123;% post_link filename [title] [escape] %&#125;(title默认是filename；escape默认要转义，即true)如：debug手册 优点：在使用此标签时可以忽略文章文件所在的路径或者文章的永久链接信息、如语言、日期。我的评价：不如markdown语法方便，[标题](/post/文件名) 功能扩展 想自定义小功能：编写JS脚本，放进/scripts/下即可; 想探索更多功能：插件商店 stellar主题基础配置所有配置直接见/_config.yml和/_config.stellar.yml，里面有详细备注和解释。下面只挑一些来讲。 自定义小组件 主题内置了8个组件布局 实现组件2步骤: 【配置】：依托现有组件布局，在_data/widgets.yml中声明各种自定义的组件； 【使用】：在/_config.stellar.yml的sidebar.widgets中调用组件名；或文章的front matter的sidebar中覆盖组件名&#x2F;组件配置。 文章头：front-matter配置直接见scaffolds/post.md，里面有详细备注和解释。 文章里：标签插件表达类标签01-emoji已配置的库有：qq, twemoji, aru, tieba, blobcat(主题自带v1版), bbpng和bbgif(主题自带v2版) 语法和示例：&#123;% emoji [source] name [height:1.75em] %&#125;&#123;% emoji 爱你 %&#125;&#123;% emoji blobcat ablobcatrainbow %&#125;&#123;% emoji blobcat ablobcatrainbow height:4em %&#125;&#123;% emoji blobcat ablobcatattentionreverse %&#125;&#123;% emoji tieba 滑稽 %&#125; 效果： 02- mark 行内文本标记，仅12种 语法和示例：&#123;% mark 默认 %&#125; &#123;% mark 红 color:red %&#125; &#123;% mark 橙 color:orange %&#125; &#123;% mark 黄 color:yellow %&#125; &#123;% mark 绿 color:green %&#125; &#123;% mark 青 color:cyan %&#125; &#123;% mark 蓝 color:blue %&#125; &#123;% mark 紫 color:purple %&#125; &#123;% mark 浅 color:light %&#125; &#123;% mark 深 color:dark %&#125; &#123;% mark 警告 color:warning %&#125; &#123;% mark 错误 color:error %&#125; 效果：默认 红 橙 黄 绿 青 蓝 紫 浅 深 警告 错误 03- hashtag 标签类似mark标签，但其文本是自定义的，还可带链接 语法：&#123;% hashtag 文本 url %&#125; 效果：Stellar Hexo GitHub Gitea 04- image 图片标签 语法：&#123;% image src [description] [download:bool/string] [width:px] [padding:px] [bg:hex] %&#125;## 谨记，键值对间不要有空格src: 图片地址description: 图片描述download:href # 下载地址，设置此值后鼠标放在图片上会显示下载地址，如果下载地址为图片地址，可以设置为 truewidth:200px # 图片宽度padding:16px # 图片四周填充宽度bg:&#x27;#ffffff&#x27; # 图片区域背景颜色，16进制; 或用`white`等；或用动态配色`var(--card)` 效果：\\{% image https://source.unsplash.com/1280x640/?sea 来自unsplash的大海图集&nbsp;download:true %\\} \\{% image https://source.unsplash.com/320x640/?forest 来自unsplash 的森林图集&nbsp;padding:16px&nbsp;bg:var(--card) %\\} 05- quot 引用（标题式的） 跟Hexo中的quote不是一个东西。用于居中醒目表示。其中el参数可使其变为居中的标题；icon参数的值在/_config.yml的tag_plugins.quot中配置 语法：&#123;% quot 内容 [icon:default/hashtag] [el:h2] %&#125; 效果：Stellar 是最好用的主题 热门话题 06- poetry 诗词 语法：&#123;% poetry 游山西村 author:陆游 footer:诗词节选 %&#125;莫笑农家腊酒浑，丰年留客足鸡豚。**山重水复疑无路，柳暗花明又一村。**&#123;% endpoetry %&#125; 效果：游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。诗词节选 07- note 备注块 语法：&#123;% note [title] content [color:red/orange/yellow/green/cyan/blue/purple/light/dark/warning/error] %&#125; 如果标题中需要显示空格，请使用&amp;nbsp;代替 效果：这&nbsp;是标题这是正文 哈哈。 这是正文哈哈。 08- link 链接卡片 语法：&#123;% link href [title] [icon:src] [desc:true/false] %&#125; 效果:不带摘要的样式：https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ 带摘要的样式：https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ 09- mermaid 图表 学习研究 https://mermaid.js.org/intro/ 安装插件：npm install --save hexo-filter-mermaid-diagrams 示例：#```mermaidgraph LRA(Section A) --&gt;|option 1| B(Section A)B --&gt;|option 2| C(Section C)#``` 效果:graph LRA(Section A) --&gt;|option 1| B(Section A)B --&gt;|option 2| C(Section C) 10- copy 复制行 语法： 过时了：&#123;% copy [width:max/...] [git:ssh/gh/https] 内容 %&#125; v1.23.0：&#123;% copy [git:ssh/gh/https] 内容 [prefix:任意字符串] %&#125; 当有git参数时，内容只需输入域名+仓库名 效果：$ https 11- radio 单选框 语法：&#123;% radio [checked:true/false] [color:red/orange/yellow/green/cyan/blue/purple] 框后的文字 %&#125; 效果：没有勾选的单选框 已勾选的单选框 12- checkbox 复选 语法：&#123;% checkbox [symbol:plus/minus/times] [color:red/orange/yellow/green/cyan/blue/purple] [checked:true/false] 框后的文字 %&#125; 效果:怎么不是绿色文字 13- navbar 导航栏（文章内的） 语法：&#123;% navbar active:/path [按钮名]() ... %&#125; active 参数用于指定高亮 效果：文章项目留言GitHub 14- frame 设备框架（不咋懂，不常用） 语法：&#123;% frame iphone11 img:/assets/wiki/prohud/toast/demo-loading.png video:/assets/wiki/prohud/toast/demo-loading.mp4 focus:top %&#125; 效果： 15- 文本修饰标签集 &#123;% psw 密码 %&#125; : 这是 密码 标签 &#123;% u 下划线 %&#125; : 这是 下划线 标签 &#123;% emp 着重号 %&#125; : 这是 着重号 标签 &#123;% wavy 波浪线 %&#125; : 这是 波浪线 标签 &#123;% del 删除线 %&#125; : 这是 删除线 标签 &#123;% sup 上角标 color:red %&#125; : 这是 上角标 标签 &#123;% sub 下角标 %&#125; : 这是 下角标 标签 &#123;% kbd 键盘样式 %&#125; : 这是 键盘样式 标签，试一试：⌘ + D 16- 目标管理（Objectives and Key Results）形象展示一个目标下多个关键点的进度。 示例写法 O1 2024年的小目标：完成 Volantis 6.0 并发布上线 来自2025年的复盘：已《基本》实现目标 正常 44% KR1 重构 tag-plugins 和 wiki 系统 当 KR 进度为 100% 时，标签默认显示为 已完成当 KR 未设置进度时，默认为 0%当 O 未设置进度时，则显示所有 KR 进度平均值 已完成 100% KR2 完成主要页面设计稿 小提示1小提示2您可以在 _config.yml 文件中修改标签的颜色和文案您可以在 _config.yml 文件中增加任意的标签配置 延期 90% KR3 完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹） 在咸水和海滩之间找一亩地求出圆周率后15位找出宇宙的终极逻辑去地狱里走两步 未完成 -12% KR-4 开发、测试和发布 站点头像 风险 0% &#123;% okr o1 %&#125;2024年的小目标：完成 Volantis 6.0 并发布上线来自2025年的复盘：已《基本》实现目标 &#123;% emoji tieba 滑稽 %&#125;&lt;!-- okr kr1 percent:1 --&gt;重构 tag-plugins 和 wiki 系统- 当 &#123;% mark KR %&#125; 进度为 100% 时，标签默认显示为 &#123;% mark color:green 已完成 %&#125;- 当 &#123;% mark KR %&#125; 未设置进度时，默认为 &#123;% mark 0% %&#125;- 当 &#123;% mark O %&#125; 未设置进度时，则显示所有 &#123;% mark KR %&#125; 进度平均值&lt;!-- okr kr2 percent:0.9 status:off_track --&gt;完成主要页面设计稿&#123;% tabs align:left %&#125;&lt;!-- tab 小提示1 --&gt;您可以在 _config.yml 文件中修改标签的颜色和文案&lt;!-- tab 小提示2 --&gt;您可以在 _config.yml 文件中增加任意的标签配置&#123;% endtabs %&#125;&lt;!-- okr kr3 percent:-0.12 status:unfinished --&gt;完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹）&#123;% checkbox 在咸水和海滩之间找一亩地 %&#125;&#123;% checkbox 求出圆周率后15位 %&#125;&#123;% checkbox 找出宇宙的终极逻辑 %&#125;&#123;% checkbox 去地狱里走两步 %&#125;&lt;!-- okr kr-4 status:at_risk --&gt;开发、测试和发布&#123;% image /assets/wiki/stellar/icon.svg height:64px 支持嵌套插入图片等其它简单组件 %&#125;&#123;% endokr %&#125; 数据集合类标签（5个）timeline 时间线静态时间线 场景1– 制作教程&#x2F;日程 示例：&#123;% timeline %&#125;&lt;!-- node 第一步：打开 GitHub --&gt;打开 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar/) 的 GitHub 页面。&lt;!-- node 第二步：点击 Star --&gt;如果发现右上角的 Star 还没点亮，就点亮它！&#123;% endtimeline %&#125; 效果：第一步：打开 GitHub打开 Stellar 的 GitHub 页面。第二步：点击 Star如果发现右上角的 Star 还没点亮，就点亮它！ 动态时间线 场景2：显示某人GitHub Issues的动态说说 示例：&#123;% timeline api:https://api.github.com/repos/JamesRay0713/blog-comments/issues?direction=asc&amp;per_page=3 %&#125;&#123;% endtimeline %&#125; 效果： 场景3：显示友链朋友圈 TODO教程：https://xaoxuu.com/wiki/stellar/fcircle/。 2023&#x2F;11&#x2F;23尝试教程：后端、极简两个方法都失败&#123;% timeline type:fcircle api:https://raw.github.xaox.cc/xaoxuu/friends-rss-generator/output/data.json %&#125;&#123;% endtimeline %&#125; 场景4：爬取微博动态 TODO fork 爬虫仓库 ，修改自己的仓库名 修改 .github&#x2F;workflows&#x2F;main.yml 中的微博ID为你想爬取的ID，修改完后每天会自动爬取你的微博，存储为 json 文件，输出文件在 output 分支 &#123;% timeline limit:20 type:weibo api:你的json文件地址 %&#125;&#123;% endtimeline %&#125; 静态+动态 即在动态代码中间插入静态节点，示例：&#123;% timeline reversed:true api:https://api.github.com/repos/xaoxuu/blog-timeline/issues?per_page=2 %&#125;&lt;!-- node 这条内容为静态数据 --&gt;这条内容为静态数据，静态数据在 `deploy` 时就已经确定了。&#123;% endtimeline %&#125; 效果：这条内容为静态数据这条内容为静态数据，静态数据在 deploy 时就已经确定了。 对时间线内容做筛选 TODO筛选方式：可在标签代码中增加参数（如user:xaoxuu），也可在api的值中增加参数（如?labels&#x3D;todo&amp;per_page&#x3D;3）更多用法详见：https://docs.github.com/en/rest/issues/issues#list-issues-assigned-to-the-authenticated-user 示例：&#123;% folders %&#125;&lt;!-- folder 只显示某个人的数据 --&gt;&#123;% timeline user:xaoxuu api:https://api.github.com/repos/volantis-x/hexo-theme-volantis/issues %&#125;&#123;% endtimeline %&#125;&lt;!-- folder 筛选最近3条todo --&gt;&#123;% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?labels=todo&amp;per_page=3 %&#125;&#123;% endtimeline %&#125;&lt;!-- folder 筛选评论最多的3条建议 --&gt;&#123;% timeline api:https://api.github.com/repos/volantis-x/hexo-theme-volantis/issues?labels=feature-request&amp;per_page=3&amp;sort=comments %&#125;&#123;% endtimeline %&#125;&#123;% endfolders %&#125; 效果：只显示某个人的数据筛选最近3条todo筛选评论最多的3条建议 friends 友链 静态友链：先在source/_data/links.yml中添加友链信息, 后可以在任何位置插入友链组示例：&#123;% friends 开源大佬 %&#125;效果： 动态友链:（有空再学）&#123;% friends api:https://raw.github.xaox.cc/xaoxuu/friends/output/v2/data.json %&#125; sites 网站卡片 实现方法：先在source/_data/links/组名.yml中添加网站信息, 后可以在任何位置插入网站卡片示例：&#123;% sites 组名 %&#125;效果： ghcard 卡片 示例：&#123;% ghcard 用户名 %&#125;或&#123;% ghcard 用户名/仓库名 theme:dark %&#125; 效果： toc 文档目录树实现了把一个wiki文档的目录放到任何一个地方。相关配置：source/_data/widgets.yml中也有toc组件，这个组件可用于source/_config.stellar.yml中的sidebar，或用于文章的front matter。 语法：&#123;% toc wiki:xxx [open:true] [display:mobile] title %&#125; 效果：mangrove的目录模型训练与测试index建立一个公司 容器类标签（11个）box 普通块、代码块容器 语法：&#123;% box [title] [color:color] [child:codeblock/tabs] %&#125;内容&#123;% endbox %&#125; 效果1：child参数为空——和note功能类似 注：stellar的note标签插件，就是基于box的。 Stellar v1.12.0因为原 noteblock 标签在升级到 hexo 6.0 之后跟官方库冲突了 。。。 源码：&#123;% box Stellar v1.12.0 color:warning %&#125;因为原 noteblock 标签在升级到 hexo 6.0 之后跟官方库冲突了 。。。&#123;% endbox %&#125; 效果2：child参数为codeblock——和Hexo的code功能重复 注：优劣对比，box更美观；code配置参数更多。 /path/to/codefunc test() &#123; // ...&#125; 源码： &#123;% box /path/to/code child:codeblock color:green %&#125; \\`\\`\\`swift func test() &#123; // ... &#125; \\`\\`\\` &#123;% endbox %&#125; 效果3：child参数为tabs——里面就可以嵌套一个tabs标签插件 图文混排示例代码个人电脑作为办公设备时，我们该如何保护隐私？公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区进行加密。 folding 折叠容器 快速复制：&#123;% folding open:false color:green 标题 %&#125;content&#123;% endfolding %&#125; 语法：&#123;% folding title [child:codeblock/...] [open:bool] [color:red/orange/yellow/green/cyan/blue/purple/light/dark] %&#125;content&#123;% endfolding %&#125; v1.21.0中，child:codeblock/...改成了codeblock:true/false 效果1– 彩色可折叠代码块： 默认打开的代码折叠框func test() &#123; // ...&#125; 效果2– 嵌套折叠容器 警告1…警告2…警告3ok folders 多个折叠容器聚合 语法：&#123;% folders %&#125;&lt;!-- folder 题目1 --&gt;这是答案1&lt;!-- folder 题目2 --&gt;这是答案2&lt;!-- folder 题目3 --&gt;这是答案3&#123;% endfolders %&#125; 效果：题目1这是答案1题目2这是答案2题目3这是答案3 tabs 分栏容器 示例：&#123;% tabs active:2 align:center %&#125;&lt;!-- tab 图片 --&gt;&#123;% image http://assets.taddream.site/build_site_images/网站图标2.png width:300px %&#125;&lt;!-- tab 代码块 --&gt;#```swiftprint(&quot;hello world&quot;)#```&#123;% endtabs %&#125; 效果：图片代码块表格let x = 123print(&quot;hello world&quot;) grid 网格分区容器 语法：目前只支持显示一行两列，且手机端因宽度较窄会恢复为单列显示。&#123;% grid [bg:block/card] %&#125;&lt;!-- cell left --&gt;&lt;center&gt;左侧内容&lt;/center&gt;&lt;!-- cell right --&gt;&lt;center&gt;右侧内容&lt;/center&gt;&#123;% endgrid %&#125; 三种背景模式：默认无；普通型block；卡片型card。上面的&lt;center&gt;可以不要。 示例： Unsplash Photo The Galactic Center is the rotational center of the Milky Way galaxy. Its central massive object is a supermassive black hole of about 4 million solar masses, which is called Sagittarius A*. Ōwhiro Bay, Wellington, New ZealandPublished on May 31, 2022SONY, ILCE-6000Free to use under the Unsplash License gallery 图库容器图片引入格式只支持md语法。默认配置可前往theme-config的：tag_plugins.gallery。 &#123;% gallery %&#125;![@tianhao_wang](https://images.unsplash.com/photo-1688142202243-e218ad203952?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDYzfEZ6bzN6dU9ITjZ3fHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1700994630045-f7a20df6d92e?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwcm9maWxlLXBhZ2V8MjN8fHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1533274221104-015a584a1005?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDE4fGJvOGpRS1RhRTBZfHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1539604214100-ab860d9082e0?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDIxfGJvOGpRS1RhRTBZfHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1698843848092-588f9c1bb0bd?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwcm9maWxlLXBhZ2V8Mzh8fHxlbnwwfHx8fHw%3D)![@vklemen](https://images.unsplash.com/photo-1516571748831-5d81767b788d?q=80&amp;w=2574&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)&#123;% endgallery %&#125; @tianhao_wang@eberhard@eberhard@eberhard@eberhard@vklemen albums 专辑容器用于陈列音乐专辑。是gallery的超集，支持点击跳转。使用方法： 准备数据：在blog/source/_data/links/&lt;组名&gt;.yml中构建要陈列的表格，格式如下：- title: Hans Zimmer url: https://www.douban.com/personage/27260154/ avatar: https://xaoxuu.com/assets/avatar/hans-zimmer-profile.jpg # 键名用icon也行- ... 使用标签：&#123;% albums [组名] [repo:owner/repo] [api:http] [size:s/m/l/xl/mix] %&#125;，参数含义作者暂未告知。效果：Hans ZimmerTwo Steps From HellAlan WalkerCapo Productions warning：2024&#x2F;01&#x2F;09 我要按住CTRL才能点击进入图像的链接，但原主题并不需要。 posters 海报容器用于陈列电影、音乐、游戏等海报。是gallery的超集，支持点击跳转。使用方法： 准备数据：在blog/source/_data/links/&lt;组名&gt;.yml中构建要陈列的表格，格式如下：- title: Minecraft Dungeons url: https://store.steampowered.com/app/1672970/Minecraft_Dungeons/ avatar: https://xaoxuu.com/assets/bookmark/games/minecraft-dungeons.jpg # 键名用icon也行- ... 使用标签：&#123;% posters [组名] [repo:owner/repo] [api:http] [size:s/m/l/xl/mix] %&#125;，参数含义作者暂未告知。效果：Minecraft DungeonsTwo Steps From HellAlan WalkerCapo Productions banner 横幅容器将取代about容器。 用法1：独立页面的横幅，内部可以套一个导航栏。 &#123;% banner 标题 bg:背景图片路径 %&#125;&#123;% navbar active:/wiki/ [文章](/post/) [项目](/wiki/) %&#125;&#123;% endbanner %&#125; 文章项目随记 用法2：个人资料页的横幅，可以加一个头像 &#123;% banner 某某 这是个人简介 avatar:/path.png bg:/path.jpg %&#125;&#123;% endbanner %&#125; James Raythis is my private page. 用法3：对link链接卡片的美化 &#123;% banner 标题 摘要。 bg:路径或url link:路径或url %&#125;&#123;% endbanner %&#125; 博客进阶：自动化部署本文讲了如何利用脚本和 GitHub Actions 简化博客搭建和部署流程，提高效率。 about 关于块容器略，将废弃 swiper 轮播容器 语法：(这里url有两种形式：md或tag-plugin)&#123;% swiper [effect:cards/coverflow] [width:min/max] %&#125;\\!\\[\\](url)&#123;% image url width:300px %&#125;...&#123;% endswiper %&#125; 效果: 文章尾：评论区插件stellar作者提供了多种插件，我这里只介绍giscus，它是由 GitHub Discussions 驱动的评论系统。 主题配置文件中的配置方法：_config.stellar.ymlcomments: service: giscus # 教程见`https://zhuanlan.zhihu.com/p/603658639`：总结就是进入https://giscus.app/zh-CN 进行各种配置，最后得到一个&lt;script&gt;元素，其内部的各种属性就用来填充在下面。 giscus: src: https://giscus.app/client.js # 当使用自建的 giscus 服务后，这里要相应更改。具体使用方法，等有需要再学 TODO data-repo: xxx/xxx # [在此输入仓库] data-repo-id: # [在此输入仓库 ID] data-category: # [在此输入分类名] data-category-id: data-mapping: pathname # 按文章的路径映射评论区。还可以是其他方式，如number data-strict: 0 data-reactions-enabled: 1 data-emit-metadata: 0 data-input-position: top # top, bottom data-theme: preferred_color_scheme data-lang: zh-CN data-loading: lazy crossorigin: anonymous 也可以在front matter中设定评论区（优先级最高），如：source/_posts/title.mdtitle: xxxgiscus: data-repo: JamesRay0713/blog-comments data-mapping: number data-term: 226 # 一个数字映射一个评论区，不同文章下设定相同数字，则它们共享一个评论区。 wiki文档专题顺利上架一个完整的wiki项目需要几步？我们先看一个项目需要的文件结构。 目录树source/ # ├── _data/│ ├── wiki/ # step1: 该目录下，一个项目配置一个文件│ │ ├── `proj1-ID.yml`│ │ └── proj2-ID.yml│ ├── `wiki.yml` # step3: 陈列其中的项目ID表示上架了│ └── other.yml├── wiki/ # 项目目录│ ├── proj1/ # step2: 写项目│ │ ├── `index.md`│ │ ├── page1.md│ │ └── pageN.md│ ├── proj2/│ └── projN/ ├── assets/ # 存放项目中链接的一些资源└── ... step1: 构建配置文件配置模板：/_data/wiki/proj1-ID.yml# 该文件用于配置一个具体的wiki项目。# 当前的文件名，一定就是项目ID，这两者必须相同。项目ID要陈列于`/_data/wiki.yml`中才能使项目出现在`/wiki/`的列表中，不陈列则隐身。# 项目ID、下面的name、/wiki/下的项目文件夹名，这三者不必相同。# 2023/12/24测试：logo，path，它们的有无对配置完全不起作用！为什么########## 必有的 ###########name: 笔记本 # 项目页面左上角的大标题、正上方的路径尾巴subtitle: &quot;每天一点，进步一点 | up up up~&quot; # 项目页面左上角的副标题title: Ray的笔记本 # 大封面和wiki列表页的标题tags: [知识库] # tags的类别形成了/wiki/index.html中的顶端导航栏。当你只想要一个隐身的项目时，tag也就没必要写了path: /wiki/my-notes/ # 给这个配置文件指定项目文件夹########## 封面/列表页 ###########icon: http://assets.taddream.site/build_site_images/wiki-note-cover.jpg # 列表页图标 cover: http://assets.taddream.site/build_site_images/wiki-note-cover.jpg # 封面页大图，不能如作者所言的用true，而是具体图片，coverpage: [cover, title, description] # 设置了才能开启封面页，且能指定组件logo: # v1.21.0, 似乎派不上用场 src: http://assets.taddream.site/build_site_images/wiki-note-cover.jpg small: 108px # 针对列表页图标 large: 180px # 针对封面页大图description: 一个啥都张罗的技术笔记本，它即将是隐身的，只能手动在域名后添加`/wiki/my-notes/`访问########## 顶部 ############repo: # 右上角会显示ghrepo组件########## 左侧 ###########sidebar: - search: override: search filter: /wiki/my-notes/ # 限定搜索范围 placeholder: search in my-notes ... - toc - related - recenttoc: # 承担wiki下，子页面的分组、排序任务。 # 注：①子页面的文件名==下面列出的题目；②子页面的front matter中的title==toc中出现的子标题。 # 而①不必等于② # 子页面的front matter中的title一定不能为空（如果又想让页面标题为空，可设置`h1: &#x27;&#x27;`），否则该页面将隐身于toc。 &#x27;日常问题解决&#x27;: # 组别也可取消；也可置空字符串。 - index # 必须有一个index，对应项目的index页面。 - 常用代码小工具 - debug集合 &#x27;前端&#x27;: - study-front-end &#x27;后端&#x27;: - 其他########## 底部 ###########comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/JamesRay/上面的repo/issues) 反馈。&#x27;comments: service: giscus giscus: data-repo: JamesRay0713/blog-comments # 仓库的issue模块，映射到本项目的评论区 data-mapping: number # 也可换成title、pathname等 data-term: 1 # 一个数字映射一个评论区，不同文章下设定相同数字，则它们共享一个评论区。这种方式在一个wiki中配置特别方便。# 如果想关闭评论区，这里写false没效果，得去具体页面的front matter写`comments: false`license: false # bool/str, 默认不显示许可协议share: false # bool/list, 默认不显示底部分 step2: 写项目警告：一旦有/wiki/proj1/，则必须有_data/wiki/proj1-ID.yml配套；其他情况随意。 项目中至少有一个index.md，其他文件自行添加。每个文件的front matter至少包含下面前3个属性： /wiki/proj1/index.md\\---layout: wiki # 使用wiki布局模板wiki: proj1-ID # 这是项目id，对应 /_data/wiki/proj1-ID.ymltitle: 这是分页标题 # 不设置标题时，则该页面对项目不可见seo_title: 新标题 # 覆盖title\\--- step3: 上架项目在/_data/wiki.yml中增加当前项目ID，如下： - proj1-ID- proj2-ID 如果step1-step2准备了多套wiki项目，但不想展示在/wiki/index.html中, 这里只要不写相应项目ID即可。 进阶专题一站多作者配置支持多个作者在一个站点发布文章。步骤如下： I. 配置作者信息：在source/_data/authors.yml# 作者 1 （默认）JamesRay: # 这是author ID name: &#x27;Ray~&#x27; # 这是作者名 url: https://taddream.site # 没有也可以 avatar: http://assets.taddream.site/my-best-avatar.png banner: http://assets.taddream.site/build_site_images/social_page_banner.jpg description: know yourself...# 作者 2author2: name: xxx ... II. 非默认下在文章的front matter中指定作者：---author: JamesRay # 注意：这里是author的ID，而不是具体呈现到文章顶部的`作者名`。--- 第三方插件专题「katex」插件或 mathjax插件用于渲染LaTeX公式。先在md文件的front matter中插入katex: true或mathjax: true;后书写latex代码，如：$$\\sum_&#123;i=0&#125;^n i^2 = \\frac&#123;(n^2+n)(2n+1)&#125;&#123;6&#125;$$,效果为：$$\\sum_{i&#x3D;0}^n i^2 &#x3D; \\frac{(n^2+n)(2n+1)}{6}$$ 遇到到一些缺陷&#x2F;BUGstellar-v1.21.0 一些无效的属性、组件 wiki文档配置中（如source\\_data\\wiki\\my-notes.yml）的logo属性 对主题的DIYTODO 创建快捷按钮：快速到顶、快速到底 DONE对article-footer的修改 目的：合并license和share部分，简化文章的footer模块 效果对比：stellar-v1.23.0：2024&#x2F;01&#x2F;11修改后： 代码变动：变动前见；变动后见。 注意事项：由于share模块整合了license模块，因此_config.stellar.yml中article.license将置空。所有文章的front matter中也将不再使用license属性。 footer.social可自定义显示与否 使用方法：在文章的front_matter中新增了footer_social属性，可手动设定其值为true/false。 代码变动：仅在文件中增加了一点点代码，&amp;&amp; page.footer_social !== false 注意事项：默认下，footer_social这个组件为true, 但不会出现在wiki布局下的文章中。 在page布局下也能有article-footer 代码变动：仅在文件中的el += &#39;&lt;/article&gt;&#39;;前添加一行，el += partial(&#39;_partial/main/article/article_footer&#39;)。 使用效果：此后page布局下的文章的front matter中share（默认false）, reference等属性都能有效显示。 page布局下自定义面包屑显示与否 使用方法：默认下是要显示的，当某篇page布局的文章不想要，只需在其front matter中添加breadcrumb: false即可。 代码变动：仅在文件中的if ((page.h1 || page.title || (page.content &amp;&amp; page.content.length &gt; 0))中添加一个条件 &amp;&amp; page.breadcrumb !== false)。 注意事项：post布局下强制显示面包屑。 经验之谈 一个页面的sidebar配置了toc，但正文部分没有任何二级及以下标题，则toc会自动替换成recent，没有办法改变。 暂时解决办法：当不想出现recent，且正文部分实在没办法有标题（如加密页面）时，那就别在sidebar里添加toc组件。","tags":["博客","hexo"],"categories":["博客"]},{"title":"常用代码/命令手册","path":"/post/manual-useful-command/","content":"使用频率较高的命令和代码片段收录于此，随手翻阅。wiki-my-notes中有相应的更详细的笔记内容。 Linux查看与查找 系统、内核相关的信息 cat /etc/os-release ，sudo lsb_release -a uname --all env export 查看硬件 逻辑cpu核数：cat /proc/cpuinfo | grep &quot;processor&quot; |wc -l 物理cpu核数：cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq|wc -l 显卡实时数据：(每0.2s刷新) $ 文件查找 whereis pkg sudo find / -name &quot;*.txt&quot; $ 有约束的全局查找:除了 /sys/(-xdev)和子目录/mnt/外。 文件、存储相关 查看存储大小： 当前系统磁盘的： 所处目录的： 文件的常用操作： 切割文件： split -b 1G -d --additional-suffix=.txt target_file 压缩文件： tar -zcvf file.tar.gz file 解压缩文件： tar -zxvf file.tar.gz 实时将终端内容存入日志文件： 执行touch ~/&quot;session_$(date +&#39;%Y%m%d_%H%M%S&#39;).log&quot;后，将进入日志记录模式，此后终端中所有内容（包括[终端控制字符]）都会记录到日志文件中。 执行exit可退出日志记录模式。 执行less -r ~/....log可查看正确渲染出终端控制字符的日志文件。 用户、权限等 切换用户switch user：sudo su [username] 以user1身份执行命令：sudo -u user1 command .sh脚本的执行:bash test.sh：启动一个新的Bash子shell来执行test.sh中的命令。它与你当前终端的shell是隔离的。sudo bash test.sh：子shell的操作者是用户root，不是当前shell的用户。否则添加- E参数。source test.sh或. test.sh：直接在当前shell执行。 用户免密使用sudo：打开sudoers文件: sudo vim /etc/sudoers；在类似%sudo ALL=(ALL:ALL) ALL的行下添加一行：yourUserName ALL=(ALL:ALL) NOPASSWD: ALL；保存并退出。 所有用户信息：cat /etc/passwd 关于进线程、缓存 实时进程：top; htop 查看所有进程：ps aux ；ps [-ef] 进程在前台后台切换：fg [pid]；bg [pid] 杀死进程：kill -9 [pid], killall -9 [pname] 清除系统缓存(1可换成2,3)：sudo sh -c &quot;echo 1 &gt; /proc/sys/vm/drop_caches&quot; 进程的后台前台： 把占用命令行的进程改到后台挂起：ctrl+ Z 查看后台进程列表：jobs 把后台挂起的程序，在后台运行起来：bg 把后台运行的程序调用至前台：fg 直接后台执行命令：command &amp;， nohup command， nohup command &amp;， nohup command &gt; /dev/null 2&gt;&amp;1 &amp; 系统服务 开&#x2F;关&#x2F;重启&#x2F;查看一个服务：sudo systemctl start/stop/restart/status 软件名 功能同上（service是一个比较旧的服务管理命令）：sudo service docker stop 将服务设为开机自启：sudo systemctl enable my-service 自定义服务: 创建一个新的服务单元文件，比如 /etc/systemd/system/my-service.service。 编辑该文件，指定服务的配置，例如：[Unit]Description=My Custom ServiceAfter=network.target[Service]ExecStart=/path/to/your/commandRestart=always[Install]WantedBy=multi-user.target 远程连接、端口、IP相关 生成密钥对： 看端口占用：netstat -ltunp IP查找 windows内：用ipconfig 注意： 列表中第一个IP值是本机IP；其他的比如vEthernet和vEthernet(WSL)下的IP是本机构建相应虚拟内网时的网关IP。 linux内： 查看完整信息：执行ifconfig，或ip a 获取具体IP值： 自身ip值：是ifconfig命令的输出中的 ‘eth0’ 的IP，或执行hostname -I | awk &#39;&#123;print $1&#125;&#39; 注：若该Linux是服务器，则IP可能是动态的；若它是WSL2或容器，则IP一定是动态的。 宿主ip值：可在宿主机执行ifconfig&#x2F;ipconfig, 其输出中的‘vthernet(WSL)’下的IP就是了；或在本机执行cat /etc/resolv.conf | grep nameserver | awk &#39;&#123; print $2 &#125;&#39; 注：只有WSL或容器才有宿主。注：wsl下的容器： 其宿主IP是Windows的‘ethernet(WSL)’下的IP，千万千万不是wsl的哦。 其网关IP却在wsl中。 文件传输 本地目录传到远端：scp -r /local/dir user@remote_ip:/remote/dir 网络连接相关 解析域名：nslookup taddream.site或ping 软件包相关多用sudo apt, 少用apt-get 搜索一个包：apt-cache search cudnn pythonvscode调试如何配置自定义调试：在工作目录的.vscode/launch.json的&quot;configurations&quot;列表中，新起一个调试配方。重点属性如下： &quot;configurations&quot;: [ &#123; &quot;justMyCode&quot;: true, //改成false, 调试时可跳转到第三方库中 &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, //可自定义工作目录 &quot;args&quot;: [ //用于python命令带参数的情况 &quot;-c&quot;, &quot;configs/yolov5/yolov5_s.yml&quot;, &quot;--infer_img&quot;, &quot;demo/mangrove_demo.tif&quot;, &quot;--output_dir&quot;, &quot;infer_output/&quot; ], &quot;env&quot;: &#123; // 在这里设置环境变量 &quot;CUDA_VISIBLE_DEVICES&quot;: &quot;0&quot; &#125;, &#125;] 包管理-conda创建环境：conda create -n test1 [–clone base] | [python&#x3D;3.7] [other pkgs], 常用：$ -conda激活&#x2F;灭活环境：conda activate test1，conda deactivate-列出所有环境：conda env list -删除指定环境：conda remove -n *** --all-导出&#x2F;导入环境：conda env export &gt; environment.yaml，conda env create -f environment.yaml-从文件安装：conda install --yes --file requirements.txt，pip install -r requirments.txt-安装时临时指定源：conda install -c conda-forge -c bioconda package_name，pip install package_name -i https://pypi.org/simple/、-i https://pypi.tuna.tsinghua.edu.cn/simple/、-i https://mirrors.aliyun.com/pypi/simple/ git链接：我的详细教程总结 Markdown 使用表情包: 去表情包网站里找对应表情包，然后复制。 前端相关npm相关 指定源安装软件包： HTML语言 锚点的使用 放锚：你想要的位置写入&lt;a name=&quot;自定义&quot;&gt;&lt;/a&gt; 用锚：链接形如 http://localhost:4000/post/network/#自定义 折叠一段文字&lt;details open&gt; &lt;summary&gt;章节标题&lt;/summary&gt; &lt;p&gt;这是章节的内容。&lt;/p&gt;&lt;/details&gt; 不加open是默认折叠状态。 docker 常用命令 最常用create详解run详解commit详解docker pull ubuntu:latest # 下载docker run -itd --name test ubuntu:latest /bin/bash # 运行docker exec -it test /bin/bash # 进入docker stop test # 停止docker commit containerID imgName1:tag1 # 生成镜像,即把你想要的容器状态持久化 # 推送镜像docker logindocker tag imgName1:tag1 jamesray0713/imgName1:tag1docker push jamesray0713/imgName1:tag1# 其他docker images # 列出所有镜像docker ps -a # 列出所有容器docker run 镜像id #新建容器并启动docker exec -it 容器ID /bin/bash #前提：容器已经启动。进入容器docker rm -f $(docker ps -aq) #删除所有的容器ctrl +P +Q #容器不停止退出docker inspect 容器ID # 查看某容器环境变量、详细配置docker create \\ -it \\ # 交互式和终端 --name my_container \\ # 容器名称 -p 8080:80 \\ # 端口映射 --volume /host/path:/container/path \\ # 挂载数据卷 --env MY_VARIABLE=value \\ # 设置环境变量 --network my_network \\ # 连接到指定网络 --hostname my_host \\ # 设置容器主机名 --restart always \\ # 容器退出时总是重启 --memory 512m \\ # 内存限制 --cpus 0.5 \\ # CPU 限制 --detach \\ # 后台运行 my_image:tag # 使用的镜像及标签docker run \\ -itd \\ # 交互式运行, --detach后台运行 #--rm \\ # 容器停止后自动删除 --name my_container \\ # 指定容器名称 -p 8080:80 \\ # 将主机端口映射到容器端口80 -v /host/path:/container/path \\ # 挂载主机目录到容器, 同功能：--mount type=bind,source=host_path,target=container_path --network my_network \\ # 连接容器到指定网络 --env MY_VARIABLE=value \\ # 设置环境变量 --label my_label=my_value \\ # 添加标签 --cpu-shares 512 \\ # CPU 分配权重 --memory 512m \\ # 内存限制 --cpus 0.5 \\ # 使用的 CPU 核心数 #--restart always \\ # 容器退出时自动重启 --privileged \\ # 赋予容器所有权限 --gpus all \\ my_image:tag \\ # 使用的镜像及标签 command_to_run_in_container # 容器中要执行的命令, 一般是 /bin/bashdocker commit \\ --author &quot;Your Name&quot; \\ --change &quot;ENV DEBUG=true&quot; \\ # 设置环境变量 DEBUG 为 true --change &quot;WORKDIR /app&quot; \\ # 设置工作目录为 /app --change &quot;USER newuser&quot; \\ # 设置用户为 newuser --change &quot;CMD [\\&quot;python\\&quot;, \\&quot;app.py\\&quot;]&quot; \\ # 设置容器启动时执行的命令 --change &quot;EXPOSE 8080&quot; \\ # 暴露容器端口 --change &quot;LABEL version=1.0&quot; \\ # 添加标签 --platform linux/amd64 \\ --quiet \\ # 静默模式，只输出新镜像的 ID CONTAINER_ID \\ NEW_IMAGE_NAME:TAG # 新镜像的名称和标签 命令大全docker attach #连接到正在运行中的容器docker build #使用 Dockerfile 创建镜像docker builder #管理builds docker builder prune #清除build缓存docker checkpoint #管理checkpoints docker checkpoint create #从正在运行的容器创建检查点 docker checkpoint ls #列出容器的检查点 docker checkpoint rm #删除指定的检查点docker commit #从容器创建一个新的镜像docker config #管理Docker配置 docker config create #创建配置文件 docker config inspect #查看配置文件信息 docker config ls #显示docker里已经保存得配置文件 docker config rm #删除配置文件docker container #管理容器 docker container prune #删除所有已停止的容器docker context #管理contexts docker context create #创建一个上下文 docker context export #将上下文导出到tar或kubecconfig文件中 docker context import #从tar或zip文件导入上下文 docker context inspect #在一个或多个上下文上显示详细信息 docker context ls #列出上下文 docker context rm #删除一个或多个上下文 docker context update #更新 docker context use #设置当前docker的上下文docker cp #用于容器与主机之间的数据拷贝docker create #创建一个新的容器但不启动它docker diff #检查容器里文件结构的更改docker events #从服务器获取实时事件docker exec #在运行的容器中执行命令docker export #将文件系统作为一个tar归档文件导出到STDOUTdocker history #查看指定镜像的创建历史docker image #管理镜像 docker image inspect #显示一个或多个镜像的元数据 docker image ls #列出本地镜像 docker image prune #删除没有使用的镜像 docker image rm #删除一个或多个镜像docker images #列出本地镜像docker import #从归档文件中创建镜像docker info #显示 Docker 系统信息，包括镜像和容器数docker inspect #获取容器/镜像的元数据docker kill #杀掉一个运行中的容器docker load #导入使用 docker save 命令导出的镜像docker login #登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hubdocker logout #登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hubdocker logs #获取容器的日志docker manifest #管理manifest(实验，不应用于生产环境) docker manifest annotate #向本地镜像清单添加附加信息 docker manifest create #创建用于注释和推入注册表的本地清单列表 docker manifest inspect #显示镜像清单或清单列表 docker manifest push #将清单列表推入仓库 docker manifest rm #从本地存储中删除一个或多个清单列表docker network #管理网络 docker network connect #将容器连接到网络 docker network create #创建一个网络 docker network disconnect #断开容器的网络 docker network inspect #显示一个或多个网络的元数据 docker network ls #列出网络 docker network prune #删除所有没有使用的网络 docker network rm #删除一个或多个网络docker node #管理集群(swarm)节点 docker node demote #从群集(swarm)管理器中降级一个或多个节点 docker node inspect #显示一个或多个节点的元数据 docker node ls #列出群集(swarm)中的节点 docker node promote #将一个或多个节点推入到群集管理器中 docker node ps #列出在一个或多个节点上运行的任务，默认为当前节点 docker node rm #从群集(swarm)删除一个或多个节点 docker node update #更新一个节点docker pause #暂停容器中所有的进程docker plugin #管理插件 docker plugin create #从rootfs和配置创建一个插件。插件数据目录必须包含config.json和rootfs目录。 docker plugin disable #禁用插件 docker plugin enable #启用插件 docker plugin inspect #显示一个或多个插件的元数据 docker plugin install #安装一个插件 docker plugin ls #列出所有插件 docker plugin push #将插件推送到注册表 docker plugin rm #删除一个或多个插件 docker plugin set #更改插件的设置 docker plugin upgrade #升级现有插件docker port #列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口docker ps #列出容器docker pull #从镜像仓库中拉取或者更新指定镜像docker push #将本地的镜像上传到镜像仓库,要先登陆到镜像仓库docker rename #重命名容器docker restart #重启容器docker rm #删除一个或多个容器docker rmi #删除一个或多个镜像docker run #创建一个新的容器并运行一个命令docker save #将指定镜像保存成 tar 归档文件docker search #从Docker Hub查找镜像docker secret #管理Docker secrets docker secret create #从文件或STDIN创建一个秘密作为内容 docker secret inspect #显示有关一个或多个秘密的详细信息 docker secret ls #列出秘密 docker secret rm #删除一个或多个秘密docker service #管理服务 docker service create #创建一个服务 docker service inspect #查看服务的元数据 docker service logs #获取服务的日志 docker service ls #列出服务 docker service ps #列出一个或多个服务的任务 docker service rm #删除一个或多个服务 docker service rollback #将更改恢复到服务的配置 docker service scale #缩放一个或多个复制服务 docker service update #更新服务docker stack #管理堆栈 docker stack deploy #部署新的堆栈或更新现有堆栈 docker stack ls #列出现有堆栈 docker stack ps #列出堆栈中的任务 docker stack rm #删除堆栈 docker stack services #列出堆栈中的服务docker start #启动一个或多个已经被停止的容器docker stats #显示容器的实时流资源使用统计信息docker stop #停止一个运行中的容器docker swarm #管理集群(Swarm) docker swarm ca #查看或旋转当前群集CA证书。此命令必须针对管理器节点 docker swarm init #初始化一个群集(Swarm) docker swarm join #加入群集作为节点和/或管理器 docker swarm join-token #管理加入令牌 docker swarm leave #离开群集(Swarm) docker swarm unlock #解锁群集(Swarm) docker swarm unlock-key #管理解锁钥匙 docker swarm update #更新群集(Swarm)docker system #管理Docker docker system df #显示docker磁盘使用情况 docker system events #从服务器获取实时事件 docker system info #显示系统范围的信息 docker system prune #删除未使用的数据docker tag #标记本地镜像，将其归入某一仓库docker top #查看容器中运行的进程信息，支持 ps 命令参数docker trust #管理Docker镜像的信任 docker trust inspect #返回有关key和签名的低级信息 docker trust key #管理登入Docker镜像的keys docker trust key generate\t#生成并加载签名密钥对 docker trust key load #加载私钥文件以进行签名 docker trust revoke #删除对镜像的认证 docker trust sign #镜像签名 docker trust signer #管理可以登录Docker镜像的实体 docker trust signer add #新增一个签名者 docker trust signer remove\t#删除一个签名者docker unpause #恢复容器中所有的进程docker update #更新一个或多个容器的配置docker version #显示 Docker 版本信息docker volume #管理volumes docker volume create #创建一个卷 docker volume inspect #显示一个或多个卷的元数据 docker volume ls #列出卷 docker volume prune #删除所有未使用的卷 docker volume rm #删除一个或多个卷docker wait #阻塞运行直到容器停止，然后打印出它的退出代码 WindowsAPI找图unsplash 一张完全随机的图片：https://source.unsplash.com/random/600x100 用关键字搜索并指定尺寸：https://source.unsplash.com/2000x400/?关键词,关键词 对目标图片处理：https://images.unsplash.com/photo-1470770841072-f978cf4d019e?q=80&amp;w=2670&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3相关参数w：图像的宽度。h：图像的高度。fit：调整图像的方式，可能的值包括 crop（裁剪）和 clip（裁剪并填充）。q：图像的质量。通常是一个介于 0 和 100 之间的数字。fm：图像的格式，可能的值包括 jpg、webp 等。auto：自动选择最佳格式，通常与 fm 一起使用。crop：裁剪图像的区域。ixid：似乎是用于图像处理的某种标识符。blur：用于指定图像的模糊度，例如 blur&#x3D;10.dpr：设备像素比，用于指定图像的分辨率，例如 dpr&#x3D;2 表示两倍的设备像素比。ar：宽高比，用于指定图像的宽高比，例如 ar&#x3D;16:9 用自己的账户进行搜索：https://api.unsplash.com/search/photos?client_id=yd_6UU9qZdBPRkZLvgXuVy_dNLneyzxbl4SOWv-gK1c&amp;page=1&amp;query=关键词","tags":["Linux","python","Deep Learning"],"categories":["toolkit"]},{"title":"网络连接相关","path":"/post/toolkit02-about-network-connection/","content":"汇总不同场景下主机之间的远程连接方法、代理服务等；探索更全能快捷的远程开发方式。 ①前两节主要讲解了如何用ssh实现两主机的互访；②第三节讲了如何通过代理访问外网资源；③第四节介绍了当我们只专注与远程生产场景下的，更高效便捷的访问方式——code CLI。非特殊说明, 下述客户端指代主访主机, 服务端指代被访主机。 0. 基础知识代理 正向代理（Forward Proxy）：隐藏客户端IP和身份客户端（通常是用户）通过正向代理服务器来访问其他服务器的资源。用途：通常用于增加访问控制和隐私，绕过访问限制，或提供匿名访问。 反向代理（Reverse Proxy）：隐藏服务器IP和身份反向代理服务器接收客户端请求，并将请求转发给内部服务器（后端服务器）。用途：用于负载均衡、安全性、缓存，以及隐藏后端服务器的实际结构。 1. 远程连接：服务、客户两端可直连访问1.1 服务端确保安装openssh-server 检验: ssh -V win10安装: 控制面板→ 程序→ 启关windows功能→ 下载ssh服务器 Linux安装: sudo apt-get install openssh-server sudo service sshd start/status # 查看状态: wsl和Linux sudo systemctl status/restart sshd # 查看状态: Linux 可选：按需配置服务端/etc/ssh/sshd_config（改后需重启sshd） Port 2222 # 如wsl1中要修改，不与win冲突; 而wsl2可不必修改, 因为它已是一台独立主机 PermitRootLogin yes # 可以root远程登录PasswordAuthentication yes # 密码验证登录GSSAPIAuthentication yes # 解决一台服务器管理多个ssh服务UseDNS no # 加快响应速度因为在内网环境下ListenAddress 192.168.25.130 # 只监听指定内网的IPMatch User anoncvs # 当前环境允许登录的用户GatewayPorts yesAllowTcpForwarding yes...... 1.2 免密码登录——配密钥 核心：公钥在服务端，私钥在客户端 密钥对生成方法: ssh-keygen -t rsa -C &#39;hl1670704310@icloud.com&#39; -f ~/.ssh/someName-rsa 情况1: 用新密钥对 建议在客户端本地生成，方法见上 公钥发给服务端: 自动: ssh-copy-id -i ~/.ssh/name_rsa.pub -p 22 user@remote_host 手动: 复制~/.ssh/someName-rsa.pub的内容到服务端主机的~/.ssh/authorized_keys 情况2: 用旧密钥对 客户端: 把私钥存放于~/.ssh/id_rsa, 用于ssh -i参数; 修改其权限chmod 600 rsa_path 服务端: 公钥内容复制到~/.ssh/authorized_keys 1.3 登录服务端主机 完整命令，无密直连: ssh -p 22 user@remote_host 最简指令（推荐）: ssh test 前提须在客户端配置~/.ssh/config Host test HostName serverIP User serverUSER Port 22 ServerAliveInterval 60 IdentityFile ~/.ssh/id_rsa 1.4 常见问题排查 连接出问题，先尝试删除客户端~/.ssh/know_hosts 2. 远程连接服务、客户两端不可直连访问场景: 两主机位于不同内网, 且都可访问互联网, 假设这里公司某主机为服务端(确保安装有sshserver), 家中笔记本为客户端 2.1 当拥有一个公网IP时(e.g.云服)🚩2.1.1 方法1: 远程端口转发&#x2F;内网穿透核心: 先让远程主机连到跳板机, 把ssh端口暴露给跳板机指定的端口, 再让本地主机连到跳板机的指定端口, 实现穿透。 准备两对密钥: KEY-sj: 用于服务端(pri)→ 跳板机(pub)的连接, reach_jumper_rsa KEY-cs: 用于客户端(pri)→ 服务端(pub)的连接, reach_luge_server_rsa 跳板机: 检查服务端配置(戳, 注: 在远程主机眼里跳板机是服务端) 防火墙设置: 在入站策略中开启任一闲置端口(如18086)并重启系统。用以映射到服务端的ssh端口, 让客户端以为连到该端口, 就等于连到了服务端的ssh服务。 sshd配置: 在/etc/ssh/sshd_config中至少保证GatewayPorts yes和AllowTcpForwarding yes; 可选ForwardAgent yes 密钥配置: 把KEY-sj的公钥内容添加到~/.ssh/authorized_keys文件，没有文件则创建 服务端主机&#x2F;远程主机: 检查服务端配置(戳) 先处理密钥: 将KEY-sj的私钥文件复制到~/.ssh/, 改权限为600； 将KEY-cs的公钥内容添加到~/.ssh/authorized_keys文件, 没有文件则创建； 后配置与跳板机的ssh连接, 在~/.ssh/config中输入: Host jumper HostName 跳板机IP Port 跳板机ssh端口 User 跳板机用户名 ServerAliveInterval 60 IdentityFile ~/.ssh/刚才KEY-sj的私钥 后执行远程转发命令 ssh -gfnNTR 18086:localhost:22 jumper 解释: g开启网关转发, f放入后台, n不接受输入, N不开交互式shell, T禁用伪终端, R代表这是远程的转发规则。 该命令将本机(服务端)的22端口映射到了跳板机的18086端口, 使得外界访问本机的ssh服务变为可能。 该命令长期在服务端后台执行, 可通过ps aux | grep &#39;ssh -gfnNTR 18086:localhost:22 jumper&#39;命令查看其进程 客户端主机:ssh 服务端用户名@跳板机IP -p 18086 -i KEY-cs的私钥若有问题，添加-v参数可以打印详细日志；或者删掉~/.ssh/known_host*相关文件试试看。 上述命令也可改到~/.ssh/config中。 2.2 当无公网IP时2.2.1 可视化内网穿透软件使用场景: 服务端有桌面系统, 如工位上的windows, 软件需安装于服务端 花生壳:直接添加一个端口映射项目即可, 可最终得到命令形如ssh -p 21570 james@44621m7c15.yicp.fun;优点: 足够简单; 缺点: 花生壳定义到wsl的映射时, 需面临宿主机每次开关机都会重启虚拟网络适配器导致wsl的内网IP改变的情况, 不够方便。 ZeroTier：功能：创建一个虚拟局域网，实现多台机器的互访。 2.2.2 命令行穿透工具使用场景: 如工位上的wsl, 公司内网的某台服务器 多种工具, 这些工具不仅限于tcp协议 bore优缺点: 简单, bore.pub带宽超低。 公网主机(可选):\t将该主机作为bore服务器, 相当于跳板机: bore server 服务端: 在想要暴露端口的主机上下载二进制可执行文件 暴露本地端口: bore local 22 --to bore.pub 如果设置了公网主机, 命令改为 bore local 22 --to 公网主机IP 你会得到一个新端口newP 客户端: 访问暴露的端口: ssh -p newP 服务端用户名@bore.pub 其他 2.3 当服务端IP不固定时 场景：本地想访问工位的wsl 难点：Windows是通过虚拟交换机给Win10主机与WSL2子系统分别分配IP地址，当Windows重启并再次打开WSL2时，虚拟交换机会被重新创建，分配给它们的IP地址也会随着改变。 常规思路：每次重启后都用wsl2的新IP来更新ssh命令 讨巧思路：直接访问win端系统，在进入cmd时系统自动跳转到bash.exe(就像Linux中在.bashrc末尾加上zsh一样) 方法：执行跳转命令 New-ItemProperty -Path &quot;HKLM:\\SOFTWARE\\OpenSSH&quot; -Name DefaultShell -Value &quot;C:\\WINDOWS\\System32\\bash.exe&quot; -PropertyType String -Force 然后再通过(#2.1，或#2.2)的方法访问工位的Windows 3. 破qiang访问互联网3.1 只想访问特定的外部网站场景：我国内的服务器需要从github下载文件, 为此只想实现访问github域名的能力 下述方法综述法1~法4我多次尝试，有的有时有效，有的完全无效；只要自己有梯子，法5一定能行；法6属于是曲线救国了，保底方案。 color&#x3D;green 法1：修改本地hosts文件 更新：查到的IP地址国内也不一定能访问，此法无效。 原理：我国通过一些技术手段实现了DNS污染，返回错误的GitHub的ip地址。因此我们只需更改&#x2F;增添hosts中的域名IP映射即可 获取正确映射：进入网站 查询（如 github.com -&gt; 20.205.243.166） 在Windows： 修改C:\\Windows\\System32\\drivers\\etc\\hosts权限， 后进入添加映射（如 20.205.243.166 github.com）， 刷新本地DNS缓存：ipconfig /flushdns 在Linux： 只需在/etc/hosts添加映射即可 若未生效，sudo systemctl restart nscd，如报错则须安装：sudo apt install nscd 或 sudo /etc/init.d/nscd restart 法2：修改DNS 原理：不同的DNS服务商可能有不同的解析方法 在Linux：sudo vim /etc/resolv.conf添加&#x2F;修改nameserver ，指定你想要使用的DNS服务器的IP地址，后执行sudo systemctl restart systemd-resolved生效 如：nameserver 114.114.114.114 nameserver 223.5.5.5 法3：借助github520项目原理仍是修改hosts 法4：针对github网站可用ssh密钥对 在主访主机准备密钥对，见这里 公钥复制到github: “Settings” -&gt; “SSH and GPG keys” -&gt; “New SSH key” 两种处理方式，但都是ssh连接：方式1方式2 验证可以连接：ssh -v -T git@github.com, 会返回successful 此时可以下载仓库：git clone git@github.com:your-username/your-repository.git 在~/.ssh/config添加远程主机信息如下：Host github User hl1670704310@icloud.com Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa port 443 验证可以连接：ssh -T git@github.com 法5：配置代理假设我们已经通过一些渠道得到了一个梯子，且正运行在本地，那请移步系统的设置→ 网络→ 代理→ 手动设置代理获取代理地址和端口（e.g. 127.0.0.1:7890）然后在终端给git配置代理服务器：git config --global http.proxy http://127.0.0.1:7890可验证查看配置成功：git config --global --list 法6：借助gitee以上方法均无效时，老实把目标仓库导入到gitee，然后使用gitee仓库链接。 3.2 丝滑访问所有外网3.2.1 VPN软件 小火箭 v2ray clash for windows for linux 3.2.2 代理商 BSTE: 目前最便宜，￥85&#x2F;年，100G&#x2F;月 3.2.3 自造代理服务器 永久免费HeroKu部署：实践TODO 4. VScode强大的远程开发工具—— Remote Tunnels中文；microsoft文档 工具原理本质是vscode客户端与服务端的通信。在服务端已经安装好code cli且运行了通道命令的前提下，我们可直接用URL连接远端，如server&#x2F;VM&#x2F;container&#x2F;WSL等（远端需能访问互联网）。该工具有助于高效便捷地开发，但有个缺点是必须事先想办法登录远端手动开启通道命令。 使用场景 当用于生产的服务器在公司内网，无法直接访问怎么办？ 当你把工位电脑装上向日葵，延迟和隐私问题该咋办？ 当公司服务器管理严格，你买了公网IP，用ssh搞端口转发，搭建的通道被网管掐了又怎么办？ 当在服务器里docker容器搞生产，层层端口、IP设置令人头大，又该如何应对？（当然SSH/tunnel到宿主机+ Dev Container插件也比较简单） vscode服务端解君愁。 如何使用 远程服务端： 下载独立包装的code CLI压缩包后解压，认准系统和架构，如下图： 也可命令方式： curl -Lk &#x27;https://code.visualstudio.com/sha/download?build=stable&amp;os=cli-alpine-x64&#x27; --output vscode_cli.tar.gztar -xf vscode_cli.tar.gz 上面的下载连接只针对Linux-Alpine x64系统及架构（不过其他版本如focal好像也能用），若是其他系统架构，请参考。 按如下图步骤进行：①用命令创建隧道：./code tunnel，将得到绑定到此远程计算机的 vscode.dev URL。若是首次创建，②需按提示选择登录账户（建议Microsoft）、③进入devicelogin的url，登录账户，输入它给你的验证码、④给这台远程机器命名。⑤获得vscode dev的URL 确保通道持久运行，戳 本地客户端： 方法1：在本地网页上开发。直接打开 URL即可进入网页版vscode desktop 若是首次打开URL，会提示登录GitHub&#x2F;Microsoft账户来授权你能正确地访问隧道。（国内没有梯子的用户建议使用Microsoft账户） 方法2：用本地VScode Desktop开发。先安装插件Remote SSH，Remote Tunnels；后进入左侧面板的Remote，点击Tunnels右侧的+，选择账户，系统会自动刷出你账户下的远程机器名，连接即可。","tags":["ssh","port forwarding"],"categories":["toolkit"]},{"title":"操作系统配置相关","path":"/post/toolkit01_about_OS_config/","content":"该手册可用于对新到手的系统进行快速配置。 基于不同的系统环境，会有不同的配置方法，下面列举了4种场景 Windows安装系统 制作启动盘(可选) 启动Dabaicai.exe(下载) 我的存放于E:\\app_tools\\a00.关于装系统、分区、EFI启动项设置等\\重装系统\\DaBaiCai\\Dabaicai.exe 根据‘使用教程’逐步制作。 制作好的镜像在J:\\windows_iso_library目录下，按需选择一个. 已有启动盘，做好一切C盘重要数据备份后，重启。 重启界面迅速按F12，进入BIOS界面 选择含USB Device类似字符，进入winPE操作系统模式。 可进行选择性分区等操作。最后一键还原进行重装系统。 注：某些iso跟大白菜不太兼容，一键还原后，开机重启长久卡在logo界面。别慌，重进PE系统，解压该iso，按照里面的说明再次重装（即此时大白菜只给了我PE界面，重装的活儿是其他工具搞定的） 配置系统 安装驱动：百度获取厂商驱动程序，安装，重启生效，不然蓝牙、音响等都会有问题。 我的驱动程序存在E:\\app_tools\\a00.关于装系统、分区、EFI启动项设置等\\装机驱动等\\雷神官网驱动下载，按README.md操作。 解放C盘：修改文件夹左边快速访问栏的‘下载、文档、图片’的属性→位置，移动到其他盘(如G:\\doc) office的部署安装 原因：大部分软件都在非C盘中，但office默认在C，因此需特别地将其重新安装 下载: xoffice部署工具并解压 我的存放于H:\\02.办公工具\\2.office\\Office Tool\\Office Tool Plus 部署：阅读’新手教程’安装详细了解，或如下操作： 部署→’安装文件管理’模块→选择文件→选.\\Office Tool\\Office\\Data中任一.cab文件（实现离线部署） 依次设置’产品、应用程序、语言、部署设置(64位，当前通道，安装)’模块→开始部署。 激活：E:\\app_tools\\暴风激活工具V17.0.zip 配置生产环境如果在windows中有一些写代码的小需求，可安装git。为了获得非阉割版的git，建议一步到位，安装Git for Windows SDK工具包。 git-sdk是一个仿Linux的集成开发环境，可以省去单独安装git git-bash g++ make python(多版本) perl ruby sqlite msys clang mingW32 mingW64 pacman等工具的烦恼安装教程 WSL2安装系统 环境准备 确保虚拟化选项开启：一般默认开启，不然需要进电脑的BIOS设置里开启 打开设置：控制面板-&gt;程序-&gt;启用或关闭windows功能-&gt;开启（Windows虚拟机监控程序平台、适用于Linux的Windows子系统、Hyper-V）三个功能。 将虚拟化平台的启动类型设置为自动： bcdedit /set hypervisorlaunchtype auto 重启. 安装 可命令行安装：wsl --install -d Ubuntu 可Microsoft store安装 其他相关命令(管理员权限开终端) wsl --update # 升级内核wsl --listwsl -l --shutdown # 重启内核，首次安装需要重启wsl -l -v # wsl状态、版本 配置系统 （可选）迁离C盘，在其他盘中形成ext4.vhdx文件： wsl --export Ubuntu-20.04 K:\\Ubuntu_subSystem\\ubuntu2004.tar # 导出到压缩包wsl --unregister Ubuntu-20.04wsl --import Ubuntu-20.04 K:\\Ubuntu_subSystem\\ubuntu2004_fs K:\\Ubuntu_subSystem\\ubuntu2004.tar --version 2 # 导入到其他盘ubuntu2004 config --default-user hlei0 # 把Linux的之前的用户名添加上 注：也可手动进行’import’操作：Add-AppxPackage .\\Ubuntu_2004.2020.424.0_x64.appx 使能支持systemctl &#123;cat &lt;&lt;EOT[boot]systemd=trueEOT&#125; | sudo tee /etc/wsl.conf​exit 后在cmd重启：wsl --shutdown, wsl 然后直接跳转linux整个流程完成配置。 debug 当宿主机又重装了，wsl其实可正常使用 原理：microsoft store的ubuntu软件，和wsl2的文件系统是分开的。没有软件，文件系统照常运行。因为迁移了fileSystem后，即使ubuntu软件被卸载，但ext4.vhdx存在，便可用wsl命令在重装后的cmd中继续访问子系统。 当.vhdx损坏，可用wsl --import命令解压出新的.vhdx继续使用wsl。 docker😓 在win安装Docker Desktop 不建议，因为吃内存和cpu；可选择在wsl中安装dockerwin端docker的角色类似wsl 安装教程 验证：docker --version，wsl -l -v 配置国内源：进设置→ docker Engine→ 框中添加： &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot; ] 迁离C盘： 关闭docker, 后执行 wsl --shutdown # 关机Linuxwsl --export docker-desktop-data K:\\Ubuntu_subSystem\\docker_library\\docker-desktop-data.tar # 导出压缩包wsl --export docker-desktop K:\\Ubuntu_subSystem\\docker_library\\docker-desktop.tar # 导出wsl --unregister docker-desktop-data # 注销wsl --unregister docker-desktop # 注销wsl --import docker-desktop-data K:\\Ubuntu_subSystem\\docker_library\\data\\ K:\\Ubuntu_subSystem\\docker_library\\data\\docker-desktop-data.tar --version 2 # 导入wsl --import docker-desktop K:\\Ubuntu_subSystem\\docker_library\\distro\\ K:\\Ubuntu_subSystem\\docker_library\\distro\\docker-desktop.tar --version 2 # 导入 😀 在Linux端安装Docker Engine 教程速览: 安装 # （可选）卸载旧版本sudo apt-get remove docker docker-engine docker.io containerd runc # 安装依赖sudo apt-get updatesudo apt-get install ca-certificates curl gnupg# 添加官方的gpgkeysudo mkdir -m 0755 -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg# 设置软件库codename=$(grep VERSION_CODENAME /etc/os-release | cut -d&#x27;=&#x27; -f2)echo \\&quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\&quot;$(. /etc/os-release &amp;&amp; echo &quot;$codename&quot;)&quot; stable&quot; | \\sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt-get update# 安装docker引擎sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin# 启动sudo service docker start# 验证sudo docker run hello-world 配置镜像源 获取镜像加速器地址：登录阿里云-&gt;控制台-&gt;搜索容器镜像服务-&gt;’镜像加速器’ 添加镜像 sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;&quot;registry-mirrors&quot;: [&quot;https://你自己的.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 启动 普通Linux中：sudo systemctl start docker(还有restart, status…)；后docker启动 wsl2中：sudo service docker start debug 碰到Temporary failure resolving ‘gb.archive.ubuntu.com’问题： 可以永久性地在你的系统中添加一个DNS服务器：echo &quot;nameserver 8.8.8.8&quot; | sudo tee /etc/resolvconf/resolv.conf.d/base &gt; /dev/null 😀 在wsl2安装Docker Engine和Linux端一模一样。 ⭐⭐⭐一个很难受的BUG: wsl2中的docker的Ubuntu，其内核依然是WSL2，不是纯粹的Ubuntu。 原因：wsl2是Ubuntu，但不是完整的Ubuntu；那么和wsl2共用内核的docker容器，自然是跟wsl2啦。 wsl2的局限性：不能使用Linux原生的systemctl来管理服务。 局限性的解决办法： 对于wsl2，戳 对于wsl2里的docker容器，设置docker run的参数来模拟原生环境: --privileged: 赋予容器特权，这对于模拟Systemd环境是必要的。--tmpfs /run --tmpfs /run/lock: 将 &#x2F;run 和 &#x2F;run&#x2F;lock 设置为tmpfs文件系统，以便Systemd单元正常工作-v /sys/fs/cgroup:/sys/fs/cgroup:ro: 将主机的 &#x2F;sys&#x2F;fs&#x2F;cgroup 挂载到容器中，以便容器内的Systemd能够访问它。 Linux🚩 自动配置脚本：点击下载该脚本可对一个Ubuntu新系统进行一键配置，脚本有以下模块（如果只想手动配置部分模块请跳转下一节）： 必定安装的①②③⑦模块： ①配置国内源：加速apt的软件包的下载速度。 ②安装基础软件包：“wget” “curl” “git” “vim” “net-tools” “iputils-ping” “htop” “tmux”“zsh” “kmod” “g++” “gcc” “cmake” “psmisc” “language-pack-en” “tree” ③安装oh-my-zsh：比Linux默认的bash更便捷高效的命令行工具。 ⑦安装vscode CLI：vscode的无桌面版客户端，用于远程生产。 选择性安装的：若带--in-container参数，则脚本提前结束；若不带，则安装④⑤⑥模块 ④安装Miniconda； ⑤安装docker； ⑥安装NVIDIA Container Toolkit。 注：脚本不包含安装CUDA+ cuDNN部分, 需手动。 脚本使用方法： 下载脚本：复制所有内容； 编写脚本：cd ~ &amp;&amp; tee ~/config_script.sh；粘贴ctrl+ V；退出文件ctrl+ C 执行脚本：bash ~/config_script.sh [--in-container] 注意：根据实际需求，完全可以自选任意模块的组合，进行一键配置。 注意：将执行较长时间，结束后注意排查日志看有无报错。 注意：除了开始阶段可能需要手动设置时区外，其他命令均自动完成。 时区设置如下，需按提示依次填写6, 70: 刷新配置：source ~/.bashrc 1. 手动配置：配置国内源sudo mv /etc/apt/sources.list /etc/apt/sources.list_backupsudo vim /etc/apt/sources.list 在vim中写入： 阿里源#deb-src http://mirrors.aliyun.com/ubuntu/ $codename main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ $codename main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ $codename-security main restricted universe multiverse#deb-src http://mirrors.aliyun.com/ubuntu/ $codename-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ $codename-updates main restricted universe multiverse#deb-src http://mirrors.aliyun.com/ubuntu/ $codename-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ $codename-backports main restricted universe multiverse#deb-src http://mirrors.aliyun.com/ubuntu/ $codename-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ $codename-proposed main restricted universe multiverse#deb-src http://mirrors.aliyun.com/ubuntu/ $codename-proposed main restricted universe multiverse 或 清华源# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse# deb-src http://security.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse 注意，$codename需更换为适合本机的codename，查看方式： sudo lsb_release -a sudo apt-get updatesudo apt-get upgrade 2.手动配置： 配置基础工具终端美化：ohmyzsh 若不想安装zsh, 最简单的bash美化：在~/.bashrc中添加：export PS1=&quot;\\033[1;35m&gt; \\T, \\u, \\w\\[\\033[0m\\] \\$ &quot;，可将命令行头变成： `> 08:29:56, root, ~ $ ` 安装zsh sudo apt-get install zsh -yvim ~/.bashrc # 进入后添加：if [ -t 1 ]; then exec zsh; fi。然后重启终端echo $SHELL # 检验zsh为当前shell 下载安装ohmyzsh 官方库及教程, 鉴于国内环境，将纯手动安装： 将官方库导入到gitee.com 下载安装脚本：wget -O- https://gitee.com/mirrors/ohmyzsh/raw/master/tools/install.sh &gt; ~/install.sh 进入脚本搜索ohmyzsh/ohmyzsh改为jamesray0713/ohmyzsh，搜索github改为gitee 安装：sh ~/install.sh 配置ohmyzsh 换主题：sudo vim ~/.zshrc，修改为 ZSH_THEME=&quot;robbyrussell&quot; 加插件： cd .oh-my-zsh/custom/plugins git clone https://gitee.com/jamesray0713/zsh-autosuggestions # 自动填充git clone https://gitee.com/jamesray0713/zsh-syntax-highlighting # 高亮vim ~/.zshrc 后将plugins=( git )改为plugins=( git zsh-autosuggestions zsh-syntax-highlighting ) 改抬头： 进入~/.oh-my-zsh/themes/robbyrussell.zsh-theme， 修改第二行为：PROMPT+=&#39; %&#123;$fg[cyan]%&#125;[$PWD]%&#123;$reset_color%&#125; $(git_prompt_info)&#39; 重启终端 包管理：miniconda用python做项目前，一定要做好版本管理，防止版本冲突、包冲突问题。为此python有自带的venv，而更流行的是conda，这里只介绍python的换源、conda的安装及换源。 若不安装conda，则只需pip更换国内源: 进入~/.pip/pip.conf文件（没有则创建），写入以下内容： [global]index-url = https://pypi.org/simple/ # 官方源#index-url = https://pypi.tuna.tsinghua.edu.cn/simple # 清华源#index-url = https://mirrors.aliyun.com/pypi/simple/ # 阿里源 国内源存在包的版本不全的情况，有时候也要换回国外官方源，如：pip install -r requirements.txt -i https://pypi.org/simple/ miniconda:先下载、安装: mkdir ~/packagescd packageswget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.shbash Miniconda3-latest-Linux-x86_64.sh -b -p ~/Miniconda3 # 用zsh可能有未知的错误，b是静默安装vim ~/.condarc 后更换国内源: channels: - defaultsshow_channel_urls: truedefault_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/rcustom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 检验：进入当前shell的配置文件（如~/.zshrc）末尾查看是否有被&gt;&gt;&gt; conda initialize &gt;&gt;&gt;字样包含的内容，没有的话从~/.bashrc里复制过来（其中的shell.bash改为shell.zsh。 为深度学习做系统配置为了让你的代码能在新系统的GPU中跑起来，这里提供一站式解决方案，即把CUDA和cuDNN准备妥当即可。鉴于目前我常用的场景，这里只介绍Nvidia显卡在win、Ubuntu、wsl下的应用。资料： 所有已归档的CUDA版本的资源&amp;文档； Nvidia文档中心 -&gt; CUDA文档-latest ； cuDNN文档。 1. 安装显卡驱动一般来说系统已经配置好了，若需要重装驱动，可去主板厂商官网、或NVIDIA官网下载；若需升级驱动，进入GeForce Experience软件查看并更新。安装成功后，可通过命令验证：nvidia-smi，其中能获得驱动版本号、显卡最大支持的CUDA版本号等。 2.1 在Windows平台搞DL 装CUDA流程总结： 选择CUDA版本：不高于显卡最大支持版本，且要契合项目要求 下载exe(local)，执行安装 选自定义安装: 第一次安装，尽量全选(除了CUDA-&gt;visual studio); 第n次安装，尽量只选择CUDA，不然会出现错误。 安装目录尽量默认，因为后期开发中很多报错来源于路径问题。 控制面板-&gt;程序将得到一堆CUDA软件 添加到系统环境变量：有4个，可能后两个未自动生成，需参考下图手动配，NVCUDASAMPLES_ROOT; NVCUDASAMPLES11_0_ROOT 验证：nvcc -V 装cuDNN流程总结 注册&#x2F;登录账号，下载匹配CUDA的版本 解压得到3个文件夹，直接全盘拷贝到cuda的安装目录下 cuDNN 其实是 CUDA 的一个补丁，专为深度学习运算进行优化的。 以下4个路径添加到系统环境变量的path： ....\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\bin....\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include....\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\lib....\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\libnvvp 验证：执行将得到显卡详细配置参数 cd 安装目录\\extras\\demo_suite.\\bandwidthTest.exe.\\deviceQuery.exe 2.2 在wsl2平台搞DL wsl2直接调用宿主机的显卡驱动，无需安装。由于wsl2可看作Ubuntu，具体操作直接参考【2.4 在Linux中搞DL】。 2.3 在容器中搞DL(最常用)这里只介绍Linux下的docker容器。由于对docker for windows不爽，就不介绍了。 宿主机中：装NVIDIA Container Toolkit, 该工具能使docker容器具有调用宿主机GPU的能力。 安装方法# 建立package repository 和 GPG keydistribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\ &amp;&amp; curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \\ &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/experimental/$distribution/libnvidia-container.list | \\ sed &#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27; | \\ sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.listsudo apt-get update# 安装sudo apt-get install -y nvidia-container-toolkit# 设置Docker daemon 守护进程识别Nvidia容器Runtimesudo nvidia-ctk runtime configure --runtime=docker##重启dockersudo systemctl restart docker# 测试docker run --rm -it --gpus=all nvcr.io/nvidia/k8s/cuda-sample:nbody nbody -gpu -benchmark 容器中：可直接pull带CUDA、cuDNN的镜像；也可参照【2.4 在Linux中搞DL】手动配置CUDA和cuDNN。 2.4 在Linux平台搞DL 安装cuda：在链接中指定操作系统、架构、发行版本(wsl或Ubuntu)、安装包类型(尽量选则&#39;deb(local)&#39;)，即可得到相应安装命令脚本。不同CUDA版本间的脚本会有各种各样的差异，无法类推，只能现用现搜。下面是一个列子： Linux-x86_64-WSL-Ubuntu-2.0-deb(local)wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pinsudo mv cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600wget https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda-repo-wsl-ubuntu-11-8-local_11.8.0-1_amd64.debsudo dpkg -i cuda-repo-wsl-ubuntu-11-8-local_11.8.0-1_amd64.debsudo cp /var/cuda-repo-wsl-ubuntu-11-8-local/cuda-*-keyring.gpg /usr/share/keyrings/sudo apt-get updatesudo apt-get -y install cuda 后续动作——添加环境变量：在~/.zshrc末尾添加export PATH=/usr/local/cuda-11.8/bin$&#123;PATH:+:$&#123;PATH&#125;&#125; 其他可选后续动作安装用户空间的守护进程：sudo /usr/bin/nvidia-persistenced --verbose, TODO: 报错，缺少libnvidia-cfg.so.1文件验证：验证驱动：cat /proc/driver/nvidia/version（wsl2中无效）; 验证编译器：nvcc -V；编译&amp;运行测试：获取示例目录（放到当前目录下）：cuda-install-samples-11.2.sh .编译deviceQuery: 进入NVIDIA_CUDA-11.2_Samples/1_Utilities/deviceQuery/，执行make，直接得到二进制文件运行deviceQuery：执行./deviceQuery，得到结果。 安装cuDNN先下载合适的版本；然后： cd /path/of/deb# 安装debsudo dpkg -i cudnn-local-repo-ubuntu2004-8.9.6.50_1.0-1_amd64.deb# 拷贝CUDA GPG keysudo cp /var/cudnn-local-repo-*/cudnn-local-*-keyring.gpg /usr/share/keyrings/# 刷新, 查看支持的软件包(一般为3个：运行时库、开发库、样例库)sudo apt-get updateapt-cache search cudnn# 正式开始安装cudnn的3个库 # 报错：libcudnn8只有8.9.6.50-1+cuda11.8的版本，那此时就照它的意思来，就用cuda11.8好了，后面不会因为我预装的CUDA11.2而报错。sudo apt-get install libcudnn8=8.9.6.50-1+cuda11.2sudo apt-get install libcudnn8-devsudo apt-get install libcudnn8-samples# 验证能正常使用cudnncp -r /usr/src/cudnn_samples_v8/ $HOME &amp;&amp; cd $HOME/cudnn_samples_v8/mnistCUDNN &amp;&amp; make clean &amp;&amp; make # 最后得到`./mnistCUDNN`可执行文件，运行得到`Test passed!`即成功。","tags":["Linux","OS","Windows","docker"],"categories":["toolkit"]},{"path":"/explore/index.html","content":"文章站点项目大佬友链探索空间 本站印象笔记传送门 重要TODO… 有空TODO博客网站持续搭建维护 优雅写博客——GitHub Codespaces(TODO)如果你经常需要在一些临时电脑上写写稿子、预览效果，不能立即发布且需要多端同步，或许这是个不错的选择，详见这篇文章： https://xaoxuu.com/blog/20221121/https://xaoxuu.com/blog/20221121/ 博客站友链&#x2F;引流方法： 加入虫洞项目 加入开往项目 做一个电子书的wiki 2023 视频文章推荐为什么有些人看起来不努力，却进步飞快？【正确打开 2023】 有的人忙着翻身，有的人急着认命 一小时读完《Vue.js 设计与实现》 要钱不要命"},{"path":"/oasis/index.html","content":"function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } U2FsdGVkX19JNjKonCe4WB1vug5Zfllh1GdoX4ceVTsDKthamGhRUpXkwIajSW3SJSxzi1/f0GZIufGqdUqcd6gkAoQVVuIuT6rPUxs7i/b+xAu3ByF2EyieJ/kkw7+mD8Sap2fWzHWr4Ara2o0VM9N/CSeyyImrsssTM7Z5fa7yyOUN1yFyUEDg2lj2n2bOQQxavOXXfi0RZl2mgNaYBw3G4WTshIqRi/CMwPggPah+4g9dmQiKYHiY/daJQGmGPlTp5vlMZXFjF0el/p9tQmCRg20hd9UOgDVGJ677u9g3SQr/M3yEI6u9CCieOHY+REDT/5+GNKiFB9muUx+rsUopqNDh+hnMKXOYH0Z9iASmi14bCFFWd9+ePvT3mioCBnRSjH0ib+1K1Dz9yLHl/z621FYsoRgzVFqku3GIGhauvhkvPghFYRTQJk3hxoSQ2v8T+4I5dp0IFprcF+SRuUeRqUlKltaFfT7hYdf/7JjzbdFvUcQyDuoOOcJN6GGqDYRh299vpgoNb2fTDLfDPQAvQLpSbIbQ6r4sciVfNnJgTW3S07AnkVnr1iFDz3DeQYgk+Ub/bfQVqLqp4kUfwnuIWOADI6pT6F2AwugnlkxuDNzZL2TO2qlXAkQz5VQYF1JEkDxMNWDQBvnU4daeYgDdg8VyG8ukAq9fRFfK36wfWSoEGOIxG/bUPAWxncvORvl/d7JpayS5ipbnJwVBFb0mMkmGSOH2SQQ87NNxiWIAWqJp/F/Cri1L0ovC5/FCF68wd4x8E6RS3+H2oHByvv3KB/a00mOlWAEUaYNCRZDBDkNrRXClS68RGMQMupsDaYlniY07dueKK04guvCOFgj6o4ZXU+RzFUeZLilRNRQ4L97dEq2rnLZGZXQwAyGMGgSvXCX/2zuNKqnyv1jyAPz1F16DjK6q5ugx0e3hqZLU8nRLl1QVB2CtwkimJwti5Qf9YcAjVbtfso3NIHhDIQ+HdZun+ZnkdBFNPrQz0gxIjQKmPNgByUcqmQvgUbdpvbQuBdNbsnCyPqLLFMZsgt3ehWk97CAy+r0deEY6SrWx6/Okam4v8204xgeT+FwgE6SeJ9NOcTp2dZ/FLMXC0N10FF+XhrjG3FeDoWa9sH32sm1+Aru/AZ3nZbZ278io83mTALcbiFFNq9wdmXfvXovBS64AebSwA403EOVtzUUNfYQZ0NahEn6GvlKIEqgwkILhZOjvJ2FIv+I1oaOFlN63ZVFqLn6v8lPgDly5gggjRQB3+/stM9olBPPv2LwPDLfCCuUKTWe0e+WbZqKh5wDen3QfgIXsgdIHYU74MHCfm0xefG8A7+0OxZ8+nnbNPgvdHoKJ7IQ5yBbi7QRrCwf0MnXhUHqEwPIbabKZaIkypz5HJgVOBJ6x8X5fTPyjRCdYMf0VFihlyLn0O8UecWtiZkRXCUE9RgIRgLZYdGHgycEu7QMbEMj4r514J8y8C3KWU4jk7Kk9ZofCfBPgfqwcgwBgZj1RsF7cZG0P/lzFCbPR3HiVC93SI6/FeFXrPh6ZKUz4ksMlRjZ3M8cl7ORrdFxlIvW5P4vZ/83MlfBEU+vwaVrIuLM4wIxw7ydxkRpjW5mYoCp8K2rbvzIas6A2P9rpTQMNVfDVulhZZO3J8+KRin6g8qisMsz2eJjDXMBRr4mHshVEMXg6hgJKSGp5DoWAehRkAB3b/yzVnDnzQs6ZaOaAZIiL4wH6VKB2cuOZ8XvviSR9ALMGhfZUGkYA5mGZKNfdbc4VbMOfS66NKiLT820Pg3RxFE/401NfQXWYiZRsUHKEAOB7kgQIJXL3QywJxK4gOZlIk9HhTgNtSTTsuZ2DtwrTAw5moFvHxK+RSoD1zJrHYb+Vh+tN6C3OZU+VK1ZyqQlrLQ3S2JKD2hBg1E9OjgFrM1Ol87toEZ9mPSE4omVTfyrX61hsByOMj51fb/h8hqIS+SbJ+ArDS1XPhnNPENW2J4IANGMkStdQJ6twYYv8gqIbYSlDjo8mYMNEcBYCo/XglYWbUxw= var onError = function(error) { document.getElementById(\"enc_error\").innerHTML = \"password error!\" }; function decrypt() { var passwd = document.getElementById(\"enc_pwd_input\").value; console.log(passwd); doDecrypt(passwd, onError); }"},{"path":"/social/index.html","content":"留言虫洞个人空间 人生 .. 参与项目 fastFET python data-science"},{"path":"/explore/awesome/index.html","content":"文章站点项目大佬友链主页集合 开源大佬尹寒磊技术和生活的记录空间Justin Yanghttps://lifestyle1.cn/执着_7748https://www.jianshu.com/...Woooodi目前共计 58 篇日志。枋柚梓喵喵喵？MHuiGBe Yourself, Make a Difference.Colsrch愿多年以后，我可以酌一杯清酒，烂醉如泥，梦中回到我们的曾经。ChrAlpha 的幻想乡不硬核瞎折腾小冰博客http://zfe.space/ 最近动态TODO"},{"path":"/explore/friends/index.html","content":"文章站点项目大佬友链友链 海内存知己 天涯若比邻 朋友圈动态 TODO，找时间学习 https://xaoxuu.com/wiki/stellar/third-party/fcircle.html 您可加入我的友链 通过提交我的仓库的issue加好友。具体操作如下： 第一步：新建 Issue在GitHub Issue中点击new issue, 按照模板格式填写并提交。为了提高图片加载速度，建议优化头像：打开 压缩图 上传自己的头像，将图片尺寸调整到 96px 后下载。将压缩后的图片上传到 去不图床 并使用此图片链接作为头像。第二步：添加友链并等待管理员审核您还可添加本站到您的友链中。title:友链title: JamesRayavatar: &#x27;&#x27;url: https://taddream.sitescreenshot: &#x27;&#x27;待管理员审核通过，添加了 active 标签后，回来刷新即可生效。如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客更新。如果无法修改，可以重新创建一个。"},{"path":"/explore/sites/index.html","content":"文章站点项目大佬友链站点集合收录学习网站、工具、组件、资源、API... 工具综合类工具包 UU在线工具集合站, 点击即可下载.exe文件(安全无毒)，内部集成约600种小工具 开发者武器库, 在线工具150+ 查找查看类 UU-svg, svg代码转图片 写作类 徽章生成, 如 : shields工具 先制作url，用以生成徽章图片: https://img.shields.io/badge/软件名-版本号-颜色或其代码.svg?logo=软件名&amp;logoColor=颜色 其中版本号可选，logo和logocolor参数可选，但首先要去icon库中确认库中有收录，否则需自定义logo(base64编码)。 后把徽章图片附上链接，嵌入行内，在markdown渲染器中，徽章将直接生效： （可选）最后，若.md需被博客软件(e.g. Hexo)渲染成html格式, 可能出现‘图片无法嵌入行内、图片无法附上链接’等问题，可考虑将上一步的代码手动转为html格式，放在.md中： &lt;a href=&quot;https://hexo.io/zh-cn/index.html&quot;&gt; &lt;img src=&quot;https://img.shields.io/badge/hexo-6.3.0-ff69b4.svg?logo=hexo&quot; alt=&quot;img&quot; style=&quot;display:inline-block;&quot;&gt;&lt;/a&gt; badge.fury工具特点：只针对几种语言；格式、配色固定；获取完整徽章更自动化。如pytorch的徽章：转换代码工作参照上面。 转换类 url ↔ markdown 单向工具(主推)，双向工具 建议url最好是博客文章类的页面，如CSDN、知乎、掘金、个人博客…的文章。 获取资源的API图片 获取 unsplash.com 的图片 获取随机图片：https://source.unsplash.com/random 根据关键词获得随机图片： https://source.unsplash.com/featured?{keyword} 留待慢慢整理电子书开发相关学习网站GitHub 开源库vue 组件库React 组件库css后端管理脚手架其他工具桌面端框架自媒体图片处理颜色相关设计相关音频相关站长工具在线简历制作https://www.mujicv.com/index.htmlhttps://www.mujicv.com/index.html"},{"path":"/oasis/creativity/index.html","content":"主页创意蚪儿随笔画廊创意空间记录我在创业、发明上的一些灵光一现的想法 发明 自行行李车 创业 外卖厨房直播app"},{"path":"/oasis/creativity/ivt-bike-luggage.html","content":"主页创意蚪儿随笔画廊发明：自行行李车 想制作一个可以上飞机的，自行车和行李箱的结合体。 点子契机人在机场，起飞还有数小时，想去周边玩耍溜达很不方便，需要一个便捷、多功能的代步工具。 市场现状奢侈、轻奢路线；都是电动的。类似产品如下： 世界最小电动滑板车车型“Arma”: 可折叠，众筹阶段 新指定小型轻便摩托车车型“V-Lite” 国产电动骑行登机箱AirWheel SE3S: ￥3000+，极速13km&#x2F;h。 总结： 价格不亲民：针对高端人士的轻奢、奢侈产品； 电动不可靠：均为电动产品，续航问题大，与其说是可靠的多功能代步工具，不如说是个电动玩具；"},{"path":"/oasis/dream-world/index.html","content":"主页创意蚪儿随笔画廊蚪蚪空间是蚪儿的专属天地 本意为这片天地一点点添砖加瓦，不曾想地基还未垒起，梦却戛然而止。2023&#x2F;12&#x2F;30 01:20，小蝌蚪宣告我们结束了。我知道，是我给不出美好未来，把我们带入了绝境。仍旧止不住心伤。我们甚至没能听过2024的钟声。 如今，十多天过去了，看到一些东西仍会止不住潸然，就像这个博主拍的：迷失在现实与过去（注：复制链接，粘贴到浏览器访问）"},{"path":"/oasis/essays/index.html","content":"主页创意蚪儿随笔画廊随笔集当我想写一些文章了就来这里吧 ~~ 个人留言板 零零散散 2023&#x2F;12&#x2F;27 蚪儿作词 仿写蚪儿如果你此刻感觉到开心不妨穿上最漂亮的裙子数十年来她都自赏着孤芳但撇见过她的人都在期待着下一次惊鸿生活小碎片"},{"path":"/oasis/essays/private-msg-board.html","content":"主页创意蚪儿随笔画廊个人留言板想往站点传点文字 ~~"},{"path":"/oasis/gallery/index.html","content":"主页创意蚪儿随笔画廊我们的画廊是生活中的难忘时刻汇集地。 ~~ 随机@tianhao_wang@eberhard@eberhard@eberhard@eberhard@vklemen 云朵"},{"title":"模型训练与测试","path":"/wiki/OD-mangrove/train-and-test.html","content":"基于paddleYOLO的coding (摒弃)资料：PaddleYOLO项目；官方文档 源码更改记录表.&#x2F;configs:A: configs&#x2F;datasets&#x2F;mangrove_coco.yml, configs&#x2F;datasets&#x2F;mangrove_voc.yml, configs&#x2F;yolov5&#x2F;yolov5_s_80e_ssod_finetune_coco_mangrove.ymlM: configs&#x2F;yolov5&#x2F;base&#x2F;yolov5_cspdarknet.yml.&#x2F;dataset:A: dataset&#x2F;mangrove&#x2F;.&#x2F;tools 环境准备：docker+paddle 注：容器里的/paddle/用于挂载和主机通信。另外一定要加--gpus=all参数。8040端口用于paddle的可视化工具。 数据准备资料：见 进入工作目录/paddle/PaddleYOLO/, 把自定义的voc类型训练数据复制进dataset/mangrove/ 新增Dataset配置文件及其对应的数据目录 改为规范的voc组织结构：bash dataset/mangrove/data_to_voc.sh, 并配置configs/datasets/mangrove_voc.yml 注意，bug点：name: VOCDataSet要换成!VOCDataSet 增加规范的coco组织结构：bash dataset/mangrove/data_voc_to_coco.sh, 并配置configs/datasets/mangrove_coco.yml 新增模型配置文件：涉及到选择模型，先选一个有预训练模型的：configs/yolov5/yolov5_s_80e_ssod_finetune_coco_mangrove.yml 准备新锚框： 因为该项目属于密集的小目标监测，所有的锚框像素范围需要很小才行。 计算新锚框：python tools/anchor_cluster.py -v false -c configs/yolov5/yolov5_s_80e_ssod_finetune_coco_mangrove.yml 更新到配置文件的锚框部分：configs/yolov5/_base_/yolov5_cspdarknet.yml 配置模型 注：默认学习率是适配多GPU训练(8x GPU)，若使用单GPU训练，须对应调整学习率（例如，除以8）。更多使用问题，请参考FAQ细细设置6个配置文件（1主5副） 基于paddleDetection中的SOD资料：项目主页，官方实践 直接调用其训练、验证、推理工具系统环境：4090显卡-24G显存。 训练 工具路径：PaddleDetection/tools/train.py 推理 推理命令：python /paddle/PaddleDetection/deploy/python/infer.py \\--model_dir=/paddle/PaddleDetection/deploy_inference_model/ppyoloe_crn_l_80e_sliced_visdrone_640_025 \\--image_dir=$test_img_dir_container \\--output_dir=/paddle/output/ \\--device=GPU \\--save_results --save_images False--batch_size 32## 更多的一些重要参数节选--save_results # 把所有预测框存到`output_dir`下的`bbox.json`中--save_images True # 默认会把带框的推理图存储下来--cpu_threads 1--run_mode paddle #/trt_fp32/trt_fp16/trt_int8--threshold 0.5--batch_size 1 # 有大量图需要推理时，可增大batch提高并行能力。能增多大取决于显存。但似乎总推理时间并没有减少。--slice_infer --overlap_ratio 0.0 0.0 # 将不再使用这俩参数 推理性能测试见性能对比"},{"title":"index","path":"/wiki/OD-mangrove/index.html","content":"背景介绍红树林目标检测，属于超大分辨率的TIFF图像的小目标检测。 项目构思流程设计标注数据 -&gt; 识别树种 -&gt; 密度统计 -&gt; 可视化呈现 标注数据: 标注得越详细，框体与目标越契合，模型训练出的准确性越高。 识别树种：基于YOLO的目标检测模型 密度统计：基于像素与地理坐标之间的映射关系 可能的难点 数据量和质量：处理大规模高分辨率图像需要大量计算资源和存储空间。 标注数据的准确性和质量： 对模型的性能至关重要。 图像分割：实现像素级别的图像分割对计算机视觉任务来说是复杂的，需要专业的分割算法和大规模标注的分割数据。 密度估算：从分割结果中估算树木密度可能受到光照、遮挡和树木形状的影响，这需要细致的算法和考虑各种因素。 性能优化：处理大图像需要优化计算效率和内存管理，以确保算法可以在合理的时间内完成任务。 step1 构建数据集数据背景 检测图像像素巨大，tiff格式，当尺寸40000*40000，约有3GB； 直接将原图用于训练、测试不可取，将导致算力不足，内存爆炸。因此在训练、推理前，必须有切割图像的步骤。 检测目标像素超小，树冠像素尺寸在约20~50； 检测精度的提高存在挑战 没有现成的、精细标注的训练集。 数据标注工作标注流程是先切割图像，后利用标注软件进行作业。 安装TIFF图像切割工具 点击下载TIFF图像切割工具 放到自定义文件夹下，解压，查阅readme.txt，双击运行切割大图工具.bat 当您的系统中未安装python，该工具会自动下载conda-python安装包（或者您也可点击手动下载），下载后按如下流程安装python： 安装：双击刚下载的安装包，根据提示选择All Users。如果有add to env PATH的选项请勾上，勾不上也无妨。记住安装目录，默认为C:\\ProgramData\\Miniconda3，也可自定义安装到其他盘。 验证环境变量：进入操作系统的设置，搜索框中搜高级系统设置，点击环境变量，双击系统变量中的Path，查看路径列表中是否有Miniconda3相关的两个路径（C:\\ProgramData\\Miniconda3和C:\\ProgramData\\Miniconda3\\Scripts，若安装目录是自定义的，这里也会相应改变），没有则新建该路径。 测试：点击开始菜单，软件目录中找到Anaconda3下的Anaconda powershell prompt，右键以管理员身份进入，执行conda -V，返回相应版本号，即安装成功。 安装好python后，重新双击运行切割大图工具.bat，片刻后弹出窗口如下： 按您需求设置，其中输出图片格式，子图尺寸，重叠比率可保持默认值, 也可0.1重叠。 点击开始，当下方日志框中出现Mission Success!，即切图成功，前往你指定的存放目录进行标注工作。 注意： 图片越大，加载时间loading image......越长 子图集合中可能会存在大量空白图片，这是由于原始.tif图像四周的空白像素点导致，忽略即可。另外：命令行实现切割：time python /home/james/obj_OD/demo_mangrove/split_app.py --input_dir origin --output_dir origin 安装使用标注软件 安装：进入刚才的Anaconda powershell prompt软件，输入pip install labelImg并执行，片刻后就安装好标注软件了。 进入：执行labelImg，我们将进入标注工具界面。 此后若再次使用该工具，可直接在Anaconda powershell prompt或cmd命令行中输入执行labelImg即可。 界面左上角点击open dir，导入存放原图的文件夹。 View菜单中选择single class mode，单类模式下提高标注速度。 点击create rectBox（或快捷键W），即可鼠标进行标注。首个框体标注会让你自定义目标类别。 框体要包含完整目标物，且要尽可能小，不要遗漏每一棵树。完成一张图的标注后ctrl+S保存即可，这样操作目录下会生成一个同名的.xml文件，格式如下: &lt;annotation verified=&quot;yes&quot;&gt; &lt;folder&gt;01_Downloads&lt;/folder&gt; &lt;filename&gt;1.tif&lt;/filename&gt; &lt;path&gt;G:\\doc\\01_Downloads\\1.tif&lt;/path&gt; &lt;source&gt; &lt;database&gt;Unknown&lt;/database&gt; &lt;/source&gt; &lt;size&gt; &lt;width&gt;41394&lt;/width&gt; &lt;height&gt;37777&lt;/height&gt; &lt;depth&gt;3&lt;/depth&gt; &lt;/size&gt; &lt;segmented&gt;0&lt;/segmented&gt; &lt;object&gt; &lt;name&gt;tree&lt;/name&gt; &lt;pose&gt;Unspecified&lt;/pose&gt; &lt;truncated&gt;0&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;bndbox&gt; &lt;xmin&gt;23146&lt;/xmin&gt; &lt;ymin&gt;25563&lt;/ymin&gt; &lt;xmax&gt;23162&lt;/xmax&gt; &lt;ymax&gt;25579&lt;/ymax&gt; &lt;/bndbox&gt; &lt;/object&gt; 点击左侧菜单Next Image继续标注。 目标分类方法树种与类别名对应关系红树林植物有诸多类别，下面是本项目的类别名与树种的对应关系： 树种 类别名 标注特征 备注 红海榄 tree 秋茄 qiu 白骨壤 bai 无瓣海桑 wu 老鼠勒 lao 桐花树 tong 灌木类，全省有一定种植（据资料，惠州项目基本无种植），一般单株为一簇一簇，叶片翠绿、黄绿、暗绿都有，影像识别特征较难。 木榄 mu 卤蕨 lu 草本类，一般无直接种植，暂时不需识别。 拉关木 la 暂时没有找到影像素材，本次惠州、广州不用识别，后续补充。 其他 noise 非红树林的其他所有树种 树种图例及特征 标注日志及备忘录 序号 数据源 标注图像存放路径 备注 1 &#x2F;mnt&#x2F;d&#x2F;【003】红树林核查识别工作&#x2F;惠东正射1&#x2F;1.tif &#x2F;home&#x2F;james&#x2F;obj_OD&#x2F;PaddleDetection&#x2F;dataset&#x2F;mangrove_coco 已用于一轮训练 2 D:\\【003】红树林核查识别工作\\2023年核查数据图\\惠东2023核查01号图斑\\标注 潞哥√ 3 D:\\【003】红树林核查识别工作\\2023年核查数据图\\惠东2023核查11号图斑\\标注 潞哥√ 4 J:\\【011】2023红树林省级核查正射影像\\惠州市\\惠东县\\正射影像 我× step3 训练数据我们基于640*640的子图进行训练。 训练日志 序号 base model 训练数据 Best test bbox ap 模型路径 1 ppyoloe-l T-31&#x2F;V-9 0.461 &#x2F;home&#x2F;james&#x2F;obj_OD&#x2F;PaddleDetection&#x2F;deploy_inference_model&#x2F;ppyoloe_crn_l_200e_sliced_mangrove_640_025 2 step4 预测图像通过训练得到模型后，我们将导入新图片进行预测。但由于该项目的预测图片尺寸一般都超大，因此预测流程归纳为：预处理 -&gt; 预测 -&gt; 后处理 预处理：手动切割图像模型预测时，输入图像可以是任何有效尺寸，因此我们面临的首要问题是，切割到什么尺寸可以使推理更高效、准确？ 注意事项：python的图像处理库 (PIL或Pillow)有像素限制，支持处理最高9450*9450的图像。 下面将以5000*5000的目标图片进行测试。 一阶段法：使用事先设计的自切功能来推理 手切子图 手切多少张 自切子子图数 显存消耗(G) 单张手切图耗时(s) 总耗时(s) 识别数 640 81 1 2.2 - 20 13355 1000 36 4 3.2 5 54 15299 1500 16 9 4.8 10 106 15817 2000 9 16 6.9 22 177 15345 2500 9 16 7.2 40 270 23387 3000 4 25 9.7 97 276 15410 4000 4 49 15.5 270 956 - 5000 1 64 19.7 450 450 - 可见，传入推理模块的图越大，推理速度越慢，显存消耗越大。 两阶段法：使用手切推理 手切子图 手切多少张 显存消耗(G) 总耗时(s) 识别数 640 81 1.1 9 38766 1000 36 1.8 7 17729 1500 16 1.8 5 8000 2000 9 1.8 5 4500 2500 9 2.2 5 4500 3000 4 2.2 4 2000 4000 4 2.2 5 2000 5000 1 1.8 4 500 可见，直接事前切图到最小，即模型训练所用尺寸，速度非常快，显存消耗非常小，识别能力非常强。 结论： PIL库处理图像能力有限，必须事前切图，再导入推理模块。 推理模块的自切功能--slice_infer不如手切。 切割标准为：直接切到训练所用的640*640。 开始推理推理日志： 序号 分辨率 大小 耗时 原图路径 1 4.1w*3.7w 3.0G 4’ “D:\\【003】红树林核查识别工作\\惠东正射1\\1.tif” 2 2w*2w 1.5G 1’10’’ “D:\\【003】红树林核查识别工作\\惠东正射1\\origin\\1_20000x20000.tif” 后处理：拼接预测图像初步设想，后处理的路径有两种： 只交付预测框文本数据 优点：简洁，方便，且如果后续借助某些方法将数据转换为可嵌入GIS软件的格式，使预测框的呈现方式更加原生，这会更符合目标用户的使用习惯； 缺点：寻找这种转换方法不一定能成功，且会带来更高的项目设计成本。 交付带预测框的拼接后的图像 优点：呈现更直观； 缺点：需要更多的存储空间； 难点：拼接的大图将是一张超高分辨率的TIFF图像，简单的工具不能实现。当前只针对第二种方法进行设计。鉴于其难点，常用的PIL库、imageio库等均不支持超大图，因此采用了GDAL。 GDAL的安装与使用资料：地理空间开源基金会osgeo&#x2F;osgeoCN; GDAL的官方文档&#x2F;中文文档；python的API手册官方&#x2F;中文 安装：conda install -c conda-forge gdal 使用：一定要先用from osgeo import gdal导入模块 设计拼图模块: python /home/james/obj_OD/demo_mangrove/splice.py --input_dir $output_dir --output_path $final_path 模块性能测试： 原图尺寸 原图大小 合并耗时 合并后尺寸 其他 4.1w*3.8w 3.0G 18’ 4.36G 可是图片损坏状态 2w*2w 1.5G 3’’ 1.1G 可见上行的合并流程有bug [TODO:] 用户实操：如何推理？ 把需要预测的TIFF大图放到一个空文件夹中，复制该文件夹路径； 由于一些未知的bug, 建议预测的原图不大于2GB。 在Ubuntu中运行bash /home/james/obj_OD/demo_mangrove/demo-mangrove.sh --input-dir &quot;复制的路径&quot;； 片刻后，带预测框的原图将出现在桌面的红树林目标检测可视化结果文件夹中。 step5 计算密度等操作"},{"title":"建立一个公司","path":"/wiki/OD-mangrove/create-a-company.html","content":"由于涉及到未来可能存在的项目竞标的问题，我们需要考虑成立一个公司主体才行了。从来都没接触过办理营业执照的事情，这里将给出一些参考。 如何办理营业执照执照内容注意事项根据一个开公司的战友的经验分享，总结如下： 执照价格：办下来很容易，深圳应该就几百块钱。 经营范围：可以往多了写，互联网技术产品、设备制造、产品销售、技术转让等等，没有成本。 注册资金：数万到百万均可。新《公司法》规定，2024/07/01从认缴制改为5年内实缴制，因此注册资金要综合考虑到我们未来的经营规模，是否有能力将那么多钱放到公司账户上。 其实也没关系，注册资金写多了也可以在必要的时候实行减资操作。 注册地：选择“集群注册”，即选在某个经济开发区下面，几千块搞定，这样也避免了像曦哥说的那样，仅仅为了一个注册地的问题，而去长期租赁一个场地形成的人力和租房成本。 公司账户办理：也简单，不用太费心，只是要多花两三个月流程才走的下来。 执照的维护：也没啥成本，每月报下帐，每年写好年报，就能长期存续下去。 因此，我们关心的重点还是是否可以把项目预算缩小，或者我们怎么提高竞标能力。"},{"title":"AI代码能力提升","path":"/wiki/awesome-proj/improve-AI-code-skill.html","content":"文章站点项目大佬友链AI-coding-skill 如何提高AI代码技能，去lucidrains大佬主页研究他的每一个仓库吧。另外再搭配一个AI代码保姆级解释的网站。 lucidrains"},{"title":"index","path":"/wiki/awesome-proj/index.html","content":"文章站点项目大佬友链项目收集 网页截图转前端代码"},{"title":"Git学习","path":"/wiki/my-notes/git.html","content":"资料菜鸟：菜鸟教程，最佳简明指南git: 总站；文档：命令手册、书籍、速查表、howto ；深入学习：像git一样思考，图解github，其他链接github: 帮助中心，文档中心 TIPS: 文中的PR代表pull request；fork等于‘派生’。 一些重要概念一些语法杂项&lt;branch&gt;@&#123;&lt;筛选条件&gt;&#125;, 见 指定提交我们有许多引用（HEAD，branch，tag，commitID）来找到这些引用所指向的提交，而有更多的历史提交该如何索引到呢？下面的例子我都将用HEAD代表引用 指定单个提交: ^3是第三个爸爸（前提是对应提交有多个爸爸，0是自己，1和置空是爸爸，2是二爸，…）； ~3是第三层长辈（0是自己，1和置空是爸爸，2是爷爷，…）。 举例：HEAD^, 指向该引用的父提交。HEAD^2, 指向第二个父提交。 举例：HEAD~2 代表“第一父提交的第一父提交”，也就是“祖父提交” 举例：HEAD~3^2 HEAD的曾祖父的第二个父亲。 指定提交区间 双点：选出在一个分支中而不在另一个分支中的提交 git log experiment..master 显示在 master 分支中而不在 experiment 分支中的提交 如果你留空了其中的一边， Git 会默认为 HEAD 常用: 查看你即将推送到远端的内容 $ 多点：在任意引用前加上 ^ 字符或者 –not 来指明你不希望提交被包含其中的分支。三者等价git log refA..refBgit log ^refA refBgit log refB --not refA git log refA refB ^refC 所有被 refA 或 refB 包含的但是不被 refC 包含的提交。 三点：选择出被两个引用 之一 包含但又不被两者同时包含的提交。git log master...experiment 比较’后者分支’和’两者公共祖先分支’之间的差异。 三区代表工作目录、暂存区(index)、本地仓库（commit快照的集合、版本库）。 Pull-Request参考 引用是指向 Git 数据库中某个提交（commit）的指针。查看引用的命令见。· 本地的引用： HEAD类 【HEAD】：（必有！.git/HEAD）是指向当前工作目录所在分支的指针。一般HEAD指向分支，所以它是指向指针的指针。 detached HEAD： （可有）意味着 HEAD 指向的是一个特定的提交（commit），而不是分支。所以它是指向对象的指针。在这种状态下的提交将不属于任何分支。为此建议新建一个分支来承接这个提交对象。 FETCH_HEAD：（可有，.git/FETCH_HEAD）指向最近一次从远程存储库获取的提交。 ORIG_HEAD：（可有，.git/ORIG_HEAD）保存某些操作前的 HEAD 的值，用于回滚。它通常用于在执行危险的操作（例如git reset）之前保存 HEAD 的位置。 分支（branch）: （如.git/refs/heads/master） 当本地分支追踪着一个远程分支，则此时本地分支叫跟踪分支，远程的叫上游分支。 标签（tag）:（如.git/refs/tags/1.0.0） PR型分支: 本地不会存在这种分支 · 远程的引用:（注意，一个版本库可以连接多个remote） (HEAD不会存在于远程) 远程分支：（如.git/refs/remotes/master）详见 远程标签。 合并请求分支&#x2F;PR分支：（如refs/pull/&lt;pr#&gt;/head） 由来：远程源仓库一旦有PR发生，就会生成这样一个分支型引用，指向派生仓库里想要合并的那个分支的最新提交快照。clone和fetch都会忽略这类引用，因此可称作一种假分支。 优点：本质来讲，仓库内的一个引用，却指向了仓库外的一个资源，还不用过问这个资源的url，简直就是为高效的pull request量身定做的。 查看这种分支列表的方法：参考 如何使用：参考 方法4。 命令图解： Git配置和初始化初始化 方法1：git init 方法2：git clone &lt;url&gt;.git 使用前的配置git config有3个级别：--system系统级；--global用户级；--local本地级。 显示所有三级配置： git config --list --show-origin 配置用户：git config --global user.name &quot;John Doe&quot;，git config --global user.email johndoe@example.com忽略文件详解 其他有用配置 设置git别名：简化常用git命令的输入复杂性, 如， 撤销已暂存的文件git reset HEAD -- &lt;file&gt;-&gt;git unstage &lt;file&gt;：$ 查看最后一次提交日志：git log -1 HEAD-&gt;git last: $ 外部命令变成git子命令(叹号)：gitk-&gt;git visual: $ 暂存密码几分钟：用于push时Git服务器询问用户密码的临时缓存。git config --global credential.helper cache pull时默认使用变基：git config --global pull.rebase true Git命令更多命令移步官方文档 基础类git add功能：跟踪新文件，把已跟踪的文件放到暂存区，合并时把有冲突的文件标记为已解决状态等。本质：精确地将内容添加到下一次提交中 git commit提交动作的意义：是对你的工作目录作一次快照，以后可以回到这个状态，或者进行比较。 命令 说明 git commit -m &quot;...&quot; 提交 git commit -a -m &quot;...&quot; 提交并跳过缓存，即省略git add。但要小心一些并不需要的文件。 git commit --amend 追加提交，而不新增快照。详见 git rm git删除文件的原理：仓库的快照是没有删除一说的，只有更新。因此git的删除实际执行手段是：从暂存区移除，然后提交。 git删除文件的效果：工作区、暂存区都会被删掉。如果接着commit后，新快照里相应文件也就没有了。 注意事项：当文件在暂存区和最新快照的内容有不同，则会报错并建议--cached或-f 命令 说明 git rm log/\\*.log 工作区、暂存区都会被删掉。这里的文件是glob模式匹配 git rm --cached &lt;file&gt; 只删除暂存区 git rm -f &lt;file&gt; 强制删除工作区、暂存区 git mv-功能：移动文件、重命名文件。-原理：等效于三个命令mv fileA fileB &amp;&amp; git rm fileA &amp;&amp; git add fileB, 即实现了在暂存区内的文件移动。 查看类git status -sgit show git show &lt;commit/branch/tag&gt; --statgit show &lt;brancn&gt;@&#123;&lt;筛选条件&gt;&#125;用来筛选查看结果，如HEAD@&#123;5&#125;是前5次的HEAD历史；master@&#123;yesterday&#125;是你的 master 分支在昨天的时候指向了哪个提交。 git reflog查看HEAD所指向的历史引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 git diff 命令 说明 git diff 比较的是文件在暂存区和工作目录的差异, a/是暂存区，b/是工作目录。 git diff --staged 比对文件在最后一次提交和暂存区的差异, a/是本地仓库的最后一次提交，b/是暂存区 git diff master [feat1] 比较两个分支/提交之间的差异(分支名也可换成提交对象哈希值), 若没有第二个参数，则默认第二个参数是当前分支 git diff master..feat1 比较两个分支之间的差异, 等价于上行命令。详见 git diff master...feat1 比较’后者分支’和’两者公共祖先分支’之间的差异，等价于git diff $(git merge-base feat1 master) feat1 git difftool --tool-help 看你的系统支持哪些 Git Diff 插件（包括命令行形式的、窗口形式的 TODO:） 其他参数： --cached --check 检查代码错误 git log git log --oneline --decorate --graph --all 查看各个分支当前所指的提交对象、分叉历史。 git log b1 --not master 查看b1分支下不与master重合的提交对象。等价于git log master..b1 其他参数 –abbrev-commit 显示提交对象的前7位 -g 来查看类似于 git log 输出格式的引用日志信息。 --no-merges 不要显示合并提交, 即三方合并场景下自动生成的新提交对象。 --patch/-p 显示每次提交所引入的差异&#x2F;具体修改。 --show-signature 显示签名信息 -2,--since=2.weeks 限制输出选项，更多 --stat 看到每次提交的简略统计信息 --pretty=oneline/ short/ full/ fuller/ format:&quot;%h - %an, %ar : %s&quot; 可以使用不同于默认格式的方式展示提交历史。 具体格式占位符见 更多常用选项 log中的搜索功能，见 git grep在工作目录中搜索。详见搜索 git blame显示每一行是由谁提交的。 查看各种指针指针即引用，包含branch、tag等。 查看分支git branch -a, 列出本地和远程的所有分支，即.git/refs/heads/和.git/refs/remotes/下的所有文件。更详细的branch使用见。 查看所有引用git ls-remote [&lt;url&gt;]，列出远程url下的所有引用。低级命令，显示任意一个仓库(url)中的所有引用。其中url也可换成url-shortname。获取到的列表形如： 9c906cc02bf209b8b8823f696fffeac5501a3372 HEAD9c906cc02bf209b8b8823f696fffeac5501a3372 refs/heads/main9c906cc02bf209b8b8823f696fffeac5501a3372 refs/heads/npm6a83107c62950be9453aac297bb0193fd743cd6e refs/pull/1/headafe83c2d1a70674c9505cc1d8b7d380d5e076ed3 refs/pull/1/merge3c8d735ee16296c242be7a9742ebfbc2665adec1 refs/pull/2/head15c9f4f80973a2758462ab2066b6ad9fe8dcf03d refs/pull/2/mergef6b06a6d6c61bfe81ea99cc55669121a7d6dee8f refs/tags/1.0.0-rc.63d98a5a189e0bd680850a5e4c388021c03bf89de refs/tags/1.0.1a 解释： HEAD指向工作目录所在的提交对象； refs/heads/下都是分支； refs/tags/下都是标签； （注：为什么没有refs/remote/, 毕竟本地的.git/refs/下一般都有remote/目录？因为ls-remote命令的对象是远程仓库，不是本地仓库，远程仓库当然没有remote啦。） refs/pull/ 下都是PR分支 refs/pull/&lt;pr#&gt;/head: 指向PR过程中派生仓库里合并请求分支中的最后一个提交快照。 refs/pull/&lt;pr#&gt;/merge: 它表示如果你在网站上按下“合并”按钮，将产生的提交。这可以让你在点击按钮之前测试合并。 撤销和重置类清理 clean参考 贮藏 stash参考 恢复 git reset HEAD &lt;file&gt; !危险, reset加'--hard'更危险，撤销暂存区的文件 git checkout -- &lt;file&gt; !危险，撤销工作区的文件所做过的修改。另参考 git checkout HEAD &lt;file&gt; 从最新提交恢复文件 git revert: 撤销一个提交的更改。 标签类git tag 查看标签：git tag,git tag -l &quot;v1.8.5*&quot;git show 看到标签信息和与之对应的提交信息 打标签：给仓库历史中的某一个提交打上标签，以示重要。分类如下， 轻量标签（lightweight）：只是某个特定提交的引用git tag v1.4 附注标签（annotated）：是存储在 Git 数据库中的一个完整对象git tag -a v1.4 -m &quot;my version 1.4&quot; 推送标签（类似推送分支） git push &lt;remote&gt; &lt;tagname&gt; 推送特定标签到远程仓库，类似推送分支。 git push &lt;remote&gt; --tags 推送远端没有的所有标签 删除标签 git tag -d &lt;tagname&gt; 本地的 git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; 远程的, 将冒号前面的空值推送到远程标签名，从而高效地删除它 git push &lt;remote&gt; --delete &lt;tagname&gt; 远程的, 方法2, 更直观 检出标签 git checkout 2.0.0 查看某个标签所指向的文件版本 缺点：使你的仓库处于“分离头指针（detached HEAD）”的状态，此时要想将修改提交到标签里是不可能的，得创建新分支来实现git checkout -b version2 v2.0.0 其他参数： ☆ 加签名：git tag -s v1.5 -m &#39;...&#39;（如何配置与使用签名请参考） git describe &lt;branch&gt; 为提交生成构建号。由于每个提交的ID是一串不易读的SHA-1值，该命令实现了为提交附上一个可读的名称。 构建号的格式：&lt;最近的标签名&gt;-&lt;自该标签之后的提交数目&gt;-g&lt;8或10位的SHA-1值&gt; (e.g. v1.6.2-rc1-20-g8c5b85c)。 前提条件：最近的那个tag的生成需要使用 -a 或 -s 选项。 远程相关见含remote fetch pull push等。 分支相关见含branch checkout merge rebase等。 git checkout checkout（检出）的作用是实现在不同的分支或文件状态之间切换，状态切换意味着工作目录内容的改变。因此一般在检出前，需留意你当前的修改需不需要被提交(commit)、临时保存(stash)等。checkout能切换分支，恢复文件等。 ☆切换分支：git checkout [-b branch2] [branch1] 形式1：git checkout branch1，切换到项目版本库中名为branch1的分支。 注意：(先用git branch -a查看所有分支的列表) 当branch1存在于本地分支列表(形如branch1)，则可以直接切换过去，和git switch branch1等价； 当branch1只存在于远程分支列表(形如origin/branch1)，即此时该远程跟踪分支在本地没有跟踪分支： 若用git checkout origin/branch1，则HEAD称为detached HEAD，因此建议使用下一行的方法; 若用git checkout branch1，则该命令是git checkout -b branch1 origin/branch1的简化版（见形式3）。 当branch1不存在于整个分支列表，则报错。 形式2：git checkout -b branch2，基于当前分支，新建并切换到分支branch2。 形式3：git checkout -b branch2 branch1，基于指定的分支branch2，新建并切换到分支branch1。 ☆最常用的场景：git checkout -b branch1 origin/branch1-&gt; 太过于常用，简化版本：git checkout --track origin/branch1-&gt; 进一步简化：git checkout branch1（前提：本地没有名为branch1的分支，而远程仓库刚好有。TODO: 连接的是多个远程仓库怎么办） 切换/恢复文件：git checkout -- file1 工作目录中的file1被修改过，此时恢复优先级为：暂存区的file1 -&gt; 提交对象中的file1。 git switchswitch是对checkout的切换分支方面的功能的改进。git switch &lt;branch-name&gt; 切换到一个已有的本地分支；或切换到一个本地没有但远程有的分支，它会自动创建并设定好远程追踪。 更多参数 -c &lt;branch&gt; 创建并切换到一个新分支。 发布相关 git archive 见 git shortlog 见 其他类git submodule: 管理 Git 子模块。git fsck: 检查对象文件和引用的完整性。 管道命令git中更加底层、低级的命令。cat-filecheck-ignorecheckout-indexcommit-treecount-objectsdiff-indexfor-each-refhash-objectls-filesls-treemerge-baseread-treerev-listrev-parse 查看branch1的SHA-1show-refsymbolic-refupdate-indexupdate-refverify-packwrite-tree Git远程一个本地仓库可连接多个远程仓库。 命令：查看、增删远程仓库git remote -v 显示本地仓库连接的所有远程仓库git remote show &lt;remote&gt; 查看某一个远程仓库的更多信息git ls-remote &lt;remote&gt; 查看某一个远程仓库下的所有远程引用(HEAD, tag, branch)的完整列表 git remote add &lt;shortname&gt; &lt;url&gt; 添加远程仓库git remote rename &lt;shortname1&gt; &lt;shortname2&gt; 修改一个远程仓库的简写名git remote remove &lt;shortname&gt; 移除一个远程仓库 命令：下载、拉取(以下假设remote&#x3D;origin, branch&#x3D;dev1) git fetch &lt;remote&gt; [&lt;branch&gt;] 只会将数据从远程仓库下载&#x2F;更新到你的本地仓库 —— 它并不会自动合并或修改你当前的工作，需要自己手动merge。原理见图。 fetch中的分支问题详见。 git pull等于fetch+merge。使用前提是已经设置好了跟踪的上游分支，见这里的方法2。更多命令： git pull &lt;url&gt; &lt;branch&gt; 临时把url下的branch进行拉取合并，避免了‘添加remote’等配置。 命令：推送(下面假设remote&#x3D;origin, branch&#x3D;dev1) git push &lt;remote&gt; &lt;branch&gt; 其原始命令为：git push origin refs/heads/dev1:refs/heads/dev2, 或git push origin dev1:dev2, 即推送本地的dev1分支来更新/成为远程的dev2分支 牢记：冒号前是本地分支，冒号后是远程仓库；注意：两个分支名字可同可不同。 注意【集中式工作流】：当多人推送到同一远程分支时，你必须先抓取他们的工作，再将其合并进你的工作（这里抓取+合并也可换成pull），然后才能push。 push的更多参数 git push origin --delete dev1: 删除远程的dev1分支 git push -u origin dev1: -u即--set-upstream-to, 会将本地的“dev1”分支和指定了远程仓库的“dev1”分支关联起来（即手动设置远程跟踪分支的概念, 联系branch-u）。 以后在dev1环境下就可以用简化的“git push”命令来推送了（pull也是）,不需要指定远程分支名字。 这样方便在一个仓库连接了多个远程仓库时，对push的默认配置。 TODO: 引用规范 push标签 git push &lt;remote&gt; &lt;tagname&gt; 推送特定标签到远程仓库，类似推送分支。 git push &lt;remote&gt; --tags 推送远端没有的所有标签 ★ Git分支管理！概述 原理解读：用对象的逻辑理解git原理： Git的分支，是术语引用的其中一种。其本质上仅仅是指向提交对象的可变指针。 HEAD是一个指针，指向当前所在的本地分支（可理解为当前分支的别名） 一些命令 git branch 查看： git branch 本地所有分支 git branch -a 本地+远程所有分支。（查看当前仓库有哪些远程仓库，执行git remote -v） -v 每个分支的最后一次提交的信息 -vv 在-v基础上有更多简笔信息：跟踪的上游分支、与上游的版本差异。常用：$ -u 设置上游分支，详见 --merged [branch], --no-merged [branch] 只显示已经&#x2F;没有合并到当前分支的分支 --merged下显示的非当前分支，可尽情删除，毕竟都合并过了。其他情况，也可强制删除-D 新建分支：git branch &lt;branch1&gt; [base-branch] 当base-branch缺失，则默认基于当前branch来新建。 可为分支设置命名空间, 如branch1可写为james/branch1。 更多命令：git branch -h git checkout: 切换分支或还原工作目录中的文件。见 git merge: 将一个分支的更改合并到另一个分支。见 git rebase: 变基，将提交从一个分支移动到另一个分支。见 场景：分支的新建与合并新建和切换分支 git checkout -b &lt;dev1&gt;切换&#x2F;检出命令的机理：让HEAD指向另一个的分支指针，同时工作目录也恢复成对应的快照版本。一般情况下，这些分支命令也可分开操作：查看(git branch)新建(git branch &lt;dev1&gt;)切换&#x2F;检出(git checkout &lt;dev1&gt;)，当dev1在本地不存在时，该命令实际是把远程分支检出到本地新建的同名分支，同时设置好跟踪此时master有紧急错误需要修复先把dev1分支打扫干净：尽量把所有修改都形成快照，即commit。实在不行也可贮藏(stashing)和修补(amending)。切换到主分支: git checkout master新建并切换到修复分支：git checkout -b hotfix修改、测试、提交把修复分支合并到master: git checkout master, git merge hotfix删除重复分支：git branch -d hotfix(因为此时master指针和hotfix指针，指向同一个提交对象。 )继续回到开发分支dev1上工作修改、测试、提交把开发分支合并到master: git checkout master, git merge dev1此时，若master指向的快照不是dev1指向的快照的直接祖先，则git后台会寻找他俩的公共祖先，做一个三方合并, 三方合并会自动创建一个新提交对象C6，如下图：删除开发分支：git branch -d dev1有冲突怎么合并？merge后，如果某文件有冲突，会提示合并失败。定位产生冲突的文件：git status。进入文件手动解决冲突：冲突代码会有明显的状态标识，我们需二选一、或自定义处理代码。删除标识：&lt;&lt;&lt;&lt;&lt;&lt;&lt; , ======= , 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt;标记文件为冲突已解决：git add file最终合并提交。 分支开发工作流长期分支主题分支 远程分支(下面假设remote&#x3D;origin, branch&#x3D;dev1) ★ 远程跟踪分支：是远程分支状态的本地引用，无法移动(即无法在该分支基础上产生新的提交快照)。形式为&lt;remote&gt;/&lt;branch&gt;, 另外用git branch -a命令可得到形式remotes/&lt;remote&gt;/&lt;branch&gt;。 如何产生：git fetch &lt;remote&gt;后抓取到了本地没有的新分支就是。 想在远程跟踪分支上工作怎么办，有两种方法： 把远程追踪分支合并到本地当前分支：git merge origin/dev1。 基于远程追踪分支在本地新建一个分支：git checkout -b dev1 origin/dev1(超级常用的命令，具体使用见里的形式3。) 此时，本地的dev1叫跟踪分支, 对应的那个远程的dev1叫上游分支。 ★ 跟踪分支&#x2F;上游分支:从一个远程跟踪分支(上游分支)检出一个本地分支(跟踪分支)时自动创建的分支。有了’上游’和’跟踪’两个分支的对应，git pull才能自动识别抓取、合并的对象; 且可用 @&#123;upstream&#125; 或 @&#123;u&#125;来代替上游分支名，如git merge @&#123;u&#125;-&gt;git merge origin/dev1。如何生成跟踪分支（及其上游分支）： 【克隆时自动生成】：git clone后，会自动获得跟踪分支(master)对远程跟踪分支(origin/master)的跟踪。 【把远程分支检出到本地新分支时自动生成】：具体使用见里的形式3。 【手动设置&#x2F;更改本地已有的分支的上游】：git branch -u origin/dev1 [local_branch]（-u即--set-upstream-to，联系push-u） 变基与合并同：都是整合分支的方法，两者执行结果是相同的。异：merge下的提交历史复杂(多线)，因为所有commit都保留了；rebase下的提交历史简洁(单线)，因为会删除部分历史commit。 变基-rebase 变基的定义：即提取在当前主题分支experiment中引入的补丁和修改，移动到目标基底分支master进行应用和提交。 变基的实质：丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 变基的原理：一开始experiment指向C4，master指向C3。-&gt; 找到最近共同祖先C2-&gt; 对比experiment对C2的所有修改(即一个&#x2F;多个快照)并存为临时文件；-&gt; 将experiment指向master所在的C3；-&gt; 在C3基础上依序应用临时文件的修改，生成新快照C4&#39;(多个快照时，就是新快照链), experiment指向最新的那个快照；-&gt; master进行快进合并完成变基。 命令解释：git rebase master, 把当前分支融入到master里。 操作步骤： 先在主题分支里实施变基：$ git checkout experiment, $ git rebase master 这两个命令等价于$ git rebase master(base分支) experiment(topic分支) 后在目标分支里完成变基：$ git checkout master, $ git merge experiment 最后删除不用的分支：$ git branch -d experiment 优点：对比’merge’, 变基使得提交历史更加整洁——没有分叉。实际上，rebase就是把merge的三方合并情况改造成快进合并。 ☆风险：鉴于变基有丢弃提交的特性，如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。 风险后果：仓库中会有多个完全重复的commit；别人丢弃的一些commit会因为你的push再次回到仓库；仓库版本混乱。 出现风险的解决办法：用变基解决变基 也就是当你在fetch了‘别人push的经过变基的commit’后，不要用‘merge’了，而是用‘rebase’命令，将当前主题分支变基到远程跟踪分支上，如：git rebase teamone/master [master]，然后执行【操作步骤】中的2-3步。 上述过程fetch + rebase命令可整合为：git pull --rebase, 简便实现主题分支变基到远程跟踪分支。 下图是用merge和用rebase的效果对比： 该办法的前提：确保别人的变基中 C4’ 和 C4 是几乎一样的。 更多功能： 【–onto】当分支有嵌套，只想让子子分支并入指定分支，同时不让子分支并入： 图示场景：让server分支下的client分支并入master分支 方法：$ git rebase --onto master server client -&gt;$ git checkout master -&gt;$ git merge server 解释：“取出 client 分支，找出它从 server 分支分叉之后的补丁，然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样” 【-i】用 rebase -i 将工作压缩成一个单独的提交 拣选-cherry-pick变基是把一个分支上的多个提交打成一个补丁，更新到目标分支上，生成新提交；拣选是把一个提交的更改，直接更新到目标分支上，生成新提交。 这种方式在你只想引入主题分支中的某个提交，或者主题分支中只有一个提交，而你不想运行变基时很有用。git cherry-pick e43a6 合并-merge使用场景见。 命令解释：git merge dev1, 将b1分支的内容合并到当前分支中。 合并的类型： 快进合并：dev1要并入master，而master的快照是dev1的快照的直接祖先，因此master指针可直接快进到dev1处。 三方合并：不是直接祖先，则要找俩分支的公共祖先快照(分叉点)，对这三个快照进行整合，生成一个新快照(汇合点)。此时master和dev1都指向这个新快照。 更多参数： 延迟生成新快照：git merge --squash dev1，在需要三方合并的场景下，该参数会做合并过程的几乎所有工作，除了生成新快照。这些改动将在你下一次手动提交时被写入。 另一种延迟：--no-commit Git服务器(公共仓库)为了git的协作功能，你的仓库需要转变成公共仓库/远程仓库/git服务器。 4种协议git服务器使用的通信协议支持：本地、SSH、HTTP、Git，详见。一般地，用ssh://进行授权访问，用git://进行无授权访问，用https://可同时实现。 Git协议 其数据访问特点：快速且无需授权，因此仓库只能是公开的。 优点：对只读的项目很友好，省去逐一配置 SSH 公钥的麻烦。… 用SSH协议搭建Git服务比起HTTP，借助SSH协议的搭建更加容易！但其难点在于用户管理——如何设置数量不可知的用户的访问权限、读写权限？ 方法1：在Git服务寄宿的主机上创建一个’git’用户供所有用户使用。 方法2：让 SSH 服务器通过某种集中授权机制(e.g. LDAP服务)来授权。下面将借助方法1进行搭建： 配置远程主机准备一个ssh可连接的远程主机: 我有一个云服务器、一个域名，因此我将云服IP添加到了域名解析mygit.taddream.site中， 访问云服方式为：ssh -p 10361 root@mygit.taddream.site创建git用户，建立.ssh目录: sudo adduser gitsudo usermod -aG sudo git # 将 git 用户添加到 sudo 组中su gitcdmkdir .ssh &amp;&amp; chmod 700 .sshtouch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys接收来自一些用户的公钥妥善存放: echo &quot;粘贴公钥内容&quot; &gt;&gt; ~/.ssh/authorized_keys准备裸仓库到远程主机中裸仓库目录名一定是.git结尾；安装git服务的远程主机中，一般所有的裸仓库都放在/srv/git/下, 其权限改为777。创建一个裸仓库可有多种场景：场景1：远程主机管理者手动将别处的裸仓库上传到远程主机先在别处将目标仓库导出为裸仓库：$ git clone --bare my_project my_project.git 上述命令等价于把原仓库的.git/目录复制过来：$ cp -Rf my_project/.git my_project.git然后将裸仓库上传到远程主机：$ scp -P 10361 -r my_project.git git@git.taddream.site:/srv/git/场景2：远程主机管理者建空的裸仓库 + 项目贡献者推送初始版本先在远程主机创建空的公共仓库：$ sudo git init --bare /srv/git/pro2.git然后从任一用户本地推送第一个项目版本：cd projectgit initgit add .git commit -m &#x27;initial commit&#x27;# git remote add origin git@git.taddream.site:/srv/git/project.git # 若出现端口权限报错，则用下面的命令git remote add origin ssh://git@git.taddream.site:10361/srv/git/project.gitgit push origin master开发者开始使用公共仓库一旦裸仓库有了初始快照，用户们就可以（用ssh协议借助git账户和放置好的公钥）克隆了。clone: 当访问端口是默认的22，可用：git clone git@git.taddream.site:/srv/git/project.git当访问端口非22(e.g. 10361)，可用：git clone ssh://git@git.taddream.site:10361/srv/git/project.gitpush:git push origin master 如果push时出现写入权限报错，可对该公共仓库目录使用git init --bare --shared，或直接chmod 775，都能修改其组权限为所有用户可写。权限约束目前所有（获得授权的）开发者用户都能以系统用户 git 的身份登录服务器从而获得一个普通 shell。但远程主机系统管理员并不想让开发者对公共仓库之外有权限。约束1：将 git-shell (Git软件包中自带的受限shell工具)设置为用户 git 的登录 shell。约束方法：sudo chsh git -s $(which git-shell)效果：放置了公钥的开发者执行ssh git@git.taddream.site再也不能成功了，但git clone/push等仍有效。约束2：禁用端口转发约束原因：约束1并不能阻止开发者通过SSH端口转发获取git身份下的普通shell，因此需要对git身份禁用端口转发。方法：在 ~/.ssh/authorized_keys中，在指定的公钥条目开始位置，把ssh-rsa改为：txt更多的约束设置：查看git help shell 用Git协议搭建通过 “Git” 协议建立一个基于守护进程的仓库。TODO: 用到再研究。搭建方法见 用 smart HTTP搭建设置 Smart HTTP: 一般只需要在服务器上启用git-http-backend的CGI(命令网关接口)脚本。步骤： 系统环境准备 安装 Apache 作为web服务器及CGI服务器:sudo apt-get install apache2 apache2-utils # 安装Apachea2enmod cgi alias env headers ssl # 启用相关模块systemctl restart apache2 # 重启 确保主机的80或443端口开放。如有防火墙限制、需要端口转发等问题，请事先处理好。 改权限 允许web服务器对仓库目录的读写权限：chgrp -R www-data /srv/git 新建虚拟主机配置文件并设定权限：cd /etc/apache2/sites-availablesudo touch git-http.confsudo chgrp www-data git-http.conf # 若要递归，用`-R` 配置 在git-http.conf写入： &lt;VirtualHost *:80&gt; ServerName git.taddream.site DocumentRoot /var/www/gitweb ...&lt;/VirtualHost&gt; VirtualHost标签中添加git相关配置：让 git-http-backend脚本作为 Web 服务器对 /git 路径请求的CGI处理器。 SetEnv GIT_PROJECT_ROOT /srv/gitSetEnv GIT_HTTP_EXPORT_ALLScriptAlias /git/ /usr/lib/git-core/git-http-backend/ 如果留空 GIT_HTTP_EXPORT_ALL 这个环境变量，Git 将只对无授权客户端提供带 git-daemon-export-ok 文件的版本库，就像 Git 守护进程一样。 VirtualHost标签中添加授权验证(当对仓库有写入时) &lt;Files &quot;git-http-backend&quot;&gt; AuthType Basic AuthName &quot;Git Access&quot; AuthUserFile /srv/git/.htpasswd Require expr !(%&#123;QUERY_STRING&#125; -strmatch &#x27;*service=git-receive-pack*&#x27; || %&#123;REQUEST_URI&#125; =~ m#/git-receive-pack$#) Require valid-user&lt;/Files&gt; 其他配置对拉取操作也要授权验证：&lt;LocationMatch &quot;^/git/.*/git-receive-pack$&quot;&gt; Options +ExecCGI AuthType Basic AuthName &quot;Git Access&quot; AuthUserFile /etc/apache2/.htpasswd_project1 Require valid-user&lt;/LocationMatch&gt;其他 授权因为配置中用到了.htpasswd文件，所以需要添加 Apache 授权用户$ htpasswd -c /srv/git/.htpasswd yourname 如果已经创建过 .htpasswd 文件，去掉 -c命令执行后，终端会让你设置密码。完成后.htpasswd中会将密码加密存放。 重启启动虚拟主机，重启 Apache cd /etc/apache2/sites-availablea2ensite git-http.conf # 注意，`a2ensite`命令操作的目标文件一定不能带路径。systemctl restart apache2 bingo！测试 开发者已经可以用http来clone、fetch了：git clone http://git.taddream.site:10580/git/project.git 注：API中的/git/即服务器上的/srv/git/目录 开发者也能push的，如果此前对push操作（git-receive-pack）设置了授权验证，那么push过程会让你输入Apache的用户密码。 建立GitWebGitWeb是一个 Git 服务器的简易 web 界面，使用 GitWeb 来显示仓库的信息。 查看临时web使用轻量web服务器。见 持续维护的web使用gitweb软件包，包内有CGI脚本。 【准备软件包】 先获取gitweb目录：用whereis gitweb查看系统是否自带，若自带，一般存在于/usr/share/gitweb/; 若不自带，则用下述命令手动安装，得到./gitweb/目录。 git clone git://git.kernel.org/pub/scm/git/git.gitcd git/ make GITWEB_PROJECTROOT=&quot;/srv/git&quot; prefix=/usr gitweb 后移动目录：放到Apache默认网页目录下：sudo cp -Rf &lt;path of gitweb&gt; /var/www/ 最后配置gitweb: 为了指定git仓库目录，需在/etc/gitweb.conf(没有则创建)中写入$projectroot = &quot;/home/git/repositories&quot;; 【配置虚拟主机】还记得用smart HTTP搭建Git服务器里的配置环节吗？当时只实现了用http://git.taddream.site:10580来传输仓库(SetEnv GIT_PROJECT_ROOT), 而没有用这个url来同时实现仓库的网页查看(DocumentRoot)。为此我们配置如下: 修改VirtualHost标签里的DocumentRoot属性； 若用的系统自带的gitweb包，还需配置环境变量GITWEB_PROJECTROOT； 更新，不必配置该环境变量，只需配置/etc/gitweb.conf即可； 并增加Directory子标签。 DocumentRoot /var/www/gitwebSetEnv GITWEB_PROJECTROOT /srv/git&lt;Directory /var/www/gitweb&gt; Options +ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch AllowOverride All order allow,deny Allow from all AddHandler cgi-script cgi DirectoryIndex gitweb.cgi&lt;/Directory&gt; 在重启Apache(systemctl restart apache2)后，我们就可以访问http://git.taddream.site:10580来查看仓库了。 建立GitLab (better GitWeb)是比GitWeb更现代，功能更全的 Git 服务器。GitLab 是一个数据库支持的 web 应用，安装也更复杂。资料：git-&gt;gitlabTODO: 用到再研究该模块 Git的协作方式Git是分布式的，它可以很好地支持多人协作。 分布式工作流程集中式工作流属于单点协作模型。使用广泛。所有开发者都需要与仓库对齐。工作特点：不支持非快进式（non-fast-forward）推送，即push前须对仓库可能存在的更新进行fetch+merge。 集成管理者工作流GitHub&#x2F;GitLab中使用最广泛的。项目是只读的，开发者只能fork，想推送到master分支时只能呼叫请求管理者进行push。优点之一: 你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。流程见 主管与副主管工作流多见于大型项目, 如Linux内核。副主管（lieutenant），即各个集成管理者分别负责集成项目中的特定部分。主管（dictator），即总集成管理者负责统筹，维护参考仓库。 整合-管理者工作流类似于主管-副主管，但这里没有主管，而是副主管们形成集中式工作流。然后开发者和副主管之间的关系则来自集成管理者工作流。 贡献项目贡献原则 【纠错】：提交前要检查错误，特别是空白错误：git diff --check 【切小块】：每一次提交的变更，应该只针对一个小问题的解决，而不应该是多个小问题攒起来后再提交。 如果一个文件有大量修改，而想切小块多次提交怎么办：用交互式暂存，即git add --patch 【优质的提交信息】：git commit -m &quot;&lt;msg&gt;&quot;中，msg&#x3D; 少于50字节的摘要性描述(标题) + 一个空白行 + 详细的变更描述(正文)。 正文中可以有：空行来分段，项目符号 如数字和 - *，悬挂缩进等。 在不同级别的团队中 在私有小型团队中即项目为两三个人私有开发。多使用集中式工作流 在私有管理团队中即有很多人参与的不公开项目。多使用整合-管理者工作流 在公开项目-用fork-PR特点：没有权限直接更新项目的master分支，需要用到fork和pull request。工作流程： git clone &lt;project-url&gt;: 本地仓库将有一个origin连接project-url git checkout -b featureA：新建分支开始自己的工作 …work: 新增，修改，多次提交等 fork：去GitHub的项目主页派生 git remote add myfork &lt;forked-project-url&gt;: 添加remote，即你的派生仓库url git push -u myfork featureA origin没有权限，只能推送到派生仓库myfork;这里不是把featureA合并到master再推送到myfork&#x2F;master，而是保留主分支，直接推送featureA分支到新分支myfork&#x2F;featureA。 拉取请求(Pull Request)：通知原项目的维护者你有想要他们合并的工作。详见 等待管理者审查、讨论、合并，最终实现你的贡献被更新到原仓库的master上。 关于Pull-Request 方法1：在GitHub网页上进行 – 相当方便 PR流程：进入派生仓库的刚刚push的分支页面，会自动出现Compare &amp; PR按钮，进入按提示创建PR即可。如图： 一些重要的知识点： 【PR前不必总是 Fork】：当你对源项目有写权限，那就可以直接推送特性分支过去，然后手动创建一个master分支的PR页面，进行代码审查和讨论等协作。 【PR后仍可提交】：当你对特性分支发起PR后，讨论过程中仍可以在特性分支上继续提交。最终PR的merge会整合‘从PR前到讨论后’的所有改动。 【发起PR的场所】：任何分支上均可，甚至可在PR上发起PR 【派生仓库的master不要动】：建议你的工作在派生仓库的特性分支上进行，派生仓库的master多用来与源仓库的master对齐。 【不干净合并情况的处理】：不干净合并就是在PR时报错存在合并冲突。解决冲突有两种方法： 变基：（不推荐）派生仓库中，把你的特性分支，变基到master分支中。由于变基容易搅乱提交历史的性质。 反向合并: （推荐！）拉取源仓库的master，将其合并到你派生仓库的特性分支上，修复提示的冲突，推送回远程派生仓库的特性分支，再次发起PR。该过程类似于派生仓库的更新 【引用】：GitHub的评论中可以引用PR、issue、commit。 议题引用: 项目中所有的PR和Issue（议题）都会生成一个独一无二的编号以供引用。引用方式有三种： 直接引用当前仓库的PR&#x2F;Issue: #123 引用别人派生仓库的Issue：&lt;username&gt;#123 引用完全不同项目的PR&#x2F;Issue：&lt;username&gt;/&lt;projectName&gt;#123 提交引用：必须完整的写出 40 位长的 SHA-1 方法2：用git request-pull命令 git request-pull origin/master myfork: 命令解释：’origin&#x2F;master’是基础分支，即希望管理者在原项目的该分支上拉取我的贡献；’myfork’是给管理者指明应该去哪个url拉取内容。 命令输出：一个请求拉取的所有修改的摘要。这个摘要可以用来通过邮件发给项目管理员。 在公开项目-用邮件【不常用】该方法区别于fork+pull request: 这里是直接把每一次提交变成补丁文件，然后用邮件发给项目管理者。命令：git format-patch -M origin/master，得到每个提交生成的.patch文件，然后可以用git send-email *.patch命令发送，或手动发送那些文件。 维护项目如何成为一个项目的管理者。一般流程是：为将要整合的新东西新开分支 -&gt; 导入补丁到新分支 -&gt; 检查贡献内容 -&gt; 合并到原项目的目标分支(e.g. master) -&gt; 想发布时，可为发布打标签 -&gt; 为发布生成构建号 -&gt; 发布 -&gt; 制作提交简报。具体如下。 1、导入大家的贡献场景1：贡献者邮件传来.patch【该场景多用于贡献频率较低的开发者】工作流程为，①在原始仓库中开启新分支，用以测试补丁；②把补丁内容应用到工作目录，用以查看、检查、测试；③手动暂存并提交补丁所引入的更改；④按需把新补丁合并到master。其中第二步有两种情况： 情况1，.patch文件由git diff生成，可使用命令git apply /path/*.patch：该命令优于patch -p1。在执行前还可先检查补丁：git apply --check /path/*.patch。 情况2，.patch文件由git format-patch生成，可使用命令git am /path/*.patch: git am 是为了读取 mbox 文件而构建的， mbox 是一种用来在单个文本文件中存储一个或多个电子邮件消息的简单纯文本格式，.patch文件开头就是Mbox格式。 一个mbox 文件可以包含多个补丁文件。生成方法：开发者用git send-email发来所有补丁，你将其下载成mbox格式即可。 当更改过于复杂，补丁应用将失败，你可以： 手动解决所有标记出来的冲突（就和merge时一样），然后暂存文件，然后用git am --resolved告诉系统冲突解决，继续下一个文件。 也可用参数智能应对：git am -3 /path/*.patch，尝试三方合并的方法。前提是用于创建补丁的提交对象（即公共祖先）在你的版本库内。 场景2：贡献者用fork+PullRequest你此刻处于本地源仓库, 有多种方法对新补丁进行导入、审查、合并。 方法1：添加remote（多用于长期贡献的开发者） git remote add devlpr1 &lt;developer-forked-project-url&gt; # 添加开发者邮件中指定的`remote`git fetch devlpr1git checkout -b featureA devlpr1/featureA # 把开发者在派生仓库的特性分支，检出到本地的特性分支，同时设置好了`追踪`。 审核后没问题就可以合并了，具体怎么合并还要看你的工作流。 方法2：用临时抓取合并命令（多用于临时开发者的PR）git pull &lt;developer-forked-project-url&gt; &lt;featureA&gt;。审核后没问题就可以合并了，具体怎么合并还要看你的工作流。 方法3：PR页面上操作PR页面的merge pull request按钮会指导我们进行琐碎的拉取合并过程。如： 方法4：使用合并请求分支（多用于有大量PR时使用）PR分支的概述该方法的核心是，把PR引用的路径从对本地源仓库的隐身状态，变为可拉取可合并的显式分支。 处理单个PR时：-&gt; 获取PR编号如#372-&gt; 在git ls-remote origin中获取编号对应的索引路径，如refs/pull/372/head-&gt; 直接抓取该分支：git fetch origin refs/pull/372/head-&gt; 该分支合并到本地源仓库的测试分支:git checkout -b test; git merge FETCH_HEAD-&gt; 审查后就可以合并到master，伺机push了。 处理大量PR时： 先配置origin:打开./git/config，在[remote &quot;origin&quot;]模块下添加 txt其作用是让远程源仓库的所有看起来像refs/pull/123/head的引用应该在本地版本库像 refs/remotes/origin/pr/123 一样存储。 当然如果你有多个远程仓库，这里‘origin’也可换成你想要的‘shortname’。 后执行git fetch origin, 用fetch更新后，一次性把所有的PR分支都变成了显式分支 后检出一个PR分支: git checkout pr/123 审查后就可以合并到master，伺机push了。 2、检查贡献内容 查看贡献者独有的提交: git log featureA --not master（即master之后，featureA之前的提交） 查看贡献代码的具体差异： git diff master [featureA]: 用于master是featureA的直接祖先时； git diff $(git merge-base featureA master) [featureA]: 用于master有分叉后，应该手动寻找master与featureA的公共祖先后，再与贡献者的分支比较差异。 简化命令：git diff master...featureA, 该方法下对比的两个主体是：后者分支、两者的公共祖先分支。 3、合并贡献内容常见合并工作流–两阶段一旦本地源仓库有新内容的分支审核完毕，则将其合并入稳定的master分支，如此反复操作。在重要项目中，考虑使用两阶段合并循环: 你会维护两个长期分支，分别是 master 和 develop，master 分支只会在一个非常稳定的版本发布时才会更新，而所有的新代码会首先整合进入 develop 分支。 你定期将这两个分支推送到公共版本库中。 每次需要合并新的主题分支时, 应该合并进入 develop 分支； 当打标签发布的时候，你会将 master 分支快进到已经稳定的 develop 分支。 大项目合并工作流–四阶段资料： Git 维护者手册四个长期分支： master：稳定版本库。特点，始终在进行快进。 next：特点，偶尔会被变基。 pu（proposed updates）：用于新工作。特点，变基比较频繁。 maint（maintenance backports）：用于维护性向后移植工作工作流程： master分出不同的主题分支(理解为项目模块)； 贡献者们在不同的主题下工作，成果被收入各个主题分支，方法可参考fork+PR； 测试评估一个主题分支是否能合并，或者仍需要更多工作。 若可验收，将被并入 next 分支； 若需更多工作，将被并入 pu 分支； 之后当next或pu完全稳定，则再次并入 master 分支（实际就是master快进到next或pu分支）。 一个主题并入master后，便会被从版本库中删除掉。 在需要的时候，将发布一版新的master。同时上一版master会派生出maint分支，提供向后移植过来的补丁以供发布维护更新。 变基与拣选工作流有些维护者更喜欢保持线性的提交历史。具体使用参考 4、为发布打标签参考 5、生成构建号(可选)参考 6、准备一次发布创建一个最新的快照归档，封装成压缩包进行发布。 gzip格式：$ zip格式：$ 注：这里操作的分支是master；整个项目被放进了project目录再压缩的；因为使用了describe，所以要保证master此前有tag(with -a&#x2F;-S)。 7、制作提交简报shortlog可以快速生成一份包含从上次发布之后项目新增内容的修改日志（changelog）类文档，即给定范围内的所有提交的摘要的总结。git shortlog --no-merges master --not v1.0.1（ v1.0.1以来的所有提交的总结。） GitHub贡献项目常用的工作流程： 贡献者（fork &gt; clone &gt; work &gt; push &gt;PR，详见）， 管理者（审查、讨论、合并、关闭PR，都在网页上进行）。 每个分支都有自己的PR GitHub风格的Markdown它增加了一些基础的 Markdown 中做不到的东西。 它在创建拉取请求和议题中的评论和描述时十分有用。 任务列表方法： - [X] 编写代码- [ ] 编写所有测试程序- [ ] 为代码编写文档 效果：只需要点击复选框，就能更新评论 —— 你不需要直接修改 Markdown。在PR的总览页面上还能看到它的进度条。 引用别人评论的部分句子方法：你的评论中复制那些句子，在每行前添加 &gt; 符号即可。 表情符号方法：句首用:开头（e.g. :eye），句中则在冒号前加空格（e.g. :eye）。 让派生仓库保持更新 方法1：进入本地派生仓库的master &gt; 把远程的源仓库的master拉取合并到本地master &gt; 更新后的本地master推送到远程派生仓库 git checkout mastergit pull &lt;url&gt;git push origin master 方法2: 方法1的简化版，配置本地仓库remote里的fetch-url为项目源仓库的url、push-url保持为项目派生仓库的url。 git remote add forked_origin &lt;url&gt; # 添加源仓库的urlgit branch --set-upstream-to=forked_origin/master master # 通过修改追踪分支，来改变fetch-urlgit config --local remote.pushDefault origin # 保持push-url 最后使用简化的命令组合即可：$ 方法3: 直接在远程派生仓库的GitHub网页点击Sync fork即可。 维护项目· 1、创建新的版本库：其中，当分享url的时候，推荐HTTP(s)的，因为SSH的需要GitHub账号秘钥等。· 2、添加合作者：给他们push权限。· 4、PR中的提醒、通知和订阅。· 5、网页通知VS邮件通知。 3、管理合并请求（一些PR的知识点）先用邮件或PR页面对发起的一个PR进行通知、审查、讨论和改进。(邮件和评论是同步的)。然后当你决定要合并了，有这4种方法 6、特殊文件 README 贡献 CONTRIBUTING：指出对于你的项目开启的合并请求你想要的／不想要的各种事情。 这样别人在开启合并请求之前可以读到这些指导方针。 管理组织组织帐户代表了一组共同拥有多个项目的人，同时也提供一些工具用于对成员进行分组管理。TODO: 需要再学。 脚本GitHub介绍GitHub 钩子系统与 API 接口，使 GitHub 按照我们的设想来工作。 钩子TODO: 需要再学。https://docs.github.com/zh/webhooks GitHub API 针对不需要授权的接口，发送一个简单的 GET 请求即可； 需要授权的接口，使用访问令牌示例场景： 对一个特定议题写评论curl -H &quot;Content-Type: application/json&quot; \\ -H &quot;Authorization: token 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&quot; \\ --data &#x27;&#123;&quot;body&quot;:&quot;写下你的评论&quot;&#125;&#x27; \\ https://api.github.com/repos/JamesRay0713/blog-comments/issues/1/comments 修改PR的状态TODO: 需要再学。 https://git-scm.com/book/zh/v2/GitHub-%E8%84%9A%E6%9C%AC-GitHub#_修改_pull_request_的状态 Git工具交互式暂存交互式帮助你将文件的特定部分组合成提交，确保提交是逻辑上独立的变更集。 git add -i $ git add -i staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb*** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elpWhat now&gt; 其中，2让你选择要暂存的文件；5让你选择要暂存某个文件的哪些行。 更多‘文件的部分暂存’的命令： git add -p 相当于上面的5 git reset --patch 部分重置文件 git stash save –patch 部分暂存文件 git checkout –patch 部分检出文件 贮藏与清理贮藏· 使用场景：当前分支的工作有点难以理清，因此不能有效commit，此刻又需要另开分支做更要紧的事。· 作用：跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上，并将工作目录恢复到最后一次提交的状态。 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）。 贮藏也可当做有回退功能的清理工具· 使用方法： 在一个‘暂存区有未提交、工作目录有未暂存’的分支中 开启贮藏git stash [push] , git status会看到一个干净的分支。 贮藏的所有文件都是已跟踪状态。 查看历史贮藏git stash list 在当前分支中恢复贮藏git stash apply [stash@&#123;2&#125;] (若不指定宾语，则默认恢复stash@{0}) 除非使用--index，上面命令不会重新暂存。 在新建分支中恢复贮藏git stash branch &lt;branch1&gt; [&lt;stash&gt;] 恢复成功后自动丢弃贮藏。 移除：git stash drop [stash@&#123;0&#125;] 应用+移除：git stash pop [stash@&#123;0&#125;] · 更多参数： --keep-index -u 贮藏任何未跟踪文件 --patch 交互式指定需要贮藏的内容 清理它被设计为从工作目录中移除没有忽略的未跟踪的文件。 如果你改变主意了，你也不一定能找回来那些文件的内容。安全期间，决定清理时，先用-n，再改成-f。 安全清理的替代方式：git stash --all 移除工作目录中所有未追踪的文件以及空的子目录-d: git clean -df 演习式清理–dry-run 或 -n ：git clean -d -n 包含忽略文件：-x 签名工具GPG参考。可以签名&#x2F;验证签名的一些命令：-S&#x2F;-s 签：git tag -s v1.5 -m &#39;my signed 1.5 tag&#39; 签：git commit -a -S -m &#39;signed commit&#39; 签：git merge --verify-signatures -S &lt;branch1&gt; 看：git log --show-signature -1, git log --pretty=&quot;format:%h %G? %aN %s&quot;(%G) 验：git merge --verify-signatures &lt;branch1&gt; 检查并拒绝没有携带可信 GPG 签名的提交 搜索搜文件git grep &lt;string&gt;从提交历史、工作目录、甚至索引中查找一个’字符串’或者’正则表达式’。参数： -n 或 –line-number 选项数来输出 Git 找到的匹配行的行号。 -c 或 –count 只输出匹配数。 -p 或 –show-function 显示每一个匹配的字符串所在的方法或函数 –and 确保了多个匹配出现在同一文本行中 搜提交 git log -S &lt;string/常量名&gt; 显示新增和删除该字符串的提交 -L 展示代码中一行或者一个函数的历史。 git log -L :git_deflate_bound:zlib.c: 查看 zlib.c 文件中 git_deflate_bound 函数的每一次变更. 重写历史即修改历史提交，其原则是：你要修改的提交，一定不能是已经push了的提交！！！有以下两种使用场景： 修改最后一次提交【可修改内容、也可修改提交信息】步骤：先在工作目录中修改、增删你的文件 -&gt; git add -&gt; git commit --amend -&gt; 自动进入编辑器，写入新的‘commit message’ -&gt; 完成。效果：你的最新一次的commit实现了变更，commit的校验和也刷新了，但不会新增一个提交。 --no-edit 选项可以跳过编辑提交信息。 同时处理多个提交· 该场景下我们有多种目的：批量修改提交信息、重排序多个提交、压缩多个提交、拆分任意一个提交等。· 实现它们的核心是git rebase -i HEAD~3，基于交互式的变基工具中的自定义脚本，从你在命令行中指定的提交（HEAD~3）开始，从上到下的依次重演每一个提交引入的修改。 注意：变基范围的选择易搞错。例如想重写最近的3次提交(HEAD, HEAD, HEAD2)，则应该把’最远的那个提交(HEAD~2)的父提交(^)’传给命令，即HEAD~3。 · 【总体步骤】是： 执行git rebase -i HEAD~3，自动进入文本编辑器，可以看到有多个pick行，对应你指定的HEAD~3后的每一个提交。形如rebase-i的编辑器pick 993162d updatepick e790f14 iafter rebapick b7b18ae uuu---update# Rebase 4acbfd9..b7b18ae onto 4acbfd9 (3 commands)## Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous# commit&#x27;s log message, unless -C is used, in which case# keep only this commit&#x27;s message; -c is same as -C but# opens the editor# x, exec &lt;command&gt; = run command (the rest of the line) using shell# b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)# d, drop &lt;commit&gt; = remove commit# l, label &lt;label&gt; = label current HEAD with a name# t, reset &lt;label&gt; = reset HEAD to a label# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]# create a merge commit using the original merge commit&#x27;s# message (or the oneline, if no original merge commit was# specified); use -c &lt;commit&gt; to reword the commit message# u, update-ref &lt;ref&gt; = track a placeholder for the &lt;ref&gt; to be updated# to this position in the new commits. The &lt;ref&gt; is# updated at the end of the rebase## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.# 注释里有脚本的完整教程。注意：pick行的顺序是‘历史提交的正向顺序’，即从旧到新，跟git log的输出相反。 编辑该脚本，以满足你重写历史的目的。参考下面的多个子标题的例子。 保存退出，会自动运行脚本，并自动给出接下来你需要怎么做的命令提示。同时终端会提示你正处于脚本的哪个进度： 按提示执行命令、解决冲突…（当提示中有git add &lt;file&gt;时，你甚至可以在工作区修改部分文件内容再add，当然这会有后序commit的更多冲突让你手动解决），完成！ 脚本1：修改一个&#x2F;多个历史的提交信息· 编辑脚本：把你想修改的commitID前的pick改成edit。· 脚本执行：会提示你使用git commit --amend，该命令会进入第一个edit行的commit的提交信息编辑器。编辑后执行提示命令git rebase --continue，运行下一行脚本。逐行应用，直到完成。 脚本2：删除部分历史提交· 编辑脚本：直接删除那些提交对应的行。· 脚本执行：按提示即可。(可能用到git add .等)· 最终效果：被删commit之后的commitID都将更新。 脚本3：重排序历史提交· 编辑脚本：直接更换pick行的顺序，注意从上到下是从旧到新。· 脚本执行、最终效果：同脚本2。 脚本4：Git仓库工具可视化工具gitk轻量GitWeb git instaweb --httpd=lighttpd: 开启web, 默认1234端口。若不带httpd，则默认使用lighttpd。也可指定其他web服务器：apache2、webrick等，若系统没有则apt下载。 git instaweb --httpd=lighttpd --stop: 关闭web。 引用规范：“refspec.” 它是一种把 remote 的名称映射到你本地 .git 目录的方法。"},{"title":"HTML+CSS+JS+jQuery+AJAX","path":"/wiki/my-notes/html-css-js.html","content":"至少掌握HTML, DOM -&gt; CSS -&gt; JavaScript -&gt; jQuery -&gt; AJAX，在线工具 HTML资料：教程; 手册:标签-属性等。元素（Element）&#x3D;开始标签（Tag，含属性(Attribute)）+内容（Content）+结束标签。 CSS资料：教程; 手册:选择器-属性等。 快速入门C层叠S样式S表，使网页样式、布局更高效规范。本质来讲，CSS都是对HTML元素的style属性进行定义。 语法： 属性与值之间只有冒号，没有空格。 选择器：用于限定后面这组声明的使用范围。常见的选择器： 元素选择器 选择一种HTML元素，如：p &#123; color:blue; &#125;； 类选择器 选择class属性为特定值的所有HTML元素，如：.highlight &#123; color:yellow; &#125;; 选择class属性为特定值的一种HTML元素，如：p.highlight &#123; color:yellow; &#125;; ID选择器 选择id属性为特定值的那一个HTML元素，如：#runoob &#123; width:200px; &#125;; 属性选择器 选择指定属性为特定值的指定HTML元素，如：nput[type=&quot;text&quot;] &#123;border:1px solid gray;&#125;; 后代、兄弟、伪类、伪元素选择器…… css代码的3种出现方式 内联样式： 一个元素的临时装饰，位于HTML标签的style属性中，如：&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt; 内部样式表：一个文档多处可复用，位于html.head.style元素的内容中，如： &lt;head&gt; &lt;style&gt; hr &#123;color:sienna;&#125; p &#123;margin-left:20px;&#125; body &#123;background-image:url(&quot;images/back40.gif&quot;);&#125; &lt;/style&gt;&lt;/head&gt; 外部样式表：独立文件随处使用，位于html.head.link元素的href属性中，如： \"mystyle.css\"即外部样式表&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;&lt;/head&gt; JavaScript资料：教程, DOM文档对象模型, BOM浏览器对象模型; 手册：内置对象-Browser对象-DOM对象；。 基础知识 数据类型： 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。 引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date） JS对象：在 JavaScript中，几乎所有的事物都是对象。 ‘对象’实例：var person = &#123; firstName: &quot;John&quot;, // 这是对象属性，值的访问方式：`person.firstName` lastName : &quot;Doe&quot;, id : 5566, fullName : function() // 访问时，不加`()`是对象属性；加`()`是对象方法。 &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;&#125;; JS对象是变量的容器、键值对的容器、 DOM BOM 所有JS全局对象、函数以及变量均自动成为 window 对象的成员。全局变量是 window 对象的属性。全局函数是 window 对象的方法。甚至 HTML DOM的document也是window对象的属性之一。 JS高级程序设计工具——JS库&#x2F;框架 jQuery：是目前最受欢迎的 JavaScript 框架。它使用 CSS 选择器来访问和操作网页上的 HTML 元素（DOM 对象）。jQuery 同时提供 companion UI（用户界面）和插件。见下一节。 Prototype 简单使用方法 与 jQuery 类似，Prototype 也有自己的 $() 函数。$() 函数接受 HTML DOM 元素的 id 值（或 DOM 元素），并会向 DOM 对象添加新的功能。 与 jQuery 不同，Prototype 没有用以取代 window.onload() 的 ready() 方法。相反，Prototype 会向浏览器及 HTML DOM 添加扩展。 … jQuery哈资料：教程；参考手册；API手册 基础知识jQuery 是一个 JavaScript 库。jQuery 极大地简化了 JavaScript 编程。 该库的功能HTML 元素选取HTML 元素操作CSS 操作HTML 事件函数JavaScript 特效和动画HTML DOM 遍历和修改AJAXUtilities除此之外，jQuery 还提供了大量的插件。 使用方法： 先在网页的&lt;script&gt;标签中引用该库，如：&lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt; 为更快引入，可修改src为jquary的合适的CDN地址，如: 国外的（https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js、https://cdnjs.com/…）， 国内的（https://cdn.staticfile.org/jquery/3.4.0/jquery.min.js） 疑惑为什么没有在 &lt;script&gt; 标签中使用 type=&quot;text/javascript&quot; ？在 HTML5 中，JavaScript 是 HTML5 以及所有现代浏览器中的默认脚本语言！ 语法：核心：选取 HTML 元素，执行操作。基础语法： $(selector).action() 关于选择器：jQuery 使用的语法是 XPath 与 CSS 选择器语法的组合。 AJAX资料：教程AJAX（异步的 JavaScript 和 XML）是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。AJAX不是语言，是一套标准。 NodeJS包管理工具 镜像源node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/"},{"path":"/wiki/my-notes/index.html","content":"该wiki大纲如下"},{"title":"web服务器-Apache","path":"/wiki/my-notes/server-webserver-apache.html","content":"本文操作的环境为ubuntu18.04 一些概念虚拟主机虚拟主机允许在同一台服务器上运行多个网站，有两种实现方式： 基于域名的VH最常见。一台服务器的 IP 地址可以被多个域名共享，服务器通过检查 HTTP 请求中的 Host 头部来确定请求的目标域名，然后Apache把请求路由到相应的虚拟主机配置。 注意：在DNS服务商那里，这里涉及到的那些域名，都应该被解析到Apache所在的服务器IP。相当于多个域名共用一个IP，却能拥有不同的网站目录。 基于IP的VH。 配置/var/www//usr/share 一些命令 列出正在监听的虚拟主机：sudo apache2ctl -S 虚拟主机： 开启：a2ensite git-http.conf(注意：配置文件一定不能带路径前缀。只需输入文件名，Apache会自动找到其文件路径的。) 关闭：a2dissite"},{"title":"debug集合","path":"/wiki/my-notes/set-of-debug-and-pieces-of-knowledge.html","content":"debug集合跳转debug手册 知识点：网站建设网站的备案与申请SSL证书阿里备案的，需要买至少3个月的服务器，最便宜好像是150左右服务码：去淘宝买阿里云服务码，才两块钱一个；有了服务码就不需要买服务器了，光有服务码备案也能通过；两块钱嫖遍国内 CDN。阿里云的【数字证书管理服务 -&gt; SSL 证书】，每年可以免费领20个，我一开始也是失败，后来发现申请主站证书的时候要把 @ 和 www 解析都暂停掉才可以。筛选最近3条todo筛选评论最多的3条建议"},{"title":"Git-SDK安装与配置","path":"/wiki/yinxiang/Git-SDK安装与配置.html","content":"发表于 2022-05-20 更新于 2022-06-09 上一级页面：index-windows 前言Git作为代码管理程序，自带一个好用的shell工具–Git Bash 但在Windows中，git发行版自带的git bash是阉割版，git sdk for windows则包含一个完整版本的git bash，并且提供了一套基本完整的集成开发环境 故此，在Windows环境下，推荐首先安装git sdk，git sdk包含了一个完整的git bash，本文将给出详细配置。 然后再通过git sdk来安装git，本文将给出安装过程 Git SDK 简介Git SDK 全称 Git for Windows SDK，是基于 MSYS2（MinGW64 + Cygwin 合体增强）的仿 Linux 环境； 安装后大约会占用 4~5 GB 的磁盘空间，但是包含了完整的仿 Linux 环境：包括常用工具，完整的 GNU Complier 链以及包管理器 pacman；基本上是一套完整的集成开发环境，所以是 SDK 此外，虽然 Git SDK 是基于 MSYS2 的，是 Git 的超集…… 但是你仍然需要安装 Git，本文将给出安装过程 建议安装 Git SDK 而不是 MSYS2，因为前者比后者好用 安装git发行版 git for windows要安装git sdk，需要先安装git，你可以去 Git for Windows 官网，点击如图按钮下载 安装 Git SDK你可以去 Git for Windows 官网，拉到最下面可以看到 Git SDK 的下载；这样下载的是一个安装器，会自动从一个仓库克隆这个程序所需要的全部文件但是下载速度感人， 下载Git for Windows SDK: Release Git for Windows SDK v1.0.8 · git-for-windows&#x2F;build-extra 安装步骤如下： 将解压后的文件放在某个位置，将这个路径记为git-sdk安装目录 安装有点慢，先设置走代理 1234# https协议设置走 HTTP 隧道代理git config --global http.proxy \"http://127.0.0.1:1080\"# 下面这条会丧失安全性git config --global https.proxy \"http://127.0.0.1:1080\" 具体其他的详情见git-连接远程服务器的代理方案 等待自动化安装过程： 如果安装过程中，报错安装失败，检查代理设置后， 手动打开C:\\git-sdk-64，显示系统隐藏文件，然后删除.git文件夹，然后手动管理员身份运行C:\\git-sdk-64下的setup-git-sdk.bat git bash with git sdk设置网络代理进行网络代理配置，详情见 index-proxy 配置环境变量将安装目录下的/cmd文件夹加入系统变量 注意：\\usr\\bin目录最好不要加到系统变量，避免与其他类似工具比如 Gow 产生冲突，所 另外一方面，要在cmd等shell中使用git，也需要配置这个环境变量 更新源和核心包修改 pacman 软件包源为国内源在 /etc/pacman.d/ 目录下有三个文件：mirrorlist.msys、mirrorlist.mingw64 和 mirrorlist.mingw32；我们可以直接在 Windows 中使用文本编辑器修改它们为国内源： 1234567891011## ## MSYS2 repository mirrorlist ## ## Primary ## msys2.org Server = http://mirrors.ustc.edu.cn/msys2/msys/$arch/ Server = http://repo.msys2.org/msys/$arch Server = http://downloads.sourceforge.net/project/msys2/REPOS/MSYS2/$arch Server = http://www2.futureware.at/~nickoe/msys2-mirror/msys/$arch/ Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch/ 1234567891011## ## 64-bit Mingw-w64 repository mirrorlist ## ## Primary ## msys2.org Server = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/ Server = http://repo.msys2.org/mingw/x86_64 Server = http://downloads.sourceforge.net/project/msys2/REPOS/MINGW/x86_64 Server = http://www2.futureware.at/~nickoe/msys2-mirror/x86_64/ Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64/ 1234567891011## ## 32-bit Mingw-w64 repository mirrorlist ## ## Primary ## msys2.org Server = http://mirrors.ustc.edu.cn/msys2/mingw/i686/ Server = http://repo.msys2.org/mingw/i686 Server = http://downloads.sourceforge.net/project/msys2/REPOS/MINGW/i686 Server = http://www2.futureware.at/~nickoe/msys2-mirror/i686/ Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686/ 注意服务器的顺序，将国内服务器放在优先的位置才能保证 pacman 优先使用它； 更新git SDKUpdating your SDK。 更新SDK需要关掉所有的GitBash窗口，以防有文件被锁住。 需要启动Windows的cmd来更新，然后进入C:\\git-sdk-64\\。 然后在此cmd窗口中执行update-via-pacman.bat。 不管有没有更新，每次总会重装git-extra。 也可以直接在文件浏览器中双击运行update-via-pacman.bat来完成更新。 还可以调用pacman -Syu来更新。过程中可能需要关掉重开git-bash，也许需要多次执行pacman -Syu。 更新核心软件包核心的软件包msys2-runtime、 bash以及pacman还可以通过pacman -Syu来一起更新，因为这些软件在编译的时候互相依赖。 要保证他们的互相依赖是正确的。 1pacman -Syu 另一可选的办法是执行执行C:\\git-sdk-64\\git-cmd来弹出一个cmd窗口，在其中执行pacman -Sy --needed msys2-runtime &amp;&amp; pacman -S --needed pacman bash。 执行C:\\git-sdk-64\\git-cmd。 更新核心运行时，更新pacman，并更新bash 123pacman -Sy --needed msys2-runtimepacman -Sy --needed pacmanpacman -Sy --needed bash 建议将msys2-runtime、bash和pacman分开来，单独升级。总之有可能会遇到比较奇怪的问题。 遇到某些错误无法更新如果遇到某些错误无法更新，那么总是可以选择下载一个新的SDK，重新安装之。过程中，你可以选择保留旧SDK中的usr/src，将其同步到新的SDK中。 也可以查看git update-git-for-windows -h。 更新pacman源运行git sdk 更新源信息，首次更新可能需要重启； 1pacman -Syu pacman -Sy可以确保软件包最新。pacman -Syu将所有软件包升级到最新。 使用pacman安装gitwindows下通过git sdk来安装git 1pacman -S git git是最常用的代码管理系统，git的使用见git-安装-配置 卸载git 发行版在Windows中，git发行版自带的git bash是阉割版，git sdk for windows则包含一个完整版本的git bash，并且提供了一套基本完整的集成开发环境，还可以通过git sdk来安装git 此时可以卸载系统中原本的git 发行版， 进入Git for Windows 官网， 如图所示，你点击图中按钮下载的就是git发行版，现在已经可以卸载这个发行版了 安装常用包可以通过pacman -S &lt;package-name&gt;安装软件包 安装git、wget 12pacman -S wgetpacman -S git pacman没有自带的perl。安装perl 1pacman -S perl 为git bash添加 sudo 命令:gsudo-sudo 常用命令Package management Git for Windows基于MSYS2。MSYS2和MSYS1相比，引进了包管理器msys。 更多参考The difference between MINGW and MSYS2 可以通过pacman -S &lt;package-name&gt;安装软件包。-Sy可以确保软件包最新。pacman -Syu将所有软件包升级到最新。 删除软件包pacman -R &lt;package-name&gt; 列举软件包pacman -Q；查询软件包内容pacman -Ql &lt;package-name&gt;；查询文件所属的软件包pacman -Qo &lt;file-name&gt;。 仓库Git for windows有三个相关的pacman仓库 https://github.com/git-for-windows/build-extra https://github.com/git-for-windows/MINGW-packages https://github.com/git-for-windows/MSYS2-packages 常见问题Git-Bash的文件映射 参考、引用、致谢在 Windows 10 中使用 zsh 作为默认终端 - 七海の参考書 (shiraha.cn) 在 Windows 10 中使用 zsh 作为默认终端 - 七海の参考書 (shiraha.cn) Windows Terminal美化（oh-my-posh3） - 知乎 (zhihu.com) Git for Windows的编译环境 | Marvin’s Blog【程式人生】 (marvinsblog.net)"},{"title":"文章收录","path":"/wiki/yinxiang/index.html","content":"Git-SDK安装与配置"}]